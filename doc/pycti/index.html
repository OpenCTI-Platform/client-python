<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>pycti API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>pycti</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
from .api.opencti_api_client import OpenCTIApiClient
from .api.opencti_api_connector import OpenCTIApiConnector
from .api.opencti_api_job import OpenCTIApiJob

from .connector.opencti_connector import ConnectorType
from .connector.opencti_connector import OpenCTIConnector
from .connector.opencti_connector_helper import (
    OpenCTIConnectorHelper,
    get_config_variable,
)

from .entities.opencti_tag import Tag
from .entities.opencti_marking_definition import MarkingDefinition
from .entities.opencti_external_reference import ExternalReference
from .entities.opencti_kill_chain_phase import KillChainPhase
from .entities.opencti_stix_entity import StixEntity
from .entities.opencti_stix_domain_entity import StixDomainEntity
from .entities.opencti_stix_observable import StixObservable
from .entities.opencti_stix_relation import StixRelation
from .entities.opencti_stix_observable_relation import StixObservableRelation
from .entities.opencti_identity import Identity
from .entities.opencti_threat_actor import ThreatActor
from .entities.opencti_intrusion_set import IntrusionSet
from .entities.opencti_campaign import Campaign
from .entities.opencti_incident import Incident
from .entities.opencti_malware import Malware
from .entities.opencti_tool import Tool
from .entities.opencti_vulnerability import Vulnerability
from .entities.opencti_attack_pattern import AttackPattern
from .entities.opencti_course_of_action import CourseOfAction
from .entities.opencti_report import Report
from .entities.opencti_note import Note
from .entities.opencti_opinion import Opinion
from .entities.opencti_indicator import Indicator

from .utils.opencti_stix2 import OpenCTIStix2
from .utils.constants import ObservableTypes
from .utils.constants import CustomProperties

__all__ = [
    &#34;OpenCTIApiClient&#34;,
    &#34;OpenCTIApiConnector&#34;,
    &#34;OpenCTIApiJob&#34;,
    &#34;ConnectorType&#34;,
    &#34;OpenCTIConnector&#34;,
    &#34;OpenCTIConnectorHelper&#34;,
    &#34;get_config_variable&#34;,
    &#34;Tag&#34;,
    &#34;MarkingDefinition&#34;,
    &#34;ExternalReference&#34;,
    &#34;KillChainPhase&#34;,
    &#34;StixEntity&#34;,
    &#34;StixDomainEntity&#34;,
    &#34;StixObservable&#34;,
    &#34;StixRelation&#34;,
    &#34;StixObservableRelation&#34;,
    &#34;Identity&#34;,
    &#34;ThreatActor&#34;,
    &#34;IntrusionSet&#34;,
    &#34;Campaign&#34;,
    &#34;Incident&#34;,
    &#34;Malware&#34;,
    &#34;Tool&#34;,
    &#34;Vulnerability&#34;,
    &#34;AttackPattern&#34;,
    &#34;CourseOfAction&#34;,
    &#34;Report&#34;,
    &#34;Note&#34;,
    &#34;Opinion&#34;,
    &#34;Indicator&#34;,
    &#34;OpenCTIStix2&#34;,
    &#34;ObservableTypes&#34;,
    &#34;CustomProperties&#34;,
]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="pycti.api" href="api/index.html">pycti.api</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="pycti.connector" href="connector/index.html">pycti.connector</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="pycti.entities" href="entities/index.html">pycti.entities</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="pycti.utils" href="utils/index.html">pycti.utils</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pycti.get_config_variable"><code class="name flex">
<span>def <span class="ident">get_config_variable</span></span>(<span>envvar, yaml_path, config={}, isNumber=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_config_variable(envvar, yaml_path, config={}, isNumber=False):
    if os.getenv(envvar) is not None:
        result = os.getenv(envvar)
    elif yaml_path is not None:
        if yaml_path[0] in config and yaml_path[1] in config[yaml_path[0]]:
            result = config[yaml_path[0]][yaml_path[1]]
        else:
            return None
    else:
        return None

    if result == &#34;yes&#34; or result == &#34;true&#34; or result == &#34;True&#34;:
        return True
    elif result == &#34;no&#34; or result == &#34;false&#34; or result == &#34;False&#34;:
        return False
    elif isNumber:
        return int(result)
    else:
        return result</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pycti.AttackPattern"><code class="flex name class">
<span>class <span class="ident">AttackPattern</span></span>
<span>(</span><span>opencti)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AttackPattern:
    def __init__(self, opencti):
        self.opencti = opencti
        self.properties = &#34;&#34;&#34;
            id
            stix_id_key
            stix_label
            entity_type
            parent_types
            name
            alias
            description
            graph_data
            platform
            required_permission
            external_id
            created
            modified
            created_at
            updated_at
            killChainPhases {
                edges {
                    node {
                        id
                        entity_type
                        stix_id_key
                        kill_chain_name
                        phase_name
                        phase_order
                        created
                        modified
                    }
                    relation {
                        id
                    }
                }
            }
            createdByRef {
                node {
                    id
                    entity_type
                    stix_id_key
                    stix_label
                    name
                    alias
                    description
                    created
                    modified
                    ... on Organization {
                        organization_class
                    }
                }
                relation {
                    id
                }
            }            
            markingDefinitions {
                edges {
                    node {
                        id
                        entity_type
                        stix_id_key
                        definition_type
                        definition
                        level
                        color
                        created
                        modified
                    }
                    relation {
                        id
                    }
                }
            }
            tags {
                edges {
                    node {
                        id
                        tag_type
                        value
                        color
                    }
                    relation {
                        id
                    }
                }
            }
            externalReferences {
                edges {
                    node {
                        id
                        entity_type
                        stix_id_key
                        source_name
                        description
                        url
                        hash
                        external_id
                        created
                        modified
                    }
                    relation {
                        id
                    }
                }
            }        
        &#34;&#34;&#34;

    &#34;&#34;&#34;
        List Attack-Pattern objects

        :param filters: the filters to apply
        :param search: the search keyword
        :param first: return the first n rows from the after ID (or the beginning if not set)
        :param after: ID of the first row for pagination
        :return List of Attack-Pattern objects
    &#34;&#34;&#34;

    def list(self, **kwargs):
        filters = kwargs.get(&#34;filters&#34;, None)
        search = kwargs.get(&#34;search&#34;, None)
        first = kwargs.get(&#34;first&#34;, 500)
        after = kwargs.get(&#34;after&#34;, None)
        order_by = kwargs.get(&#34;orderBy&#34;, None)
        order_mode = kwargs.get(&#34;orderMode&#34;, None)
        get_all = kwargs.get(&#34;getAll&#34;, False)
        if get_all:
            first = 500

        self.opencti.log(
            &#34;info&#34;, &#34;Listing Attack-Patterns with filters &#34; + json.dumps(filters) + &#34;.&#34;
        )
        query = (
            &#34;&#34;&#34;
            query AttackPatterns($filters: [AttackPatternsFiltering], $search: String, $first: Int, $after: ID, $orderBy: AttackPatternsOrdering, $orderMode: OrderingMode) {
                attackPatterns(filters: $filters, search: $search, first: $first, after: $after, orderBy: $orderBy, orderMode: $orderMode) {
                    edges {
                        node {
                            &#34;&#34;&#34;
            + self.properties
            + &#34;&#34;&#34;
                        }
                    }
                    pageInfo {
                        startCursor
                        endCursor
                        hasNextPage
                        hasPreviousPage
                        globalCount
                    }
                }
            }
        &#34;&#34;&#34;
        )
        result = self.opencti.query(
            query,
            {
                &#34;filters&#34;: filters,
                &#34;search&#34;: search,
                &#34;first&#34;: first,
                &#34;after&#34;: after,
                &#34;orderBy&#34;: order_by,
                &#34;orderMode&#34;: order_mode,
            },
        )
        if get_all:
            final_data = []
            data = self.opencti.process_multiple(result[&#34;data&#34;][&#34;attackPatterns&#34;])
            final_data = final_data + data
            while result[&#34;data&#34;][&#34;attackPatterns&#34;][&#34;pageInfo&#34;][&#34;hasNextPage&#34;]:
                after = result[&#34;data&#34;][&#34;attackPatterns&#34;][&#34;pageInfo&#34;][&#34;endCursor&#34;]
                self.opencti.log(&#34;info&#34;, &#34;Listing Attack-Patterns after &#34; + after)
                result = self.opencti.query(
                    query,
                    {
                        &#34;filters&#34;: filters,
                        &#34;search&#34;: search,
                        &#34;first&#34;: first,
                        &#34;after&#34;: after,
                        &#34;orderBy&#34;: order_by,
                        &#34;orderMode&#34;: order_mode,
                    },
                )
                data = self.opencti.process_multiple(result[&#34;data&#34;][&#34;attackPatterns&#34;])
                final_data = final_data + data
            return final_data
        else:
            return self.opencti.process_multiple(result[&#34;data&#34;][&#34;attackPatterns&#34;])

    &#34;&#34;&#34;
        Read a Attack-Pattern object
        
        :param id: the id of the Attack-Pattern
        :param filters: the filters to apply if no id provided
        :return Attack-Pattern object
    &#34;&#34;&#34;

    def read(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        filters = kwargs.get(&#34;filters&#34;, None)
        custom_attributes = kwargs.get(&#34;customAttributes&#34;, None)
        if id is not None:
            self.opencti.log(&#34;info&#34;, &#34;Reading Attack-Pattern {&#34; + id + &#34;}.&#34;)
            query = (
                &#34;&#34;&#34;
                query AttackPattern($id: String!) {
                    attackPattern(id: $id) {
                        &#34;&#34;&#34;
                + (
                    custom_attributes
                    if custom_attributes is not None
                    else self.properties
                )
                + &#34;&#34;&#34;
                    }
                }
             &#34;&#34;&#34;
            )
            result = self.opencti.query(query, {&#34;id&#34;: id})
            return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;attackPattern&#34;])
        elif filters is not None:
            result = self.list(filters=filters)
            if len(result) &gt; 0:
                return result[0]
            else:
                return None
        else:
            self.opencti.log(
                &#34;error&#34;, &#34;[opencti_attack_pattern] Missing parameters: id or filters&#34;
            )
            return None

    &#34;&#34;&#34;
        Create a Attack-Pattern object

        :param name: the name of the Attack Pattern
        :return Attack-Pattern object
    &#34;&#34;&#34;

    def create_raw(self, **kwargs):
        name = kwargs.get(&#34;name&#34;, None)
        description = kwargs.get(&#34;description&#34;, None)
        alias = kwargs.get(&#34;alias&#34;, None)
        platform = kwargs.get(&#34;platform&#34;, None)
        required_permission = kwargs.get(&#34;required_permission&#34;, None)
        external_id = kwargs.get(&#34;external_id&#34;, None)
        id = kwargs.get(&#34;id&#34;, None)
        stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
        created = kwargs.get(&#34;created&#34;, None)
        modified = kwargs.get(&#34;modified&#34;, None)
        created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
        marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)
        kill_chain_phases = kwargs.get(&#34;killChainPhases&#34;, None)

        if name is not None and description is not None:
            self.opencti.log(&#34;info&#34;, &#34;Creating Attack-Pattern {&#34; + name + &#34;}.&#34;)
            query = (
                &#34;&#34;&#34;
                mutation AttackPatternAdd($input: AttackPatternAddInput) {
                    attackPatternAdd(input: $input) {
                        &#34;&#34;&#34;
                + self.properties
                + &#34;&#34;&#34;
                    }
                }
            &#34;&#34;&#34;
            )
            result = self.opencti.query(
                query,
                {
                    &#34;input&#34;: {
                        &#34;name&#34;: name,
                        &#34;description&#34;: description,
                        &#34;alias&#34;: alias,
                        &#34;platform&#34;: platform,
                        &#34;required_permission&#34;: required_permission,
                        &#34;external_id&#34;: external_id,
                        &#34;internal_id_key&#34;: id,
                        &#34;stix_id_key&#34;: stix_id_key,
                        &#34;created&#34;: created,
                        &#34;modified&#34;: modified,
                        &#34;createdByRef&#34;: created_by_ref,
                        &#34;markingDefinitions&#34;: marking_definitions,
                        &#34;killChainPhases&#34;: kill_chain_phases,
                    }
                },
            )
            return self.opencti.process_multiple_fields(
                result[&#34;data&#34;][&#34;attackPatternAdd&#34;]
            )
        else:
            self.opencti.log(
                &#34;error&#34;,
                &#34;[opencti_attack_pattern] Missing parameters: name and description&#34;,
            )

    &#34;&#34;&#34;
        Create a Attack-Pattern object only if it not exists, update it on request

        :param name: the name of the Attack-Pattern
        :return Attack-Pattern object
    &#34;&#34;&#34;

    def create(self, **kwargs):
        name = kwargs.get(&#34;name&#34;, None)
        description = kwargs.get(&#34;description&#34;, None)
        alias = kwargs.get(&#34;alias&#34;, None)
        platform = kwargs.get(&#34;platform&#34;, None)
        required_permission = kwargs.get(&#34;required_permission&#34;, None)
        external_id = kwargs.get(&#34;external_id&#34;, None)
        id = kwargs.get(&#34;id&#34;, None)
        stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
        created = kwargs.get(&#34;created&#34;, None)
        modified = kwargs.get(&#34;modified&#34;, None)
        created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
        marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)
        kill_chain_phases = kwargs.get(&#34;killChainPhases&#34;, None)
        update = kwargs.get(&#34;update&#34;, False)
        custom_attributes = &#34;&#34;&#34;
            id
            entity_type
            name
            description 
            alias
            ... on AttackPattern {
                platform
                required_permission
                external_id
                
            }
        &#34;&#34;&#34;
        object_result = self.opencti.stix_domain_entity.get_by_stix_id_or_name(
            types=[&#34;Attack-Pattern&#34;],
            stix_id_key=stix_id_key,
            name=name,
            customAttributes=custom_attributes,
        )
        if object_result is None and external_id is not None:
            object_result = self.read(
                filters=[{&#34;key&#34;: &#34;external_id&#34;, &#34;values&#34;: [external_id]}]
            )
        if object_result is not None:
            if update:
                # name
                if object_result[&#34;name&#34;] != name:
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;name&#34;, value=name
                    )
                    object_result[&#34;name&#34;] = name
                # description
                if object_result[&#34;description&#34;] != description:
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;description&#34;, value=description
                    )
                    object_result[&#34;description&#34;] = description
                # alias
                if alias is not None and object_result[&#34;alias&#34;] != alias:
                    if &#34;alias&#34; in object_result:
                        new_aliases = object_result[&#34;alias&#34;] + list(
                            set(alias) - set(object_result[&#34;alias&#34;])
                        )
                    else:
                        new_aliases = alias
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;alias&#34;, value=new_aliases
                    )
                    object_result[&#34;alias&#34;] = new_aliases
                # platform
                if platform is not None and object_result[&#34;platform&#34;] != platform:
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;platform&#34;, value=platform
                    )
                    object_result[&#34;platform&#34;] = platform
                # required_permission
                if (
                    required_permission is not None
                    and object_result[&#34;required_permission&#34;] != required_permission
                ):
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;],
                        key=&#34;required_permission&#34;,
                        value=required_permission,
                    )
                    object_result[&#34;required_permission&#34;] = required_permission
                # external_id
                if (
                    external_id is not None
                    and object_result[&#34;external_id&#34;] != external_id
                ):
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;external_id&#34;, value=external_id
                    )
                    object_result[&#34;external_id&#34;] = external_id
            return object_result
        else:
            return self.create_raw(
                name=name,
                description=description,
                alias=alias,
                platform=platform,
                required_permission=required_permission,
                external_id=external_id,
                id=id,
                stix_id_key=stix_id_key,
                created=created,
                modified=modified,
                createdByRef=created_by_ref,
                markingDefinitions=marking_definitions,
                killChainPhases=kill_chain_phases,
            )

    &#34;&#34;&#34;
        Import an Attack-Pattern object from a STIX2 object

        :param stixObject: the Stix-Object Attack-Pattern
        :return Attack-Pattern object
    &#34;&#34;&#34;

    def import_from_stix2(self, **kwargs):
        stix_object = kwargs.get(&#34;stixObject&#34;, None)
        extras = kwargs.get(&#34;extras&#34;, {})
        update = kwargs.get(&#34;update&#34;, False)
        if stix_object is not None:
            # Extract external ID
            external_id = None
            if CustomProperties.EXTERNAL_ID in stix_object:
                external_id = stix_object[CustomProperties.EXTERNAL_ID]
            if &#34;external_references&#34; in stix_object:
                for external_reference in stix_object[&#34;external_references&#34;]:
                    if (
                        external_reference[&#34;source_name&#34;] == &#34;mitre-attack&#34;
                        or external_reference[&#34;source_name&#34;] == &#34;mitre-pre-attack&#34;
                        or external_reference[&#34;source_name&#34;] == &#34;amitt-attack&#34;
                    ):
                        external_id = external_reference[&#34;external_id&#34;]
            return self.create(
                name=stix_object[&#34;name&#34;],
                description=self.opencti.stix2.convert_markdown(
                    stix_object[&#34;description&#34;]
                )
                if &#34;description&#34; in stix_object
                else &#34;&#34;,
                alias=self.opencti.stix2.pick_aliases(stix_object),
                platform=stix_object[&#34;x_mitre_platforms&#34;]
                if &#34;x_mitre_platforms&#34; in stix_object
                else stix_object[&#34;x_amitt_platforms&#34;]
                if &#34;x_amitt_platforms&#34; in stix_object
                else None,
                required_permission=stix_object[&#34;x_mitre_permissions_required&#34;]
                if &#34;x_mitre_permissions_required&#34; in stix_object
                else None,
                external_id=external_id,
                id=stix_object[CustomProperties.ID]
                if CustomProperties.ID in stix_object
                else None,
                stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
                created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
                modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
                createdByRef=extras[&#34;created_by_ref_id&#34;]
                if &#34;created_by_ref_id&#34; in extras
                else None,
                markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
                if &#34;marking_definitions_ids&#34; in extras
                else [],
                killChainPhases=extras[&#34;kill_chain_phases_ids&#34;]
                if &#34;kill_chain_phases_ids&#34; in extras
                else [],
                update=update,
            )
        else:
            self.opencti.log(
                &#34;error&#34;, &#34;[opencti_attack_pattern] Missing parameters: stixObject&#34;
            )

    &#34;&#34;&#34;
        Export an Attack-Pattern object in STIX2
    
        :param id: the id of the Attack-Pattern
        :return Attack-Pattern object
    &#34;&#34;&#34;

    def to_stix2(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        mode = kwargs.get(&#34;mode&#34;, &#34;simple&#34;)
        max_marking_definition_entity = kwargs.get(
            &#34;max_marking_definition_entity&#34;, None
        )
        entity = kwargs.get(&#34;entity&#34;, None)
        if id is not None and entity is None:
            entity = self.read(id=id)
        if entity is not None:
            attack_pattern = dict()
            attack_pattern[&#34;id&#34;] = entity[&#34;stix_id_key&#34;]
            attack_pattern[&#34;type&#34;] = &#34;attack-pattern&#34;
            attack_pattern[&#34;spec_version&#34;] = SPEC_VERSION
            if self.opencti.not_empty(entity[&#34;external_id&#34;]):
                attack_pattern[CustomProperties.EXTERNAL_ID] = entity[&#34;external_id&#34;]
            attack_pattern[&#34;name&#34;] = entity[&#34;name&#34;]
            if self.opencti.not_empty(entity[&#34;stix_label&#34;]):
                attack_pattern[&#34;labels&#34;] = entity[&#34;stix_label&#34;]
            else:
                attack_pattern[&#34;labels&#34;] = [&#34;attack-pattern&#34;]
            if self.opencti.not_empty(entity[&#34;description&#34;]):
                attack_pattern[&#34;description&#34;] = entity[&#34;description&#34;]
            attack_pattern[&#34;created&#34;] = self.opencti.stix2.format_date(
                entity[&#34;created&#34;]
            )
            attack_pattern[&#34;modified&#34;] = self.opencti.stix2.format_date(
                entity[&#34;modified&#34;]
            )
            if self.opencti.not_empty(entity[&#34;platform&#34;]):
                attack_pattern[&#34;x_mitre_platforms&#34;] = entity[&#34;platform&#34;]
            if self.opencti.not_empty(entity[&#34;required_permission&#34;]):
                attack_pattern[&#34;x_mitre_permissions_required&#34;] = entity[
                    &#34;required_permission&#34;
                ]
            if self.opencti.not_empty(entity[&#34;alias&#34;]):
                attack_pattern[CustomProperties.ALIASES] = entity[&#34;alias&#34;]
            attack_pattern[CustomProperties.ID] = entity[&#34;id&#34;]
            return self.opencti.stix2.prepare_export(
                entity, attack_pattern, mode, max_marking_definition_entity
            )
        else:
            self.opencti.log(
                &#34;error&#34;, &#34;[opencti_attack_pattern] Missing parameters: id or entity&#34;
            )</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pycti.AttackPattern.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create(self, **kwargs):
    name = kwargs.get(&#34;name&#34;, None)
    description = kwargs.get(&#34;description&#34;, None)
    alias = kwargs.get(&#34;alias&#34;, None)
    platform = kwargs.get(&#34;platform&#34;, None)
    required_permission = kwargs.get(&#34;required_permission&#34;, None)
    external_id = kwargs.get(&#34;external_id&#34;, None)
    id = kwargs.get(&#34;id&#34;, None)
    stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
    created = kwargs.get(&#34;created&#34;, None)
    modified = kwargs.get(&#34;modified&#34;, None)
    created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
    marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)
    kill_chain_phases = kwargs.get(&#34;killChainPhases&#34;, None)
    update = kwargs.get(&#34;update&#34;, False)
    custom_attributes = &#34;&#34;&#34;
        id
        entity_type
        name
        description 
        alias
        ... on AttackPattern {
            platform
            required_permission
            external_id
            
        }
    &#34;&#34;&#34;
    object_result = self.opencti.stix_domain_entity.get_by_stix_id_or_name(
        types=[&#34;Attack-Pattern&#34;],
        stix_id_key=stix_id_key,
        name=name,
        customAttributes=custom_attributes,
    )
    if object_result is None and external_id is not None:
        object_result = self.read(
            filters=[{&#34;key&#34;: &#34;external_id&#34;, &#34;values&#34;: [external_id]}]
        )
    if object_result is not None:
        if update:
            # name
            if object_result[&#34;name&#34;] != name:
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;name&#34;, value=name
                )
                object_result[&#34;name&#34;] = name
            # description
            if object_result[&#34;description&#34;] != description:
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;description&#34;, value=description
                )
                object_result[&#34;description&#34;] = description
            # alias
            if alias is not None and object_result[&#34;alias&#34;] != alias:
                if &#34;alias&#34; in object_result:
                    new_aliases = object_result[&#34;alias&#34;] + list(
                        set(alias) - set(object_result[&#34;alias&#34;])
                    )
                else:
                    new_aliases = alias
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;alias&#34;, value=new_aliases
                )
                object_result[&#34;alias&#34;] = new_aliases
            # platform
            if platform is not None and object_result[&#34;platform&#34;] != platform:
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;platform&#34;, value=platform
                )
                object_result[&#34;platform&#34;] = platform
            # required_permission
            if (
                required_permission is not None
                and object_result[&#34;required_permission&#34;] != required_permission
            ):
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;],
                    key=&#34;required_permission&#34;,
                    value=required_permission,
                )
                object_result[&#34;required_permission&#34;] = required_permission
            # external_id
            if (
                external_id is not None
                and object_result[&#34;external_id&#34;] != external_id
            ):
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;external_id&#34;, value=external_id
                )
                object_result[&#34;external_id&#34;] = external_id
        return object_result
    else:
        return self.create_raw(
            name=name,
            description=description,
            alias=alias,
            platform=platform,
            required_permission=required_permission,
            external_id=external_id,
            id=id,
            stix_id_key=stix_id_key,
            created=created,
            modified=modified,
            createdByRef=created_by_ref,
            markingDefinitions=marking_definitions,
            killChainPhases=kill_chain_phases,
        )</code></pre>
</details>
</dd>
<dt id="pycti.AttackPattern.create_raw"><code class="name flex">
<span>def <span class="ident">create_raw</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_raw(self, **kwargs):
    name = kwargs.get(&#34;name&#34;, None)
    description = kwargs.get(&#34;description&#34;, None)
    alias = kwargs.get(&#34;alias&#34;, None)
    platform = kwargs.get(&#34;platform&#34;, None)
    required_permission = kwargs.get(&#34;required_permission&#34;, None)
    external_id = kwargs.get(&#34;external_id&#34;, None)
    id = kwargs.get(&#34;id&#34;, None)
    stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
    created = kwargs.get(&#34;created&#34;, None)
    modified = kwargs.get(&#34;modified&#34;, None)
    created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
    marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)
    kill_chain_phases = kwargs.get(&#34;killChainPhases&#34;, None)

    if name is not None and description is not None:
        self.opencti.log(&#34;info&#34;, &#34;Creating Attack-Pattern {&#34; + name + &#34;}.&#34;)
        query = (
            &#34;&#34;&#34;
            mutation AttackPatternAdd($input: AttackPatternAddInput) {
                attackPatternAdd(input: $input) {
                    &#34;&#34;&#34;
            + self.properties
            + &#34;&#34;&#34;
                }
            }
        &#34;&#34;&#34;
        )
        result = self.opencti.query(
            query,
            {
                &#34;input&#34;: {
                    &#34;name&#34;: name,
                    &#34;description&#34;: description,
                    &#34;alias&#34;: alias,
                    &#34;platform&#34;: platform,
                    &#34;required_permission&#34;: required_permission,
                    &#34;external_id&#34;: external_id,
                    &#34;internal_id_key&#34;: id,
                    &#34;stix_id_key&#34;: stix_id_key,
                    &#34;created&#34;: created,
                    &#34;modified&#34;: modified,
                    &#34;createdByRef&#34;: created_by_ref,
                    &#34;markingDefinitions&#34;: marking_definitions,
                    &#34;killChainPhases&#34;: kill_chain_phases,
                }
            },
        )
        return self.opencti.process_multiple_fields(
            result[&#34;data&#34;][&#34;attackPatternAdd&#34;]
        )
    else:
        self.opencti.log(
            &#34;error&#34;,
            &#34;[opencti_attack_pattern] Missing parameters: name and description&#34;,
        )</code></pre>
</details>
</dd>
<dt id="pycti.AttackPattern.import_from_stix2"><code class="name flex">
<span>def <span class="ident">import_from_stix2</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def import_from_stix2(self, **kwargs):
    stix_object = kwargs.get(&#34;stixObject&#34;, None)
    extras = kwargs.get(&#34;extras&#34;, {})
    update = kwargs.get(&#34;update&#34;, False)
    if stix_object is not None:
        # Extract external ID
        external_id = None
        if CustomProperties.EXTERNAL_ID in stix_object:
            external_id = stix_object[CustomProperties.EXTERNAL_ID]
        if &#34;external_references&#34; in stix_object:
            for external_reference in stix_object[&#34;external_references&#34;]:
                if (
                    external_reference[&#34;source_name&#34;] == &#34;mitre-attack&#34;
                    or external_reference[&#34;source_name&#34;] == &#34;mitre-pre-attack&#34;
                    or external_reference[&#34;source_name&#34;] == &#34;amitt-attack&#34;
                ):
                    external_id = external_reference[&#34;external_id&#34;]
        return self.create(
            name=stix_object[&#34;name&#34;],
            description=self.opencti.stix2.convert_markdown(
                stix_object[&#34;description&#34;]
            )
            if &#34;description&#34; in stix_object
            else &#34;&#34;,
            alias=self.opencti.stix2.pick_aliases(stix_object),
            platform=stix_object[&#34;x_mitre_platforms&#34;]
            if &#34;x_mitre_platforms&#34; in stix_object
            else stix_object[&#34;x_amitt_platforms&#34;]
            if &#34;x_amitt_platforms&#34; in stix_object
            else None,
            required_permission=stix_object[&#34;x_mitre_permissions_required&#34;]
            if &#34;x_mitre_permissions_required&#34; in stix_object
            else None,
            external_id=external_id,
            id=stix_object[CustomProperties.ID]
            if CustomProperties.ID in stix_object
            else None,
            stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
            created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
            modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
            createdByRef=extras[&#34;created_by_ref_id&#34;]
            if &#34;created_by_ref_id&#34; in extras
            else None,
            markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
            if &#34;marking_definitions_ids&#34; in extras
            else [],
            killChainPhases=extras[&#34;kill_chain_phases_ids&#34;]
            if &#34;kill_chain_phases_ids&#34; in extras
            else [],
            update=update,
        )
    else:
        self.opencti.log(
            &#34;error&#34;, &#34;[opencti_attack_pattern] Missing parameters: stixObject&#34;
        )</code></pre>
</details>
</dd>
<dt id="pycti.AttackPattern.list"><code class="name flex">
<span>def <span class="ident">list</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list(self, **kwargs):
    filters = kwargs.get(&#34;filters&#34;, None)
    search = kwargs.get(&#34;search&#34;, None)
    first = kwargs.get(&#34;first&#34;, 500)
    after = kwargs.get(&#34;after&#34;, None)
    order_by = kwargs.get(&#34;orderBy&#34;, None)
    order_mode = kwargs.get(&#34;orderMode&#34;, None)
    get_all = kwargs.get(&#34;getAll&#34;, False)
    if get_all:
        first = 500

    self.opencti.log(
        &#34;info&#34;, &#34;Listing Attack-Patterns with filters &#34; + json.dumps(filters) + &#34;.&#34;
    )
    query = (
        &#34;&#34;&#34;
        query AttackPatterns($filters: [AttackPatternsFiltering], $search: String, $first: Int, $after: ID, $orderBy: AttackPatternsOrdering, $orderMode: OrderingMode) {
            attackPatterns(filters: $filters, search: $search, first: $first, after: $after, orderBy: $orderBy, orderMode: $orderMode) {
                edges {
                    node {
                        &#34;&#34;&#34;
        + self.properties
        + &#34;&#34;&#34;
                    }
                }
                pageInfo {
                    startCursor
                    endCursor
                    hasNextPage
                    hasPreviousPage
                    globalCount
                }
            }
        }
    &#34;&#34;&#34;
    )
    result = self.opencti.query(
        query,
        {
            &#34;filters&#34;: filters,
            &#34;search&#34;: search,
            &#34;first&#34;: first,
            &#34;after&#34;: after,
            &#34;orderBy&#34;: order_by,
            &#34;orderMode&#34;: order_mode,
        },
    )
    if get_all:
        final_data = []
        data = self.opencti.process_multiple(result[&#34;data&#34;][&#34;attackPatterns&#34;])
        final_data = final_data + data
        while result[&#34;data&#34;][&#34;attackPatterns&#34;][&#34;pageInfo&#34;][&#34;hasNextPage&#34;]:
            after = result[&#34;data&#34;][&#34;attackPatterns&#34;][&#34;pageInfo&#34;][&#34;endCursor&#34;]
            self.opencti.log(&#34;info&#34;, &#34;Listing Attack-Patterns after &#34; + after)
            result = self.opencti.query(
                query,
                {
                    &#34;filters&#34;: filters,
                    &#34;search&#34;: search,
                    &#34;first&#34;: first,
                    &#34;after&#34;: after,
                    &#34;orderBy&#34;: order_by,
                    &#34;orderMode&#34;: order_mode,
                },
            )
            data = self.opencti.process_multiple(result[&#34;data&#34;][&#34;attackPatterns&#34;])
            final_data = final_data + data
        return final_data
    else:
        return self.opencti.process_multiple(result[&#34;data&#34;][&#34;attackPatterns&#34;])</code></pre>
</details>
</dd>
<dt id="pycti.AttackPattern.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    filters = kwargs.get(&#34;filters&#34;, None)
    custom_attributes = kwargs.get(&#34;customAttributes&#34;, None)
    if id is not None:
        self.opencti.log(&#34;info&#34;, &#34;Reading Attack-Pattern {&#34; + id + &#34;}.&#34;)
        query = (
            &#34;&#34;&#34;
            query AttackPattern($id: String!) {
                attackPattern(id: $id) {
                    &#34;&#34;&#34;
            + (
                custom_attributes
                if custom_attributes is not None
                else self.properties
            )
            + &#34;&#34;&#34;
                }
            }
         &#34;&#34;&#34;
        )
        result = self.opencti.query(query, {&#34;id&#34;: id})
        return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;attackPattern&#34;])
    elif filters is not None:
        result = self.list(filters=filters)
        if len(result) &gt; 0:
            return result[0]
        else:
            return None
    else:
        self.opencti.log(
            &#34;error&#34;, &#34;[opencti_attack_pattern] Missing parameters: id or filters&#34;
        )
        return None</code></pre>
</details>
</dd>
<dt id="pycti.AttackPattern.to_stix2"><code class="name flex">
<span>def <span class="ident">to_stix2</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_stix2(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    mode = kwargs.get(&#34;mode&#34;, &#34;simple&#34;)
    max_marking_definition_entity = kwargs.get(
        &#34;max_marking_definition_entity&#34;, None
    )
    entity = kwargs.get(&#34;entity&#34;, None)
    if id is not None and entity is None:
        entity = self.read(id=id)
    if entity is not None:
        attack_pattern = dict()
        attack_pattern[&#34;id&#34;] = entity[&#34;stix_id_key&#34;]
        attack_pattern[&#34;type&#34;] = &#34;attack-pattern&#34;
        attack_pattern[&#34;spec_version&#34;] = SPEC_VERSION
        if self.opencti.not_empty(entity[&#34;external_id&#34;]):
            attack_pattern[CustomProperties.EXTERNAL_ID] = entity[&#34;external_id&#34;]
        attack_pattern[&#34;name&#34;] = entity[&#34;name&#34;]
        if self.opencti.not_empty(entity[&#34;stix_label&#34;]):
            attack_pattern[&#34;labels&#34;] = entity[&#34;stix_label&#34;]
        else:
            attack_pattern[&#34;labels&#34;] = [&#34;attack-pattern&#34;]
        if self.opencti.not_empty(entity[&#34;description&#34;]):
            attack_pattern[&#34;description&#34;] = entity[&#34;description&#34;]
        attack_pattern[&#34;created&#34;] = self.opencti.stix2.format_date(
            entity[&#34;created&#34;]
        )
        attack_pattern[&#34;modified&#34;] = self.opencti.stix2.format_date(
            entity[&#34;modified&#34;]
        )
        if self.opencti.not_empty(entity[&#34;platform&#34;]):
            attack_pattern[&#34;x_mitre_platforms&#34;] = entity[&#34;platform&#34;]
        if self.opencti.not_empty(entity[&#34;required_permission&#34;]):
            attack_pattern[&#34;x_mitre_permissions_required&#34;] = entity[
                &#34;required_permission&#34;
            ]
        if self.opencti.not_empty(entity[&#34;alias&#34;]):
            attack_pattern[CustomProperties.ALIASES] = entity[&#34;alias&#34;]
        attack_pattern[CustomProperties.ID] = entity[&#34;id&#34;]
        return self.opencti.stix2.prepare_export(
            entity, attack_pattern, mode, max_marking_definition_entity
        )
    else:
        self.opencti.log(
            &#34;error&#34;, &#34;[opencti_attack_pattern] Missing parameters: id or entity&#34;
        )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pycti.Campaign"><code class="flex name class">
<span>class <span class="ident">Campaign</span></span>
<span>(</span><span>opencti)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Campaign:
    def __init__(self, opencti):
        self.opencti = opencti
        self.properties = &#34;&#34;&#34;
            id
            stix_id_key
            stix_label
            entity_type
            parent_types
            name
            alias
            description
            graph_data
            objective
            first_seen
            last_seen
            created
            modified
            created_at
            updated_at
            createdByRef {
                node {
                    id
                    entity_type
                    stix_id_key
                    stix_label
                    name
                    alias
                    description
                    created
                    modified
                    ... on Organization {
                        organization_class
                    }
                }
                relation {
                    id
                }
            }            
            markingDefinitions {
                edges {
                    node {
                        id
                        entity_type
                        stix_id_key
                        definition_type
                        definition
                        level
                        color
                        created
                        modified
                    }
                    relation {
                        id
                    }
                }
            }
            tags {
                edges {
                    node {
                        id
                        tag_type
                        value
                        color
                    }
                    relation {
                        id
                    }
                }
            }
            externalReferences {
                edges {
                    node {
                        id
                        entity_type
                        stix_id_key
                        source_name
                        description
                        url
                        hash
                        external_id
                        created
                        modified
                    }
                    relation {
                        id
                    }
                }
            }    
        &#34;&#34;&#34;

    &#34;&#34;&#34;
        List Campaign objects

        :param filters: the filters to apply
        :param search: the search keyword
        :param first: return the first n rows from the after ID (or the beginning if not set)
        :param after: ID of the first row for pagination
        :return List of Campaign objects
    &#34;&#34;&#34;

    def list(self, **kwargs):
        filters = kwargs.get(&#34;filters&#34;, None)
        search = kwargs.get(&#34;search&#34;, None)
        first = kwargs.get(&#34;first&#34;, 500)
        after = kwargs.get(&#34;after&#34;, None)
        order_by = kwargs.get(&#34;orderBy&#34;, None)
        order_mode = kwargs.get(&#34;orderMode&#34;, None)
        get_all = kwargs.get(&#34;getAll&#34;, False)
        if get_all:
            first = 500

        self.opencti.log(
            &#34;info&#34;, &#34;Listing Campaigns with filters &#34; + json.dumps(filters) + &#34;.&#34;
        )
        query = (
            &#34;&#34;&#34;
            query Campaigns($filters: [CampaignsFiltering], $search: String, $first: Int, $after: ID, $orderBy: CampaignsOrdering, $orderMode: OrderingMode) {
                campaigns(filters: $filters, search: $search, first: $first, after: $after, orderBy: $orderBy, orderMode: $orderMode) {
                    edges {
                        node {
                            &#34;&#34;&#34;
            + self.properties
            + &#34;&#34;&#34;
                        }
                    }
                    pageInfo {
                        startCursor
                        endCursor
                        hasNextPage
                        hasPreviousPage
                        globalCount
                    }
                }
            }
        &#34;&#34;&#34;
        )
        result = self.opencti.query(
            query,
            {
                &#34;filters&#34;: filters,
                &#34;search&#34;: search,
                &#34;first&#34;: first,
                &#34;after&#34;: after,
                &#34;orderBy&#34;: order_by,
                &#34;orderMode&#34;: order_mode,
            },
        )
        return self.opencti.process_multiple(result[&#34;data&#34;][&#34;campaigns&#34;])

    &#34;&#34;&#34;
        Read a Campaign object
        
        :param id: the id of the Campaign
        :param filters: the filters to apply if no id provided
        :return Campaign object
    &#34;&#34;&#34;

    def read(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        filters = kwargs.get(&#34;filters&#34;, None)
        custom_attributes = kwargs.get(&#34;customAttributes&#34;, None)
        if id is not None:
            self.opencti.log(&#34;info&#34;, &#34;Reading Campaign {&#34; + id + &#34;}.&#34;)
            query = (
                &#34;&#34;&#34;
                query Campaign($id: String!) {
                    campaign(id: $id) {
                        &#34;&#34;&#34;
                + (
                    custom_attributes
                    if custom_attributes is not None
                    else self.properties
                )
                + &#34;&#34;&#34;
                    }
                }
             &#34;&#34;&#34;
            )
            result = self.opencti.query(query, {&#34;id&#34;: id})
            return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;campaign&#34;])
        elif filters is not None:
            result = self.list(filters=filters)
            if len(result) &gt; 0:
                return result[0]
            else:
                return None
        else:
            self.opencti.log(
                &#34;error&#34;, &#34;[opencti_campaign] Missing parameters: id or filters&#34;
            )
            return None

    &#34;&#34;&#34;
        Create a Campaign object

        :param name: the name of the Campaign
        :return Campaign object
    &#34;&#34;&#34;

    def create_raw(self, **kwargs):
        name = kwargs.get(&#34;name&#34;, None)
        description = kwargs.get(&#34;description&#34;, None)
        alias = kwargs.get(&#34;alias&#34;, None)
        objective = kwargs.get(&#34;objective&#34;, None)
        first_seen = kwargs.get(&#34;first_seen&#34;, None)
        last_seen = kwargs.get(&#34;last_seen&#34;, None)
        id = kwargs.get(&#34;id&#34;, None)
        stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
        created = kwargs.get(&#34;created&#34;, None)
        modified = kwargs.get(&#34;modified&#34;, None)
        created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
        marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)

        if name is not None and description is not None:
            self.opencti.log(&#34;info&#34;, &#34;Creating Campaign {&#34; + name + &#34;}.&#34;)
            query = (
                &#34;&#34;&#34;
                mutation CampaignAdd($input: CampaignAddInput) {
                    campaignAdd(input: $input) {
                        &#34;&#34;&#34;
                + self.properties
                + &#34;&#34;&#34;
                    }
                }
            &#34;&#34;&#34;
            )
            result = self.opencti.query(
                query,
                {
                    &#34;input&#34;: {
                        &#34;name&#34;: name,
                        &#34;description&#34;: description,
                        &#34;alias&#34;: alias,
                        &#34;objective&#34;: objective,
                        &#34;first_seen&#34;: first_seen,
                        &#34;last_seen&#34;: last_seen,
                        &#34;internal_id_key&#34;: id,
                        &#34;stix_id_key&#34;: stix_id_key,
                        &#34;created&#34;: created,
                        &#34;modified&#34;: modified,
                        &#34;createdByRef&#34;: created_by_ref,
                        &#34;markingDefinitions&#34;: marking_definitions,
                    }
                },
            )
            return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;campaignAdd&#34;])
        else:
            self.opencti.log(
                &#34;error&#34;, &#34;[opencti_campaign] Missing parameters: name and description&#34;
            )

    &#34;&#34;&#34;
        Create a Campaign object only if it not exists, update it on request

        :param name: the name of the Campaign
        :return Campaign object
    &#34;&#34;&#34;

    def create(self, **kwargs):
        name = kwargs.get(&#34;name&#34;, None)
        description = kwargs.get(&#34;description&#34;, None)
        alias = kwargs.get(&#34;alias&#34;, None)
        objective = kwargs.get(&#34;objective&#34;, None)
        first_seen = kwargs.get(&#34;first_seen&#34;, None)
        last_seen = kwargs.get(&#34;last_seen&#34;, None)
        id = kwargs.get(&#34;id&#34;, None)
        stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
        created = kwargs.get(&#34;created&#34;, None)
        modified = kwargs.get(&#34;modified&#34;, None)
        created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
        marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)
        update = kwargs.get(&#34;update&#34;, False)
        custom_attributes = &#34;&#34;&#34;
            id
            entity_type
            name
            description 
            alias
            ... on Campaign {
                objective
                first_seen
                last_seen
            }
        &#34;&#34;&#34;
        object_result = self.opencti.stix_domain_entity.get_by_stix_id_or_name(
            types=[&#34;Campaign&#34;],
            stix_id_key=stix_id_key,
            name=name,
            customAttributes=custom_attributes,
        )
        if object_result is not None:
            if update:
                # name
                if object_result[&#34;name&#34;] != name:
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;name&#34;, value=name
                    )
                    object_result[&#34;name&#34;] = name
                # description
                if object_result[&#34;description&#34;] != description:
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;description&#34;, value=description
                    )
                    object_result[&#34;description&#34;] = description
                # alias
                if alias is not None and object_result[&#34;alias&#34;] != alias:
                    if &#34;alias&#34; in object_result:
                        new_aliases = object_result[&#34;alias&#34;] + list(
                            set(alias) - set(object_result[&#34;alias&#34;])
                        )
                    else:
                        new_aliases = alias
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;alias&#34;, value=new_aliases
                    )
                    object_result[&#34;alias&#34;] = new_aliases
                # objective
                if objective is not None and object_result[&#34;objective&#34;] != objective:
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;objective&#34;, value=objective
                    )
                    object_result[&#34;objective&#34;] = objective
                # first_seen
                if first_seen is not None and object_result[&#34;first_seen&#34;] != first_seen:
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;first_seen&#34;, value=first_seen
                    )
                    object_result[&#34;first_seen&#34;] = first_seen
                # last_seen
                if last_seen is not None and object_result[&#34;last_seen&#34;] != last_seen:
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;last_seen&#34;, value=last_seen
                    )
                    object_result[&#34;external_id&#34;] = last_seen
            return object_result
        else:
            return self.create_raw(
                name=name,
                description=description,
                alias=alias,
                objective=objective,
                first_seen=first_seen,
                last_seen=last_seen,
                id=id,
                stix_id_key=stix_id_key,
                created=created,
                modified=modified,
                createdByRef=created_by_ref,
                markingDefinitions=marking_definitions,
            )

    &#34;&#34;&#34;
        Export an Campaign object in STIX2
    
        :param id: the id of the Campaign
        :return Campaign object
    &#34;&#34;&#34;

    def to_stix2(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        mode = kwargs.get(&#34;mode&#34;, &#34;simple&#34;)
        max_marking_definition_entity = kwargs.get(
            &#34;max_marking_definition_entity&#34;, None
        )
        entity = kwargs.get(&#34;entity&#34;, None)
        if id is not None and entity is None:
            entity = self.read(id=id)
        if entity is not None:
            campaign = dict()
            campaign[&#34;id&#34;] = entity[&#34;stix_id_key&#34;]
            campaign[&#34;type&#34;] = &#34;campaign&#34;
            campaign[&#34;spec_version&#34;] = SPEC_VERSION
            campaign[&#34;name&#34;] = entity[&#34;name&#34;]
            if self.opencti.not_empty(entity[&#34;stix_label&#34;]):
                campaign[&#34;labels&#34;] = entity[&#34;stix_label&#34;]
            else:
                campaign[&#34;labels&#34;] = [&#34;campaign&#34;]
            if self.opencti.not_empty(entity[&#34;alias&#34;]):
                campaign[&#34;aliases&#34;] = entity[&#34;alias&#34;]
            if self.opencti.not_empty(entity[&#34;description&#34;]):
                campaign[&#34;description&#34;] = entity[&#34;description&#34;]
            if self.opencti.not_empty(entity[&#34;objective&#34;]):
                campaign[&#34;objective&#34;] = entity[&#34;objective&#34;]
            if self.opencti.not_empty(entity[&#34;first_seen&#34;]):
                campaign[CustomProperties.FIRST_SEEN] = self.opencti.stix2.format_date(
                    entity[&#34;first_seen&#34;]
                )
            if self.opencti.not_empty(entity[&#34;last_seen&#34;]):
                campaign[CustomProperties.LAST_SEEN] = self.opencti.stix2.format_date(
                    entity[&#34;last_seen&#34;]
                )
            campaign[&#34;created&#34;] = self.opencti.stix2.format_date(entity[&#34;created&#34;])
            campaign[&#34;modified&#34;] = self.opencti.stix2.format_date(entity[&#34;modified&#34;])
            campaign[CustomProperties.ID] = entity[&#34;id&#34;]
            return self.opencti.stix2.prepare_export(
                entity, campaign, mode, max_marking_definition_entity
            )
        else:
            self.opencti.log(&#34;error&#34;, &#34;Missing parameters: id or entity&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pycti.Campaign.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create(self, **kwargs):
    name = kwargs.get(&#34;name&#34;, None)
    description = kwargs.get(&#34;description&#34;, None)
    alias = kwargs.get(&#34;alias&#34;, None)
    objective = kwargs.get(&#34;objective&#34;, None)
    first_seen = kwargs.get(&#34;first_seen&#34;, None)
    last_seen = kwargs.get(&#34;last_seen&#34;, None)
    id = kwargs.get(&#34;id&#34;, None)
    stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
    created = kwargs.get(&#34;created&#34;, None)
    modified = kwargs.get(&#34;modified&#34;, None)
    created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
    marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)
    update = kwargs.get(&#34;update&#34;, False)
    custom_attributes = &#34;&#34;&#34;
        id
        entity_type
        name
        description 
        alias
        ... on Campaign {
            objective
            first_seen
            last_seen
        }
    &#34;&#34;&#34;
    object_result = self.opencti.stix_domain_entity.get_by_stix_id_or_name(
        types=[&#34;Campaign&#34;],
        stix_id_key=stix_id_key,
        name=name,
        customAttributes=custom_attributes,
    )
    if object_result is not None:
        if update:
            # name
            if object_result[&#34;name&#34;] != name:
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;name&#34;, value=name
                )
                object_result[&#34;name&#34;] = name
            # description
            if object_result[&#34;description&#34;] != description:
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;description&#34;, value=description
                )
                object_result[&#34;description&#34;] = description
            # alias
            if alias is not None and object_result[&#34;alias&#34;] != alias:
                if &#34;alias&#34; in object_result:
                    new_aliases = object_result[&#34;alias&#34;] + list(
                        set(alias) - set(object_result[&#34;alias&#34;])
                    )
                else:
                    new_aliases = alias
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;alias&#34;, value=new_aliases
                )
                object_result[&#34;alias&#34;] = new_aliases
            # objective
            if objective is not None and object_result[&#34;objective&#34;] != objective:
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;objective&#34;, value=objective
                )
                object_result[&#34;objective&#34;] = objective
            # first_seen
            if first_seen is not None and object_result[&#34;first_seen&#34;] != first_seen:
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;first_seen&#34;, value=first_seen
                )
                object_result[&#34;first_seen&#34;] = first_seen
            # last_seen
            if last_seen is not None and object_result[&#34;last_seen&#34;] != last_seen:
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;last_seen&#34;, value=last_seen
                )
                object_result[&#34;external_id&#34;] = last_seen
        return object_result
    else:
        return self.create_raw(
            name=name,
            description=description,
            alias=alias,
            objective=objective,
            first_seen=first_seen,
            last_seen=last_seen,
            id=id,
            stix_id_key=stix_id_key,
            created=created,
            modified=modified,
            createdByRef=created_by_ref,
            markingDefinitions=marking_definitions,
        )</code></pre>
</details>
</dd>
<dt id="pycti.Campaign.create_raw"><code class="name flex">
<span>def <span class="ident">create_raw</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_raw(self, **kwargs):
    name = kwargs.get(&#34;name&#34;, None)
    description = kwargs.get(&#34;description&#34;, None)
    alias = kwargs.get(&#34;alias&#34;, None)
    objective = kwargs.get(&#34;objective&#34;, None)
    first_seen = kwargs.get(&#34;first_seen&#34;, None)
    last_seen = kwargs.get(&#34;last_seen&#34;, None)
    id = kwargs.get(&#34;id&#34;, None)
    stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
    created = kwargs.get(&#34;created&#34;, None)
    modified = kwargs.get(&#34;modified&#34;, None)
    created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
    marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)

    if name is not None and description is not None:
        self.opencti.log(&#34;info&#34;, &#34;Creating Campaign {&#34; + name + &#34;}.&#34;)
        query = (
            &#34;&#34;&#34;
            mutation CampaignAdd($input: CampaignAddInput) {
                campaignAdd(input: $input) {
                    &#34;&#34;&#34;
            + self.properties
            + &#34;&#34;&#34;
                }
            }
        &#34;&#34;&#34;
        )
        result = self.opencti.query(
            query,
            {
                &#34;input&#34;: {
                    &#34;name&#34;: name,
                    &#34;description&#34;: description,
                    &#34;alias&#34;: alias,
                    &#34;objective&#34;: objective,
                    &#34;first_seen&#34;: first_seen,
                    &#34;last_seen&#34;: last_seen,
                    &#34;internal_id_key&#34;: id,
                    &#34;stix_id_key&#34;: stix_id_key,
                    &#34;created&#34;: created,
                    &#34;modified&#34;: modified,
                    &#34;createdByRef&#34;: created_by_ref,
                    &#34;markingDefinitions&#34;: marking_definitions,
                }
            },
        )
        return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;campaignAdd&#34;])
    else:
        self.opencti.log(
            &#34;error&#34;, &#34;[opencti_campaign] Missing parameters: name and description&#34;
        )</code></pre>
</details>
</dd>
<dt id="pycti.Campaign.list"><code class="name flex">
<span>def <span class="ident">list</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list(self, **kwargs):
    filters = kwargs.get(&#34;filters&#34;, None)
    search = kwargs.get(&#34;search&#34;, None)
    first = kwargs.get(&#34;first&#34;, 500)
    after = kwargs.get(&#34;after&#34;, None)
    order_by = kwargs.get(&#34;orderBy&#34;, None)
    order_mode = kwargs.get(&#34;orderMode&#34;, None)
    get_all = kwargs.get(&#34;getAll&#34;, False)
    if get_all:
        first = 500

    self.opencti.log(
        &#34;info&#34;, &#34;Listing Campaigns with filters &#34; + json.dumps(filters) + &#34;.&#34;
    )
    query = (
        &#34;&#34;&#34;
        query Campaigns($filters: [CampaignsFiltering], $search: String, $first: Int, $after: ID, $orderBy: CampaignsOrdering, $orderMode: OrderingMode) {
            campaigns(filters: $filters, search: $search, first: $first, after: $after, orderBy: $orderBy, orderMode: $orderMode) {
                edges {
                    node {
                        &#34;&#34;&#34;
        + self.properties
        + &#34;&#34;&#34;
                    }
                }
                pageInfo {
                    startCursor
                    endCursor
                    hasNextPage
                    hasPreviousPage
                    globalCount
                }
            }
        }
    &#34;&#34;&#34;
    )
    result = self.opencti.query(
        query,
        {
            &#34;filters&#34;: filters,
            &#34;search&#34;: search,
            &#34;first&#34;: first,
            &#34;after&#34;: after,
            &#34;orderBy&#34;: order_by,
            &#34;orderMode&#34;: order_mode,
        },
    )
    return self.opencti.process_multiple(result[&#34;data&#34;][&#34;campaigns&#34;])</code></pre>
</details>
</dd>
<dt id="pycti.Campaign.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    filters = kwargs.get(&#34;filters&#34;, None)
    custom_attributes = kwargs.get(&#34;customAttributes&#34;, None)
    if id is not None:
        self.opencti.log(&#34;info&#34;, &#34;Reading Campaign {&#34; + id + &#34;}.&#34;)
        query = (
            &#34;&#34;&#34;
            query Campaign($id: String!) {
                campaign(id: $id) {
                    &#34;&#34;&#34;
            + (
                custom_attributes
                if custom_attributes is not None
                else self.properties
            )
            + &#34;&#34;&#34;
                }
            }
         &#34;&#34;&#34;
        )
        result = self.opencti.query(query, {&#34;id&#34;: id})
        return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;campaign&#34;])
    elif filters is not None:
        result = self.list(filters=filters)
        if len(result) &gt; 0:
            return result[0]
        else:
            return None
    else:
        self.opencti.log(
            &#34;error&#34;, &#34;[opencti_campaign] Missing parameters: id or filters&#34;
        )
        return None</code></pre>
</details>
</dd>
<dt id="pycti.Campaign.to_stix2"><code class="name flex">
<span>def <span class="ident">to_stix2</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_stix2(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    mode = kwargs.get(&#34;mode&#34;, &#34;simple&#34;)
    max_marking_definition_entity = kwargs.get(
        &#34;max_marking_definition_entity&#34;, None
    )
    entity = kwargs.get(&#34;entity&#34;, None)
    if id is not None and entity is None:
        entity = self.read(id=id)
    if entity is not None:
        campaign = dict()
        campaign[&#34;id&#34;] = entity[&#34;stix_id_key&#34;]
        campaign[&#34;type&#34;] = &#34;campaign&#34;
        campaign[&#34;spec_version&#34;] = SPEC_VERSION
        campaign[&#34;name&#34;] = entity[&#34;name&#34;]
        if self.opencti.not_empty(entity[&#34;stix_label&#34;]):
            campaign[&#34;labels&#34;] = entity[&#34;stix_label&#34;]
        else:
            campaign[&#34;labels&#34;] = [&#34;campaign&#34;]
        if self.opencti.not_empty(entity[&#34;alias&#34;]):
            campaign[&#34;aliases&#34;] = entity[&#34;alias&#34;]
        if self.opencti.not_empty(entity[&#34;description&#34;]):
            campaign[&#34;description&#34;] = entity[&#34;description&#34;]
        if self.opencti.not_empty(entity[&#34;objective&#34;]):
            campaign[&#34;objective&#34;] = entity[&#34;objective&#34;]
        if self.opencti.not_empty(entity[&#34;first_seen&#34;]):
            campaign[CustomProperties.FIRST_SEEN] = self.opencti.stix2.format_date(
                entity[&#34;first_seen&#34;]
            )
        if self.opencti.not_empty(entity[&#34;last_seen&#34;]):
            campaign[CustomProperties.LAST_SEEN] = self.opencti.stix2.format_date(
                entity[&#34;last_seen&#34;]
            )
        campaign[&#34;created&#34;] = self.opencti.stix2.format_date(entity[&#34;created&#34;])
        campaign[&#34;modified&#34;] = self.opencti.stix2.format_date(entity[&#34;modified&#34;])
        campaign[CustomProperties.ID] = entity[&#34;id&#34;]
        return self.opencti.stix2.prepare_export(
            entity, campaign, mode, max_marking_definition_entity
        )
    else:
        self.opencti.log(&#34;error&#34;, &#34;Missing parameters: id or entity&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pycti.ConnectorType"><code class="flex name class">
<span>class <span class="ident">ConnectorType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConnectorType(Enum):
    EXTERNAL_IMPORT = &#34;EXTERNAL_IMPORT&#34;  # From remote sources to OpenCTI stix2
    INTERNAL_IMPORT_FILE = (
        &#34;INTERNAL_IMPORT_FILE&#34;  # From OpenCTI file system to OpenCTI stix2
    )
    INTERNAL_ENRICHMENT = &#34;INTERNAL_ENRICHMENT&#34;  # From OpenCTI stix2 to OpenCTI stix2
    INTERNAL_EXPORT_FILE = (
        &#34;INTERNAL_EXPORT_FILE&#34;  # From OpenCTI stix2 to OpenCTI file system
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pycti.ConnectorType.EXTERNAL_IMPORT"><code class="name">var <span class="ident">EXTERNAL_IMPORT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.ConnectorType.INTERNAL_ENRICHMENT"><code class="name">var <span class="ident">INTERNAL_ENRICHMENT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.ConnectorType.INTERNAL_EXPORT_FILE"><code class="name">var <span class="ident">INTERNAL_EXPORT_FILE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.ConnectorType.INTERNAL_IMPORT_FILE"><code class="name">var <span class="ident">INTERNAL_IMPORT_FILE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="pycti.CourseOfAction"><code class="flex name class">
<span>class <span class="ident">CourseOfAction</span></span>
<span>(</span><span>opencti)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CourseOfAction:
    def __init__(self, opencti):
        self.opencti = opencti
        self.properties = &#34;&#34;&#34;
            id
            stix_id_key
            stix_label
            entity_type
            parent_types
            name
            alias
            description
            graph_data
            created
            modified            
            created_at
            updated_at
            createdByRef {
                node {
                    id
                    entity_type
                    stix_id_key
                    stix_label
                    name
                    alias
                    description
                    created
                    modified
                    ... on Organization {
                        organization_class
                    }
                }
                relation {
                    id
                }
            }            
            markingDefinitions {
                edges {
                    node {
                        id
                        entity_type
                        stix_id_key
                        definition_type
                        definition
                        level
                        color
                        created
                        modified
                    }
                    relation {
                        id
                    }
                }
            }
            tags {
                edges {
                    node {
                        id
                        tag_type
                        value
                        color
                    }
                    relation {
                        id
                    }
                }
            }
            externalReferences {
                edges {
                    node {
                        id
                        entity_type
                        stix_id_key
                        source_name
                        description
                        url
                        hash
                        external_id
                        created
                        modified
                    }
                    relation {
                        id
                    }
                }
            }         
        &#34;&#34;&#34;

    &#34;&#34;&#34;
        List Course-Of-Action objects

        :param filters: the filters to apply
        :param search: the search keyword
        :param first: return the first n rows from the after ID (or the beginning if not set)
        :param after: ID of the first row for pagination
        :return List of Course-Of-Action objects
    &#34;&#34;&#34;

    def list(self, **kwargs):
        filters = kwargs.get(&#34;filters&#34;, None)
        search = kwargs.get(&#34;search&#34;, None)
        first = kwargs.get(&#34;first&#34;, 500)
        after = kwargs.get(&#34;after&#34;, None)
        order_by = kwargs.get(&#34;orderBy&#34;, None)
        order_mode = kwargs.get(&#34;orderMode&#34;, None)
        get_all = kwargs.get(&#34;getAll&#34;, False)
        if get_all:
            first = 500

        self.opencti.log(
            &#34;info&#34;,
            &#34;Listing Course-Of-Actions with filters &#34; + json.dumps(filters) + &#34;.&#34;,
        )
        query = (
            &#34;&#34;&#34;
            query CourseOfActions($filters: [CourseOfActionsFiltering], $search: String, $first: Int, $after: ID, $orderBy: CoursesOfActionOrdering, $orderMode: OrderingMode) {
                courseOfActions(filters: $filters, search: $search, first: $first, after: $after, orderBy: $orderBy, orderMode: $orderMode) {
                    edges {
                        node {
                            &#34;&#34;&#34;
            + self.properties
            + &#34;&#34;&#34;
                        }
                    }
                    pageInfo {
                        startCursor
                        endCursor
                        hasNextPage
                        hasPreviousPage
                        globalCount
                    }
                }
            }
        &#34;&#34;&#34;
        )
        result = self.opencti.query(
            query,
            {
                &#34;filters&#34;: filters,
                &#34;search&#34;: search,
                &#34;first&#34;: first,
                &#34;after&#34;: after,
                &#34;orderBy&#34;: order_by,
                &#34;orderMode&#34;: order_mode,
            },
        )
        return self.opencti.process_multiple(result[&#34;data&#34;][&#34;courseOfActions&#34;])

    &#34;&#34;&#34;
        Read a Course-Of-Action object
        
        :param id: the id of the Course-Of-Action
        :param filters: the filters to apply if no id provided
        :return Course-Of-Action object
    &#34;&#34;&#34;

    def read(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        filters = kwargs.get(&#34;filters&#34;, None)
        custom_attributes = kwargs.get(&#34;customAttributes&#34;, None)
        if id is not None:
            self.opencti.log(&#34;info&#34;, &#34;Reading Course-Of-Action {&#34; + id + &#34;}.&#34;)
            query = (
                &#34;&#34;&#34;
                query CourseOfAction($id: String!) {
                    courseOfAction(id: $id) {
                        &#34;&#34;&#34;
                + (
                    custom_attributes
                    if custom_attributes is not None
                    else self.properties
                )
                + &#34;&#34;&#34;
                    }
                }
             &#34;&#34;&#34;
            )
            result = self.opencti.query(query, {&#34;id&#34;: id})
            return self.opencti.process_multiple_fields(
                result[&#34;data&#34;][&#34;courseOfAction&#34;]
            )
        elif filters is not None:
            result = self.list(filters=filters)
            if len(result) &gt; 0:
                return result[0]
            else:
                return None
        else:
            self.opencti.log(
                &#34;error&#34;, &#34;[opencti_course_of_action] Missing parameters: id or filters&#34;
            )
            return None

    &#34;&#34;&#34;
        Create a Course Of Action object

        :param name: the name of the Course Of Action
        :return Course Of Action object
    &#34;&#34;&#34;

    def create_raw(self, **kwargs):
        name = kwargs.get(&#34;name&#34;, None)
        description = kwargs.get(&#34;description&#34;, None)
        alias = kwargs.get(&#34;alias&#34;, None)
        id = kwargs.get(&#34;id&#34;, None)
        stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
        created = kwargs.get(&#34;created&#34;, None)
        modified = kwargs.get(&#34;modified&#34;, None)
        created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
        marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)

        if name is not None and description is not None:
            self.opencti.log(&#34;info&#34;, &#34;Creating Course Of Action {&#34; + name + &#34;}.&#34;)
            query = (
                &#34;&#34;&#34;
                mutation CourseOfActionAdd($input: CourseOfActionAddInput) {
                    courseOfActionAdd(input: $input) {
                        &#34;&#34;&#34;
                + self.properties
                + &#34;&#34;&#34;
                    }
                }
            &#34;&#34;&#34;
            )
            result = self.opencti.query(
                query,
                {
                    &#34;input&#34;: {
                        &#34;name&#34;: name,
                        &#34;description&#34;: description,
                        &#34;alias&#34;: alias,
                        &#34;internal_id_key&#34;: id,
                        &#34;stix_id_key&#34;: stix_id_key,
                        &#34;created&#34;: created,
                        &#34;modified&#34;: modified,
                        &#34;createdByRef&#34;: created_by_ref,
                        &#34;markingDefinitions&#34;: marking_definitions,
                    }
                },
            )
            return self.opencti.process_multiple_fields(
                result[&#34;data&#34;][&#34;courseOfActionAdd&#34;]
            )
        else:
            self.opencti.log(
                &#34;error&#34;,
                &#34;[opencti_course_of_action] Missing parameters: name and description&#34;,
            )

    &#34;&#34;&#34;
        Create a Course Of Action object only if it not exists, update it on request

        :param name: the name of the Course Of Action
        :return Course Of Action object
    &#34;&#34;&#34;

    def create(self, **kwargs):
        name = kwargs.get(&#34;name&#34;, None)
        description = kwargs.get(&#34;description&#34;, None)
        alias = kwargs.get(&#34;alias&#34;, None)
        id = kwargs.get(&#34;id&#34;, None)
        stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
        created = kwargs.get(&#34;created&#34;, None)
        modified = kwargs.get(&#34;modified&#34;, None)
        created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
        marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)
        update = kwargs.get(&#34;update&#34;, False)
        custom_attributes = &#34;&#34;&#34;
            id
            entity_type
            name
            description 
            alias
        &#34;&#34;&#34;
        object_result = self.opencti.stix_domain_entity.get_by_stix_id_or_name(
            types=[&#34;Course-Of-Action&#34;],
            stix_id_key=stix_id_key,
            name=name,
            customAttributes=custom_attributes,
        )
        if object_result is not None:
            if update:
                # name
                if object_result[&#34;name&#34;] != name:
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;name&#34;, value=name
                    )
                    object_result[&#34;name&#34;] = name
                # description
                if object_result[&#34;description&#34;] != description:
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;description&#34;, value=description
                    )
                    object_result[&#34;description&#34;] = description
                # alias
                if alias is not None and object_result[&#34;alias&#34;] != alias:
                    if &#34;alias&#34; in object_result:
                        new_aliases = object_result[&#34;alias&#34;] + list(
                            set(alias) - set(object_result[&#34;alias&#34;])
                        )
                    else:
                        new_aliases = alias
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;alias&#34;, value=new_aliases
                    )
                    object_result[&#34;alias&#34;] = new_aliases
            return object_result
        else:
            return self.create_raw(
                name=name,
                description=description,
                alias=alias,
                id=id,
                stix_id_key=stix_id_key,
                created=created,
                modified=modified,
                createdByRef=created_by_ref,
                markingDefinitions=marking_definitions,
            )

    &#34;&#34;&#34;
        Export an Course-Of-Action object in STIX2
    
        :param id: the id of the Course-Of-Action
        :return Course-Of-Action object
    &#34;&#34;&#34;

    def to_stix2(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        mode = kwargs.get(&#34;mode&#34;, &#34;simple&#34;)
        max_marking_definition_entity = kwargs.get(
            &#34;max_marking_definition_entity&#34;, None
        )
        entity = kwargs.get(&#34;entity&#34;, None)
        if id is not None and entity is None:
            entity = self.read(id=id)
        if entity is not None:
            course_of_action = dict()
            course_of_action[&#34;id&#34;] = entity[&#34;stix_id_key&#34;]
            course_of_action[&#34;type&#34;] = &#34;course-of-action&#34;
            course_of_action[&#34;spec_version&#34;] = SPEC_VERSION
            course_of_action[&#34;name&#34;] = entity[&#34;name&#34;]
            if self.opencti.not_empty(entity[&#34;stix_label&#34;]):
                course_of_action[&#34;labels&#34;] = entity[&#34;stix_label&#34;]
            else:
                course_of_action[&#34;labels&#34;] = [&#34;course-of-action&#34;]
            if self.opencti.not_empty(entity[&#34;description&#34;]):
                course_of_action[&#34;description&#34;] = entity[&#34;description&#34;]
            course_of_action[&#34;created&#34;] = self.opencti.stix2.format_date(
                entity[&#34;created&#34;]
            )
            course_of_action[&#34;modified&#34;] = self.opencti.stix2.format_date(
                entity[&#34;modified&#34;]
            )
            if self.opencti.not_empty(entity[&#34;alias&#34;]):
                course_of_action[CustomProperties.ALIASES] = entity[&#34;alias&#34;]
            course_of_action[CustomProperties.ID] = entity[&#34;id&#34;]
            return self.opencti.stix2.prepare_export(
                entity, course_of_action, mode, max_marking_definition_entity
            )
        else:
            self.opencti.log(&#34;error&#34;, &#34;Missing parameters: id or entity&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pycti.CourseOfAction.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create(self, **kwargs):
    name = kwargs.get(&#34;name&#34;, None)
    description = kwargs.get(&#34;description&#34;, None)
    alias = kwargs.get(&#34;alias&#34;, None)
    id = kwargs.get(&#34;id&#34;, None)
    stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
    created = kwargs.get(&#34;created&#34;, None)
    modified = kwargs.get(&#34;modified&#34;, None)
    created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
    marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)
    update = kwargs.get(&#34;update&#34;, False)
    custom_attributes = &#34;&#34;&#34;
        id
        entity_type
        name
        description 
        alias
    &#34;&#34;&#34;
    object_result = self.opencti.stix_domain_entity.get_by_stix_id_or_name(
        types=[&#34;Course-Of-Action&#34;],
        stix_id_key=stix_id_key,
        name=name,
        customAttributes=custom_attributes,
    )
    if object_result is not None:
        if update:
            # name
            if object_result[&#34;name&#34;] != name:
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;name&#34;, value=name
                )
                object_result[&#34;name&#34;] = name
            # description
            if object_result[&#34;description&#34;] != description:
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;description&#34;, value=description
                )
                object_result[&#34;description&#34;] = description
            # alias
            if alias is not None and object_result[&#34;alias&#34;] != alias:
                if &#34;alias&#34; in object_result:
                    new_aliases = object_result[&#34;alias&#34;] + list(
                        set(alias) - set(object_result[&#34;alias&#34;])
                    )
                else:
                    new_aliases = alias
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;alias&#34;, value=new_aliases
                )
                object_result[&#34;alias&#34;] = new_aliases
        return object_result
    else:
        return self.create_raw(
            name=name,
            description=description,
            alias=alias,
            id=id,
            stix_id_key=stix_id_key,
            created=created,
            modified=modified,
            createdByRef=created_by_ref,
            markingDefinitions=marking_definitions,
        )</code></pre>
</details>
</dd>
<dt id="pycti.CourseOfAction.create_raw"><code class="name flex">
<span>def <span class="ident">create_raw</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_raw(self, **kwargs):
    name = kwargs.get(&#34;name&#34;, None)
    description = kwargs.get(&#34;description&#34;, None)
    alias = kwargs.get(&#34;alias&#34;, None)
    id = kwargs.get(&#34;id&#34;, None)
    stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
    created = kwargs.get(&#34;created&#34;, None)
    modified = kwargs.get(&#34;modified&#34;, None)
    created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
    marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)

    if name is not None and description is not None:
        self.opencti.log(&#34;info&#34;, &#34;Creating Course Of Action {&#34; + name + &#34;}.&#34;)
        query = (
            &#34;&#34;&#34;
            mutation CourseOfActionAdd($input: CourseOfActionAddInput) {
                courseOfActionAdd(input: $input) {
                    &#34;&#34;&#34;
            + self.properties
            + &#34;&#34;&#34;
                }
            }
        &#34;&#34;&#34;
        )
        result = self.opencti.query(
            query,
            {
                &#34;input&#34;: {
                    &#34;name&#34;: name,
                    &#34;description&#34;: description,
                    &#34;alias&#34;: alias,
                    &#34;internal_id_key&#34;: id,
                    &#34;stix_id_key&#34;: stix_id_key,
                    &#34;created&#34;: created,
                    &#34;modified&#34;: modified,
                    &#34;createdByRef&#34;: created_by_ref,
                    &#34;markingDefinitions&#34;: marking_definitions,
                }
            },
        )
        return self.opencti.process_multiple_fields(
            result[&#34;data&#34;][&#34;courseOfActionAdd&#34;]
        )
    else:
        self.opencti.log(
            &#34;error&#34;,
            &#34;[opencti_course_of_action] Missing parameters: name and description&#34;,
        )</code></pre>
</details>
</dd>
<dt id="pycti.CourseOfAction.list"><code class="name flex">
<span>def <span class="ident">list</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list(self, **kwargs):
    filters = kwargs.get(&#34;filters&#34;, None)
    search = kwargs.get(&#34;search&#34;, None)
    first = kwargs.get(&#34;first&#34;, 500)
    after = kwargs.get(&#34;after&#34;, None)
    order_by = kwargs.get(&#34;orderBy&#34;, None)
    order_mode = kwargs.get(&#34;orderMode&#34;, None)
    get_all = kwargs.get(&#34;getAll&#34;, False)
    if get_all:
        first = 500

    self.opencti.log(
        &#34;info&#34;,
        &#34;Listing Course-Of-Actions with filters &#34; + json.dumps(filters) + &#34;.&#34;,
    )
    query = (
        &#34;&#34;&#34;
        query CourseOfActions($filters: [CourseOfActionsFiltering], $search: String, $first: Int, $after: ID, $orderBy: CoursesOfActionOrdering, $orderMode: OrderingMode) {
            courseOfActions(filters: $filters, search: $search, first: $first, after: $after, orderBy: $orderBy, orderMode: $orderMode) {
                edges {
                    node {
                        &#34;&#34;&#34;
        + self.properties
        + &#34;&#34;&#34;
                    }
                }
                pageInfo {
                    startCursor
                    endCursor
                    hasNextPage
                    hasPreviousPage
                    globalCount
                }
            }
        }
    &#34;&#34;&#34;
    )
    result = self.opencti.query(
        query,
        {
            &#34;filters&#34;: filters,
            &#34;search&#34;: search,
            &#34;first&#34;: first,
            &#34;after&#34;: after,
            &#34;orderBy&#34;: order_by,
            &#34;orderMode&#34;: order_mode,
        },
    )
    return self.opencti.process_multiple(result[&#34;data&#34;][&#34;courseOfActions&#34;])</code></pre>
</details>
</dd>
<dt id="pycti.CourseOfAction.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    filters = kwargs.get(&#34;filters&#34;, None)
    custom_attributes = kwargs.get(&#34;customAttributes&#34;, None)
    if id is not None:
        self.opencti.log(&#34;info&#34;, &#34;Reading Course-Of-Action {&#34; + id + &#34;}.&#34;)
        query = (
            &#34;&#34;&#34;
            query CourseOfAction($id: String!) {
                courseOfAction(id: $id) {
                    &#34;&#34;&#34;
            + (
                custom_attributes
                if custom_attributes is not None
                else self.properties
            )
            + &#34;&#34;&#34;
                }
            }
         &#34;&#34;&#34;
        )
        result = self.opencti.query(query, {&#34;id&#34;: id})
        return self.opencti.process_multiple_fields(
            result[&#34;data&#34;][&#34;courseOfAction&#34;]
        )
    elif filters is not None:
        result = self.list(filters=filters)
        if len(result) &gt; 0:
            return result[0]
        else:
            return None
    else:
        self.opencti.log(
            &#34;error&#34;, &#34;[opencti_course_of_action] Missing parameters: id or filters&#34;
        )
        return None</code></pre>
</details>
</dd>
<dt id="pycti.CourseOfAction.to_stix2"><code class="name flex">
<span>def <span class="ident">to_stix2</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_stix2(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    mode = kwargs.get(&#34;mode&#34;, &#34;simple&#34;)
    max_marking_definition_entity = kwargs.get(
        &#34;max_marking_definition_entity&#34;, None
    )
    entity = kwargs.get(&#34;entity&#34;, None)
    if id is not None and entity is None:
        entity = self.read(id=id)
    if entity is not None:
        course_of_action = dict()
        course_of_action[&#34;id&#34;] = entity[&#34;stix_id_key&#34;]
        course_of_action[&#34;type&#34;] = &#34;course-of-action&#34;
        course_of_action[&#34;spec_version&#34;] = SPEC_VERSION
        course_of_action[&#34;name&#34;] = entity[&#34;name&#34;]
        if self.opencti.not_empty(entity[&#34;stix_label&#34;]):
            course_of_action[&#34;labels&#34;] = entity[&#34;stix_label&#34;]
        else:
            course_of_action[&#34;labels&#34;] = [&#34;course-of-action&#34;]
        if self.opencti.not_empty(entity[&#34;description&#34;]):
            course_of_action[&#34;description&#34;] = entity[&#34;description&#34;]
        course_of_action[&#34;created&#34;] = self.opencti.stix2.format_date(
            entity[&#34;created&#34;]
        )
        course_of_action[&#34;modified&#34;] = self.opencti.stix2.format_date(
            entity[&#34;modified&#34;]
        )
        if self.opencti.not_empty(entity[&#34;alias&#34;]):
            course_of_action[CustomProperties.ALIASES] = entity[&#34;alias&#34;]
        course_of_action[CustomProperties.ID] = entity[&#34;id&#34;]
        return self.opencti.stix2.prepare_export(
            entity, course_of_action, mode, max_marking_definition_entity
        )
    else:
        self.opencti.log(&#34;error&#34;, &#34;Missing parameters: id or entity&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pycti.CustomProperties"><code class="flex name class">
<span>class <span class="ident">CustomProperties</span></span>
</code></dt>
<dd>
<div class="desc"><p>These are the custom properies used by OpenCTI.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CustomProperties:
    &#34;&#34;&#34;These are the custom properies used by OpenCTI.

    &#34;&#34;&#34;

    # internal id used by OpenCTI - this will be auto generated
    ID = &#34;x_opencti_id&#34;

    # List of files
    FILES = &#34;x_opencti_files&#34;

    # This should be set on all reports to one of the following values:
    #  &#34;external&#34;
    #  &#34;internal&#34;
    REPORT_CLASS = &#34;x_opencti_report_class&#34;

    # use with observed_data and indicators
    INDICATOR_PATTERN = &#34;x_opencti_indicator_pattern&#34;
    PATTERN_TYPE = &#34;x_opencti_pattern_type&#34;
    OBSERVABLE_TYPE = &#34;x_opencti_observable_type&#34;
    OBSERVABLE_VALUE = &#34;x_opencti_observable_value&#34;
    CREATE_OBSERVABLES = &#34;x_opencti_observables_create&#34;
    CREATE_INDICATOR = &#34;x_opencti_indicator_create&#34;

    # custom created and modified dates
    # use with STIX &#34;kill chain&#34; and &#34;external reference&#34; objects
    CREATED = &#34;x_opencti_created&#34;
    MODIFIED = &#34;x_opencti_modified&#34;

    # use with attack pattern
    EXTERNAL_ID = &#34;x_opencti_external_id&#34;

    # use with vulnerability
    BASE_SCORE = &#34;x_opencti_base_score&#34;
    BASE_SEVERITY = &#34;x_opencti_base_severity&#34;
    ATTACK_VECTOR = &#34;x_opencti_attack_vector&#34;
    INTEGRITY_IMPACT = &#34;x_opencti_integrity_impact&#34;
    AVAILABILITY_IMPACT = &#34;x_opencti_availability_impact&#34;

    # use with intrusion-set, campaign, relation
    FIRST_SEEN = &#34;x_opencti_first_seen&#34;
    LAST_SEEN = &#34;x_opencti_last_seen&#34;

    # use with marking definitions
    COLOR = &#34;x_opencti_color&#34;
    LEVEL = &#34;x_opencti_level&#34;  # should be an integer

    # use with kill chain
    PHASE_ORDER = &#34;x_opencti_phase_order&#34;

    # use with relation
    WEIGHT = &#34;x_opencti_weight&#34;
    SCORE = &#34;x_opencti_score&#34;
    ROLE_PLAYED = &#34;x_opencti_role_played&#34;
    EXPIRATION = &#34;x_opencti_expiration&#34;
    SOURCE_REF = &#34;x_opencti_source_ref&#34;
    TARGET_REF = &#34;x_opencti_target_ref&#34;
    IGNORE_DATES = &#34;x_opencti_ignore_dates&#34;

    # generic property - applies to most SDOs
    ALIASES = &#34;x_opencti_aliases&#34;

    # applies to STIX Identity
    ORG_CLASS = &#34;x_opencti_organization_class&#34;
    IDENTITY_TYPE = (
        &#34;x_opencti_identity_type&#34;  # this overrides the stix &#39;identity_class&#39; property!
    )
    TAG_TYPE = &#34;x_opencti_tags&#34;

    # applies to STIX report
    OBJECT_STATUS = &#34;x_opencti_object_status&#34;
    SRC_CONF_LEVEL = &#34;x_opencti_source_confidence_level&#34;
    GRAPH_DATA = &#34;x_opencti_graph_data&#34;

    # applies to STIX note
    NAME = &#34;x_opencti_name&#34;</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="pycti.CustomProperties.ALIASES"><code class="name">var <span class="ident">ALIASES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.CustomProperties.ATTACK_VECTOR"><code class="name">var <span class="ident">ATTACK_VECTOR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.CustomProperties.AVAILABILITY_IMPACT"><code class="name">var <span class="ident">AVAILABILITY_IMPACT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.CustomProperties.BASE_SCORE"><code class="name">var <span class="ident">BASE_SCORE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.CustomProperties.BASE_SEVERITY"><code class="name">var <span class="ident">BASE_SEVERITY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.CustomProperties.COLOR"><code class="name">var <span class="ident">COLOR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.CustomProperties.CREATED"><code class="name">var <span class="ident">CREATED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.CustomProperties.CREATE_INDICATOR"><code class="name">var <span class="ident">CREATE_INDICATOR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.CustomProperties.CREATE_OBSERVABLES"><code class="name">var <span class="ident">CREATE_OBSERVABLES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.CustomProperties.EXPIRATION"><code class="name">var <span class="ident">EXPIRATION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.CustomProperties.EXTERNAL_ID"><code class="name">var <span class="ident">EXTERNAL_ID</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.CustomProperties.FILES"><code class="name">var <span class="ident">FILES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.CustomProperties.FIRST_SEEN"><code class="name">var <span class="ident">FIRST_SEEN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.CustomProperties.GRAPH_DATA"><code class="name">var <span class="ident">GRAPH_DATA</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.CustomProperties.ID"><code class="name">var <span class="ident">ID</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.CustomProperties.IDENTITY_TYPE"><code class="name">var <span class="ident">IDENTITY_TYPE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.CustomProperties.IGNORE_DATES"><code class="name">var <span class="ident">IGNORE_DATES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.CustomProperties.INDICATOR_PATTERN"><code class="name">var <span class="ident">INDICATOR_PATTERN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.CustomProperties.INTEGRITY_IMPACT"><code class="name">var <span class="ident">INTEGRITY_IMPACT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.CustomProperties.LAST_SEEN"><code class="name">var <span class="ident">LAST_SEEN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.CustomProperties.LEVEL"><code class="name">var <span class="ident">LEVEL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.CustomProperties.MODIFIED"><code class="name">var <span class="ident">MODIFIED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.CustomProperties.NAME"><code class="name">var <span class="ident">NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.CustomProperties.OBJECT_STATUS"><code class="name">var <span class="ident">OBJECT_STATUS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.CustomProperties.OBSERVABLE_TYPE"><code class="name">var <span class="ident">OBSERVABLE_TYPE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.CustomProperties.OBSERVABLE_VALUE"><code class="name">var <span class="ident">OBSERVABLE_VALUE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.CustomProperties.ORG_CLASS"><code class="name">var <span class="ident">ORG_CLASS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.CustomProperties.PATTERN_TYPE"><code class="name">var <span class="ident">PATTERN_TYPE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.CustomProperties.PHASE_ORDER"><code class="name">var <span class="ident">PHASE_ORDER</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.CustomProperties.REPORT_CLASS"><code class="name">var <span class="ident">REPORT_CLASS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.CustomProperties.ROLE_PLAYED"><code class="name">var <span class="ident">ROLE_PLAYED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.CustomProperties.SCORE"><code class="name">var <span class="ident">SCORE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.CustomProperties.SOURCE_REF"><code class="name">var <span class="ident">SOURCE_REF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.CustomProperties.SRC_CONF_LEVEL"><code class="name">var <span class="ident">SRC_CONF_LEVEL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.CustomProperties.TAG_TYPE"><code class="name">var <span class="ident">TAG_TYPE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.CustomProperties.TARGET_REF"><code class="name">var <span class="ident">TARGET_REF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.CustomProperties.WEIGHT"><code class="name">var <span class="ident">WEIGHT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="pycti.ExternalReference"><code class="flex name class">
<span>class <span class="ident">ExternalReference</span></span>
<span>(</span><span>opencti)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ExternalReference:
    def __init__(self, opencti):
        self.opencti = opencti
        self.properties = &#34;&#34;&#34;
            id
            entity_type
            stix_id_key
            source_name
            description
            url
            hash
            external_id
            created
            modified
            created_at
            updated_at
        &#34;&#34;&#34;

    &#34;&#34;&#34;
        List External-Reference objects

        :param filters: the filters to apply
        :param first: return the first n rows from the after ID (or the beginning if not set)
        :param after: ID of the first row for pagination
        :return List of External-Reference objects
    &#34;&#34;&#34;

    def list(self, **kwargs):
        filters = kwargs.get(&#34;filters&#34;, None)
        first = kwargs.get(&#34;first&#34;, 500)
        after = kwargs.get(&#34;after&#34;, None)
        order_by = kwargs.get(&#34;orderBy&#34;, None)
        order_mode = kwargs.get(&#34;orderMode&#34;, None)
        get_all = kwargs.get(&#34;getAll&#34;, False)
        if get_all:
            first = 500

        self.opencti.log(
            &#34;info&#34;,
            &#34;Listing External-Reference with filters &#34; + json.dumps(filters) + &#34;.&#34;,
        )
        query = (
            &#34;&#34;&#34;
            query ExternalReferences($filters: [ExternalReferencesFiltering], $first: Int, $after: ID, $orderBy: ExternalReferencesOrdering, $orderMode: OrderingMode) {
                externalReferences(filters: $filters, first: $first, after: $after, orderBy: $orderBy, orderMode: $orderMode) {
                    edges {
                        node {
                            &#34;&#34;&#34;
            + self.properties
            + &#34;&#34;&#34;
                        }
                    }
                    pageInfo {
                        startCursor
                        endCursor
                        hasNextPage
                        hasPreviousPage
                        globalCount
                    }
                }
            }
        &#34;&#34;&#34;
        )
        result = self.opencti.query(
            query,
            {
                &#34;filters&#34;: filters,
                &#34;first&#34;: first,
                &#34;after&#34;: after,
                &#34;orderBy&#34;: order_by,
                &#34;orderMode&#34;: order_mode,
            },
        )
        return self.opencti.process_multiple(result[&#34;data&#34;][&#34;externalReferences&#34;])

    &#34;&#34;&#34;
        Read a External-Reference object

        :param id: the id of the External-Reference
        :param filters: the filters to apply if no id provided
        :return External-Reference object
    &#34;&#34;&#34;

    def read(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        filters = kwargs.get(&#34;filters&#34;, None)
        if id is not None:
            self.opencti.log(&#34;info&#34;, &#34;Reading External-Reference {&#34; + id + &#34;}.&#34;)
            query = (
                &#34;&#34;&#34;
                query ExternalReference($id: String!) {
                    externalReference(id: $id) {
                        &#34;&#34;&#34;
                + self.properties
                + &#34;&#34;&#34;
                    }
                }
            &#34;&#34;&#34;
            )
            result = self.opencti.query(query, {&#34;id&#34;: id})
            return self.opencti.process_multiple_fields(
                result[&#34;data&#34;][&#34;externalReference&#34;]
            )
        elif filters is not None:
            result = self.list(filters=filters)
            if len(result) &gt; 0:
                return result[0]
            else:
                return None
        else:
            self.opencti.log(
                &#34;error&#34;,
                &#34;[opencti_external_reference] Missing parameters: id or filters&#34;,
            )
            return None

    &#34;&#34;&#34;
        Create a External Reference object

        :param source_name: the source_name of the External Reference
        :return External Reference object
    &#34;&#34;&#34;

    def create_raw(self, **kwargs):
        source_name = kwargs.get(&#34;source_name&#34;, None)
        url = kwargs.get(&#34;url&#34;, None)
        external_id = kwargs.get(&#34;external_id&#34;, None)
        description = kwargs.get(&#34;description&#34;, None)
        id = kwargs.get(&#34;id&#34;, None)
        stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
        created = kwargs.get(&#34;created&#34;, None)
        modified = kwargs.get(&#34;modified&#34;, None)

        if source_name is not None and url is not None:
            self.opencti.log(
                &#34;info&#34;, &#34;Creating External Reference {&#34; + source_name + &#34;}.&#34;
            )
            query = (
                &#34;&#34;&#34;
                mutation ExternalReferenceAdd($input: ExternalReferenceAddInput) {
                    externalReferenceAdd(input: $input) {
                        &#34;&#34;&#34;
                + self.properties
                + &#34;&#34;&#34;
                    }
                }
            &#34;&#34;&#34;
            )
            result = self.opencti.query(
                query,
                {
                    &#34;input&#34;: {
                        &#34;source_name&#34;: source_name,
                        &#34;external_id&#34;: external_id,
                        &#34;description&#34;: description,
                        &#34;url&#34;: url,
                        &#34;internal_id_key&#34;: id,
                        &#34;stix_id_key&#34;: stix_id_key,
                        &#34;created&#34;: created,
                        &#34;modified&#34;: modified,
                    }
                },
            )
            return self.opencti.process_multiple_fields(
                result[&#34;data&#34;][&#34;externalReferenceAdd&#34;]
            )
        else:
            self.opencti.log(
                &#34;error&#34;,
                &#34;[opencti_external_reference] Missing parameters: source_name and url&#34;,
            )

    &#34;&#34;&#34;
        Create a External Reference object only if it not exists, update it on request

        :param name: the name of the External Reference
        :return External Reference object
    &#34;&#34;&#34;

    def create(self, **kwargs):
        source_name = kwargs.get(&#34;source_name&#34;, None)
        url = kwargs.get(&#34;url&#34;, None)
        external_id = kwargs.get(&#34;external_id&#34;, None)
        description = kwargs.get(&#34;description&#34;, None)
        id = kwargs.get(&#34;id&#34;, None)
        stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
        created = kwargs.get(&#34;created&#34;, None)
        modified = kwargs.get(&#34;modified&#34;, None)

        external_reference_result = self.read(filters=[{&#34;key&#34;: &#34;url&#34;, &#34;values&#34;: [url]}])
        if external_reference_result is not None:
            return external_reference_result
        else:
            return self.create_raw(
                source_name=source_name,
                url=url,
                external_id=external_id,
                description=description,
                id=id,
                stix_id_key=stix_id_key,
                created=created,
                modified=modified,
            )</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pycti.ExternalReference.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create(self, **kwargs):
    source_name = kwargs.get(&#34;source_name&#34;, None)
    url = kwargs.get(&#34;url&#34;, None)
    external_id = kwargs.get(&#34;external_id&#34;, None)
    description = kwargs.get(&#34;description&#34;, None)
    id = kwargs.get(&#34;id&#34;, None)
    stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
    created = kwargs.get(&#34;created&#34;, None)
    modified = kwargs.get(&#34;modified&#34;, None)

    external_reference_result = self.read(filters=[{&#34;key&#34;: &#34;url&#34;, &#34;values&#34;: [url]}])
    if external_reference_result is not None:
        return external_reference_result
    else:
        return self.create_raw(
            source_name=source_name,
            url=url,
            external_id=external_id,
            description=description,
            id=id,
            stix_id_key=stix_id_key,
            created=created,
            modified=modified,
        )</code></pre>
</details>
</dd>
<dt id="pycti.ExternalReference.create_raw"><code class="name flex">
<span>def <span class="ident">create_raw</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_raw(self, **kwargs):
    source_name = kwargs.get(&#34;source_name&#34;, None)
    url = kwargs.get(&#34;url&#34;, None)
    external_id = kwargs.get(&#34;external_id&#34;, None)
    description = kwargs.get(&#34;description&#34;, None)
    id = kwargs.get(&#34;id&#34;, None)
    stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
    created = kwargs.get(&#34;created&#34;, None)
    modified = kwargs.get(&#34;modified&#34;, None)

    if source_name is not None and url is not None:
        self.opencti.log(
            &#34;info&#34;, &#34;Creating External Reference {&#34; + source_name + &#34;}.&#34;
        )
        query = (
            &#34;&#34;&#34;
            mutation ExternalReferenceAdd($input: ExternalReferenceAddInput) {
                externalReferenceAdd(input: $input) {
                    &#34;&#34;&#34;
            + self.properties
            + &#34;&#34;&#34;
                }
            }
        &#34;&#34;&#34;
        )
        result = self.opencti.query(
            query,
            {
                &#34;input&#34;: {
                    &#34;source_name&#34;: source_name,
                    &#34;external_id&#34;: external_id,
                    &#34;description&#34;: description,
                    &#34;url&#34;: url,
                    &#34;internal_id_key&#34;: id,
                    &#34;stix_id_key&#34;: stix_id_key,
                    &#34;created&#34;: created,
                    &#34;modified&#34;: modified,
                }
            },
        )
        return self.opencti.process_multiple_fields(
            result[&#34;data&#34;][&#34;externalReferenceAdd&#34;]
        )
    else:
        self.opencti.log(
            &#34;error&#34;,
            &#34;[opencti_external_reference] Missing parameters: source_name and url&#34;,
        )</code></pre>
</details>
</dd>
<dt id="pycti.ExternalReference.list"><code class="name flex">
<span>def <span class="ident">list</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list(self, **kwargs):
    filters = kwargs.get(&#34;filters&#34;, None)
    first = kwargs.get(&#34;first&#34;, 500)
    after = kwargs.get(&#34;after&#34;, None)
    order_by = kwargs.get(&#34;orderBy&#34;, None)
    order_mode = kwargs.get(&#34;orderMode&#34;, None)
    get_all = kwargs.get(&#34;getAll&#34;, False)
    if get_all:
        first = 500

    self.opencti.log(
        &#34;info&#34;,
        &#34;Listing External-Reference with filters &#34; + json.dumps(filters) + &#34;.&#34;,
    )
    query = (
        &#34;&#34;&#34;
        query ExternalReferences($filters: [ExternalReferencesFiltering], $first: Int, $after: ID, $orderBy: ExternalReferencesOrdering, $orderMode: OrderingMode) {
            externalReferences(filters: $filters, first: $first, after: $after, orderBy: $orderBy, orderMode: $orderMode) {
                edges {
                    node {
                        &#34;&#34;&#34;
        + self.properties
        + &#34;&#34;&#34;
                    }
                }
                pageInfo {
                    startCursor
                    endCursor
                    hasNextPage
                    hasPreviousPage
                    globalCount
                }
            }
        }
    &#34;&#34;&#34;
    )
    result = self.opencti.query(
        query,
        {
            &#34;filters&#34;: filters,
            &#34;first&#34;: first,
            &#34;after&#34;: after,
            &#34;orderBy&#34;: order_by,
            &#34;orderMode&#34;: order_mode,
        },
    )
    return self.opencti.process_multiple(result[&#34;data&#34;][&#34;externalReferences&#34;])</code></pre>
</details>
</dd>
<dt id="pycti.ExternalReference.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    filters = kwargs.get(&#34;filters&#34;, None)
    if id is not None:
        self.opencti.log(&#34;info&#34;, &#34;Reading External-Reference {&#34; + id + &#34;}.&#34;)
        query = (
            &#34;&#34;&#34;
            query ExternalReference($id: String!) {
                externalReference(id: $id) {
                    &#34;&#34;&#34;
            + self.properties
            + &#34;&#34;&#34;
                }
            }
        &#34;&#34;&#34;
        )
        result = self.opencti.query(query, {&#34;id&#34;: id})
        return self.opencti.process_multiple_fields(
            result[&#34;data&#34;][&#34;externalReference&#34;]
        )
    elif filters is not None:
        result = self.list(filters=filters)
        if len(result) &gt; 0:
            return result[0]
        else:
            return None
    else:
        self.opencti.log(
            &#34;error&#34;,
            &#34;[opencti_external_reference] Missing parameters: id or filters&#34;,
        )
        return None</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pycti.Identity"><code class="flex name class">
<span>class <span class="ident">Identity</span></span>
<span>(</span><span>opencti)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Identity:
    def __init__(self, opencti):
        self.opencti = opencti
        self.properties = &#34;&#34;&#34;
            id
            stix_id_key
            stix_label
            entity_type
            parent_types
            name
            alias
            description
            created
            modified            
            created_at
            updated_at
            ... on Organization {
                organization_class
            }
            createdByRef {
                node {
                    id
                    entity_type
                    stix_id_key
                    stix_label
                    name
                    alias
                    description
                    created
                    modified
                    ... on Organization {
                        organization_class
                    }
                }
                relation {
                    id
                }
            }            
            markingDefinitions {
                edges {
                    node {
                        id
                        entity_type
                        stix_id_key
                        definition_type
                        definition
                        level
                        color
                        created
                        modified
                    }
                    relation {
                        id
                    }
                }
            }
            tags {
                edges {
                    node {
                        id
                        tag_type
                        value
                        color
                    }
                    relation {
                        id
                    }
                }
            }
            externalReferences {
                edges {
                    node {
                        id
                        entity_type
                        stix_id_key
                        source_name
                        description
                        url
                        hash
                        external_id
                        created
                        modified
                    }
                    relation {
                        id
                    }
                }
            }
        &#34;&#34;&#34;

    &#34;&#34;&#34;
        List Identity objects

        :param types: the list of types
        :param filters: the filters to apply
        :param search: the search keyword
        :param first: return the first n rows from the after ID (or the beginning if not set)
        :param after: ID of the first row for pagination
        :return List of Identity objects
    &#34;&#34;&#34;

    def list(self, **kwargs):
        types = kwargs.get(&#34;types&#34;, None)
        filters = kwargs.get(&#34;filters&#34;, None)
        search = kwargs.get(&#34;search&#34;, None)
        first = kwargs.get(&#34;first&#34;, 500)
        after = kwargs.get(&#34;after&#34;, None)
        order_by = kwargs.get(&#34;orderBy&#34;, None)
        order_mode = kwargs.get(&#34;orderMode&#34;, None)
        get_all = kwargs.get(&#34;getAll&#34;, False)
        if get_all:
            first = 500

        self.opencti.log(
            &#34;info&#34;, &#34;Listing Identities with filters &#34; + json.dumps(filters) + &#34;.&#34;
        )
        query = (
            &#34;&#34;&#34;
            query Identities($types: [String], $filters: [IdentitiesFiltering], $search: String, $first: Int, $after: ID, $orderBy: IdentitiesOrdering, $orderMode: OrderingMode) {
                identities(types: $types, filters: $filters, search: $search, first: $first, after: $after, orderBy: $orderBy, orderMode: $orderMode) {
                    edges {
                        node {
                            &#34;&#34;&#34;
            + self.properties
            + &#34;&#34;&#34;
                        }
                    }
                    pageInfo {
                        startCursor
                        endCursor
                        hasNextPage
                        hasPreviousPage
                        globalCount
                    }
                }
            }
        &#34;&#34;&#34;
        )
        result = self.opencti.query(
            query,
            {
                &#34;types&#34;: types,
                &#34;filters&#34;: filters,
                &#34;search&#34;: search,
                &#34;first&#34;: first,
                &#34;after&#34;: after,
                &#34;orderBy&#34;: order_by,
                &#34;orderMode&#34;: order_mode,
            },
        )
        return self.opencti.process_multiple(result[&#34;data&#34;][&#34;identities&#34;])

    &#34;&#34;&#34;
        Read a Identity object
        
        :param id: the id of the Identity
        :param filters: the filters to apply if no id provided
        :return Identity object
    &#34;&#34;&#34;

    def read(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        filters = kwargs.get(&#34;filters&#34;, None)
        custom_attributes = kwargs.get(&#34;customAttributes&#34;, None)
        if id is not None:
            self.opencti.log(&#34;info&#34;, &#34;Reading Identity {&#34; + id + &#34;}.&#34;)
            query = (
                &#34;&#34;&#34;
                query Identity($id: String!) {
                    identity(id: $id) {
                        &#34;&#34;&#34;
                + (
                    custom_attributes
                    if custom_attributes is not None
                    else self.properties
                )
                + &#34;&#34;&#34;
                    }
                }
             &#34;&#34;&#34;
            )
            result = self.opencti.query(query, {&#34;id&#34;: id})
            return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;identity&#34;])
        elif filters is not None:
            result = self.list(filters=filters)
            if len(result) &gt; 0:
                return result[0]
            else:
                return None
        else:
            self.opencti.log(
                &#34;error&#34;, &#34;[opencti_identity] Missing parameters: id or filters&#34;
            )
            return None

    &#34;&#34;&#34;
        Create a Identity object

        :param name: the name of the Identity
        :return Identity object
    &#34;&#34;&#34;

    def create_raw(self, **kwargs):
        type = kwargs.get(&#34;type&#34;, None)
        name = kwargs.get(&#34;name&#34;, None)
        description = kwargs.get(&#34;description&#34;, None)
        alias = kwargs.get(&#34;alias&#34;, None)
        id = kwargs.get(&#34;id&#34;, None)
        stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
        created = kwargs.get(&#34;created&#34;, None)
        modified = kwargs.get(&#34;modified&#34;, None)
        created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
        marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)

        if name is not None and description is not None:
            self.opencti.log(&#34;info&#34;, &#34;Creating Identity {&#34; + name + &#34;}.&#34;)
            query = (
                &#34;&#34;&#34;
                mutation IdentityAdd($input: IdentityAddInput) {
                    identityAdd(input: $input) {
                         &#34;&#34;&#34;
                + self.properties
                + &#34;&#34;&#34;
                    }
                }
            &#34;&#34;&#34;
            )
            result = self.opencti.query(
                query,
                {
                    &#34;input&#34;: {
                        &#34;name&#34;: name,
                        &#34;description&#34;: description,
                        &#34;alias&#34;: alias,
                        &#34;type&#34;: type,
                        &#34;internal_id_key&#34;: id,
                        &#34;stix_id_key&#34;: stix_id_key,
                        &#34;created&#34;: created,
                        &#34;modified&#34;: modified,
                        &#34;createdByRef&#34;: created_by_ref,
                        &#34;markingDefinitions&#34;: marking_definitions,
                    }
                },
            )
            return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;identityAdd&#34;])
        else:
            self.opencti.log(&#34;error&#34;, &#34;Missing parameters: name and description&#34;)

    &#34;&#34;&#34;
        Create a  Identity object only if it not exists, update it on request

        :param name: the name of the Identity
        :return Identity object
    &#34;&#34;&#34;

    def create(self, **kwargs):
        type = kwargs.get(&#34;type&#34;, None)
        name = kwargs.get(&#34;name&#34;, None)
        description = kwargs.get(&#34;description&#34;, None)
        alias = kwargs.get(&#34;alias&#34;, None)
        id = kwargs.get(&#34;id&#34;, None)
        stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
        created = kwargs.get(&#34;created&#34;, None)
        modified = kwargs.get(&#34;modified&#34;, None)
        created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
        marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)
        update = kwargs.get(&#34;update&#34;, False)
        custom_attributes = &#34;&#34;&#34;
            id
            entity_type
            name
            description 
            alias
        &#34;&#34;&#34;
        object_result = self.opencti.stix_domain_entity.get_by_stix_id_or_name(
            types=[type],
            stix_id_key=stix_id_key,
            name=name,
            customAttributes=custom_attributes,
        )
        if object_result is not None:
            if update:
                # name
                if object_result[&#34;name&#34;] != name:
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;name&#34;, value=name
                    )
                    object_result[&#34;name&#34;] = name
                # description
                if object_result[&#34;description&#34;] != description:
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;description&#34;, value=description
                    )
                    object_result[&#34;description&#34;] = description
                # alias
                if alias is not None and object_result[&#34;alias&#34;] != alias:
                    if &#34;alias&#34; in object_result:
                        new_aliases = object_result[&#34;alias&#34;] + list(
                            set(alias) - set(object_result[&#34;alias&#34;])
                        )
                    else:
                        new_aliases = alias
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;alias&#34;, value=new_aliases
                    )
                    object_result[&#34;alias&#34;] = new_aliases
            return object_result
        else:
            return self.create_raw(
                type=type,
                name=name,
                description=description,
                alias=alias,
                id=id,
                stix_id_key=stix_id_key,
                created=created,
                modified=modified,
                createdByRef=created_by_ref,
                markingDefinitions=marking_definitions,
            )

    &#34;&#34;&#34;
        Export an Identity object in STIX2
    
        :param id: the id of the Identity
        :return Identity object
    &#34;&#34;&#34;

    def to_stix2(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        mode = kwargs.get(&#34;mode&#34;, &#34;simple&#34;)
        max_marking_definition_entity = kwargs.get(
            &#34;max_marking_definition_entity&#34;, None
        )
        entity = kwargs.get(&#34;entity&#34;, None)
        if id is not None and entity is None:
            entity = self.read(id=id)
        if entity is not None:
            if entity[&#34;entity_type&#34;] == &#34;user&#34;:
                identity_class = &#34;individual&#34;
            elif entity[&#34;entity_type&#34;] == &#34;sector&#34;:
                identity_class = &#34;class&#34;
            else:
                identity_class = &#34;organization&#34;
            identity = dict()
            identity[&#34;id&#34;] = entity[&#34;stix_id_key&#34;]
            identity[&#34;type&#34;] = &#34;identity&#34;
            identity[&#34;spec_version&#34;] = SPEC_VERSION
            identity[&#34;name&#34;] = entity[&#34;name&#34;]
            identity[&#34;identity_class&#34;] = identity_class
            if self.opencti.not_empty(entity[&#34;stix_label&#34;]):
                identity[&#34;labels&#34;] = entity[&#34;stix_label&#34;]
            else:
                identity[&#34;labels&#34;] = [&#34;identity&#34;]
            if self.opencti.not_empty(entity[&#34;description&#34;]):
                identity[&#34;description&#34;] = entity[&#34;description&#34;]
            identity[&#34;created&#34;] = self.opencti.stix2.format_date(entity[&#34;created&#34;])
            identity[&#34;modified&#34;] = self.opencti.stix2.format_date(entity[&#34;modified&#34;])
            if self.opencti.not_empty(entity[&#34;alias&#34;]):
                identity[&#34;aliases&#34;] = entity[&#34;alias&#34;]
            if (
                entity[&#34;entity_type&#34;] == &#34;organization&#34;
                and &#34;organization_class&#34; in entity
                and self.opencti.not_empty(entity[&#34;organization_class&#34;])
            ):
                identity[CustomProperties.ORG_CLASS] = entity[&#34;organization_class&#34;]
            identity[CustomProperties.IDENTITY_TYPE] = entity[&#34;entity_type&#34;]
            identity[CustomProperties.ID] = entity[&#34;id&#34;]
            return self.opencti.stix2.prepare_export(
                entity, identity, mode, max_marking_definition_entity
            )
        else:
            self.opencti.log(&#34;error&#34;, &#34;Missing parameters: id or entity&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pycti.Identity.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create(self, **kwargs):
    type = kwargs.get(&#34;type&#34;, None)
    name = kwargs.get(&#34;name&#34;, None)
    description = kwargs.get(&#34;description&#34;, None)
    alias = kwargs.get(&#34;alias&#34;, None)
    id = kwargs.get(&#34;id&#34;, None)
    stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
    created = kwargs.get(&#34;created&#34;, None)
    modified = kwargs.get(&#34;modified&#34;, None)
    created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
    marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)
    update = kwargs.get(&#34;update&#34;, False)
    custom_attributes = &#34;&#34;&#34;
        id
        entity_type
        name
        description 
        alias
    &#34;&#34;&#34;
    object_result = self.opencti.stix_domain_entity.get_by_stix_id_or_name(
        types=[type],
        stix_id_key=stix_id_key,
        name=name,
        customAttributes=custom_attributes,
    )
    if object_result is not None:
        if update:
            # name
            if object_result[&#34;name&#34;] != name:
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;name&#34;, value=name
                )
                object_result[&#34;name&#34;] = name
            # description
            if object_result[&#34;description&#34;] != description:
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;description&#34;, value=description
                )
                object_result[&#34;description&#34;] = description
            # alias
            if alias is not None and object_result[&#34;alias&#34;] != alias:
                if &#34;alias&#34; in object_result:
                    new_aliases = object_result[&#34;alias&#34;] + list(
                        set(alias) - set(object_result[&#34;alias&#34;])
                    )
                else:
                    new_aliases = alias
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;alias&#34;, value=new_aliases
                )
                object_result[&#34;alias&#34;] = new_aliases
        return object_result
    else:
        return self.create_raw(
            type=type,
            name=name,
            description=description,
            alias=alias,
            id=id,
            stix_id_key=stix_id_key,
            created=created,
            modified=modified,
            createdByRef=created_by_ref,
            markingDefinitions=marking_definitions,
        )</code></pre>
</details>
</dd>
<dt id="pycti.Identity.create_raw"><code class="name flex">
<span>def <span class="ident">create_raw</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_raw(self, **kwargs):
    type = kwargs.get(&#34;type&#34;, None)
    name = kwargs.get(&#34;name&#34;, None)
    description = kwargs.get(&#34;description&#34;, None)
    alias = kwargs.get(&#34;alias&#34;, None)
    id = kwargs.get(&#34;id&#34;, None)
    stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
    created = kwargs.get(&#34;created&#34;, None)
    modified = kwargs.get(&#34;modified&#34;, None)
    created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
    marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)

    if name is not None and description is not None:
        self.opencti.log(&#34;info&#34;, &#34;Creating Identity {&#34; + name + &#34;}.&#34;)
        query = (
            &#34;&#34;&#34;
            mutation IdentityAdd($input: IdentityAddInput) {
                identityAdd(input: $input) {
                     &#34;&#34;&#34;
            + self.properties
            + &#34;&#34;&#34;
                }
            }
        &#34;&#34;&#34;
        )
        result = self.opencti.query(
            query,
            {
                &#34;input&#34;: {
                    &#34;name&#34;: name,
                    &#34;description&#34;: description,
                    &#34;alias&#34;: alias,
                    &#34;type&#34;: type,
                    &#34;internal_id_key&#34;: id,
                    &#34;stix_id_key&#34;: stix_id_key,
                    &#34;created&#34;: created,
                    &#34;modified&#34;: modified,
                    &#34;createdByRef&#34;: created_by_ref,
                    &#34;markingDefinitions&#34;: marking_definitions,
                }
            },
        )
        return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;identityAdd&#34;])
    else:
        self.opencti.log(&#34;error&#34;, &#34;Missing parameters: name and description&#34;)</code></pre>
</details>
</dd>
<dt id="pycti.Identity.list"><code class="name flex">
<span>def <span class="ident">list</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list(self, **kwargs):
    types = kwargs.get(&#34;types&#34;, None)
    filters = kwargs.get(&#34;filters&#34;, None)
    search = kwargs.get(&#34;search&#34;, None)
    first = kwargs.get(&#34;first&#34;, 500)
    after = kwargs.get(&#34;after&#34;, None)
    order_by = kwargs.get(&#34;orderBy&#34;, None)
    order_mode = kwargs.get(&#34;orderMode&#34;, None)
    get_all = kwargs.get(&#34;getAll&#34;, False)
    if get_all:
        first = 500

    self.opencti.log(
        &#34;info&#34;, &#34;Listing Identities with filters &#34; + json.dumps(filters) + &#34;.&#34;
    )
    query = (
        &#34;&#34;&#34;
        query Identities($types: [String], $filters: [IdentitiesFiltering], $search: String, $first: Int, $after: ID, $orderBy: IdentitiesOrdering, $orderMode: OrderingMode) {
            identities(types: $types, filters: $filters, search: $search, first: $first, after: $after, orderBy: $orderBy, orderMode: $orderMode) {
                edges {
                    node {
                        &#34;&#34;&#34;
        + self.properties
        + &#34;&#34;&#34;
                    }
                }
                pageInfo {
                    startCursor
                    endCursor
                    hasNextPage
                    hasPreviousPage
                    globalCount
                }
            }
        }
    &#34;&#34;&#34;
    )
    result = self.opencti.query(
        query,
        {
            &#34;types&#34;: types,
            &#34;filters&#34;: filters,
            &#34;search&#34;: search,
            &#34;first&#34;: first,
            &#34;after&#34;: after,
            &#34;orderBy&#34;: order_by,
            &#34;orderMode&#34;: order_mode,
        },
    )
    return self.opencti.process_multiple(result[&#34;data&#34;][&#34;identities&#34;])</code></pre>
</details>
</dd>
<dt id="pycti.Identity.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    filters = kwargs.get(&#34;filters&#34;, None)
    custom_attributes = kwargs.get(&#34;customAttributes&#34;, None)
    if id is not None:
        self.opencti.log(&#34;info&#34;, &#34;Reading Identity {&#34; + id + &#34;}.&#34;)
        query = (
            &#34;&#34;&#34;
            query Identity($id: String!) {
                identity(id: $id) {
                    &#34;&#34;&#34;
            + (
                custom_attributes
                if custom_attributes is not None
                else self.properties
            )
            + &#34;&#34;&#34;
                }
            }
         &#34;&#34;&#34;
        )
        result = self.opencti.query(query, {&#34;id&#34;: id})
        return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;identity&#34;])
    elif filters is not None:
        result = self.list(filters=filters)
        if len(result) &gt; 0:
            return result[0]
        else:
            return None
    else:
        self.opencti.log(
            &#34;error&#34;, &#34;[opencti_identity] Missing parameters: id or filters&#34;
        )
        return None</code></pre>
</details>
</dd>
<dt id="pycti.Identity.to_stix2"><code class="name flex">
<span>def <span class="ident">to_stix2</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_stix2(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    mode = kwargs.get(&#34;mode&#34;, &#34;simple&#34;)
    max_marking_definition_entity = kwargs.get(
        &#34;max_marking_definition_entity&#34;, None
    )
    entity = kwargs.get(&#34;entity&#34;, None)
    if id is not None and entity is None:
        entity = self.read(id=id)
    if entity is not None:
        if entity[&#34;entity_type&#34;] == &#34;user&#34;:
            identity_class = &#34;individual&#34;
        elif entity[&#34;entity_type&#34;] == &#34;sector&#34;:
            identity_class = &#34;class&#34;
        else:
            identity_class = &#34;organization&#34;
        identity = dict()
        identity[&#34;id&#34;] = entity[&#34;stix_id_key&#34;]
        identity[&#34;type&#34;] = &#34;identity&#34;
        identity[&#34;spec_version&#34;] = SPEC_VERSION
        identity[&#34;name&#34;] = entity[&#34;name&#34;]
        identity[&#34;identity_class&#34;] = identity_class
        if self.opencti.not_empty(entity[&#34;stix_label&#34;]):
            identity[&#34;labels&#34;] = entity[&#34;stix_label&#34;]
        else:
            identity[&#34;labels&#34;] = [&#34;identity&#34;]
        if self.opencti.not_empty(entity[&#34;description&#34;]):
            identity[&#34;description&#34;] = entity[&#34;description&#34;]
        identity[&#34;created&#34;] = self.opencti.stix2.format_date(entity[&#34;created&#34;])
        identity[&#34;modified&#34;] = self.opencti.stix2.format_date(entity[&#34;modified&#34;])
        if self.opencti.not_empty(entity[&#34;alias&#34;]):
            identity[&#34;aliases&#34;] = entity[&#34;alias&#34;]
        if (
            entity[&#34;entity_type&#34;] == &#34;organization&#34;
            and &#34;organization_class&#34; in entity
            and self.opencti.not_empty(entity[&#34;organization_class&#34;])
        ):
            identity[CustomProperties.ORG_CLASS] = entity[&#34;organization_class&#34;]
        identity[CustomProperties.IDENTITY_TYPE] = entity[&#34;entity_type&#34;]
        identity[CustomProperties.ID] = entity[&#34;id&#34;]
        return self.opencti.stix2.prepare_export(
            entity, identity, mode, max_marking_definition_entity
        )
    else:
        self.opencti.log(&#34;error&#34;, &#34;Missing parameters: id or entity&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pycti.Incident"><code class="flex name class">
<span>class <span class="ident">Incident</span></span>
<span>(</span><span>opencti)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Incident:
    def __init__(self, opencti):
        self.opencti = opencti
        self.properties = &#34;&#34;&#34;
            id
            stix_id_key
            stix_label
            entity_type
            parent_types
            name
            alias
            description
            graph_data
            objective
            first_seen
            last_seen
            created
            modified            
            created_at
            updated_at
            createdByRef {
                node {
                    id
                    entity_type
                    stix_id_key
                    stix_label
                    name
                    alias
                    description
                    created
                    modified
                }
                relation {
                    id
                }
            }            
            markingDefinitions {
                edges {
                    node {
                        id
                        entity_type
                        stix_id_key
                        definition_type
                        definition
                        level
                        color
                        created
                        modified
                    }
                    relation {
                        id
                    }
                }
            }
            tags {
                edges {
                    node {
                        id
                        tag_type
                        value
                        color
                    }
                    relation {
                        id
                    }
                }
            }
            externalReferences {
                edges {
                    node {
                        id
                        entity_type
                        stix_id_key
                        source_name
                        description
                        url
                        hash
                        external_id
                        created
                        modified
                    }
                    relation {
                        id
                    }
                }
            }
            observableRefs {
                edges {
                    node {
                        id
                        entity_type
                        stix_id_key
                        observable_value
                    }
                    relation {
                        id
                    }
                }
            }
        &#34;&#34;&#34;

    &#34;&#34;&#34;
        List Incident objects

        :param filters: the filters to apply
        :param search: the search keyword
        :param first: return the first n rows from the after ID (or the beginning if not set)
        :param after: ID of the first row for pagination
        :return List of Incident objects
    &#34;&#34;&#34;

    def list(self, **kwargs):
        filters = kwargs.get(&#34;filters&#34;, None)
        search = kwargs.get(&#34;search&#34;, None)
        first = kwargs.get(&#34;first&#34;, 500)
        after = kwargs.get(&#34;after&#34;, None)
        order_by = kwargs.get(&#34;orderBy&#34;, None)
        order_mode = kwargs.get(&#34;orderMode&#34;, None)
        get_all = kwargs.get(&#34;getAll&#34;, False)
        if get_all:
            first = 500

        self.opencti.log(
            &#34;info&#34;, &#34;Listing Incidents with filters &#34; + json.dumps(filters) + &#34;.&#34;
        )
        query = (
            &#34;&#34;&#34;
            query Incidents($filters: [IncidentsFiltering], $search: String, $first: Int, $after: ID, $orderBy: IncidentsOrdering, $orderMode: OrderingMode) {
                incidents(filters: $filters, search: $search, first: $first, after: $after, orderBy: $orderBy, orderMode: $orderMode) {
                    edges {
                        node {
                            &#34;&#34;&#34;
            + self.properties
            + &#34;&#34;&#34;
                        }
                    }
                    pageInfo {
                        startCursor
                        endCursor
                        hasNextPage
                        hasPreviousPage
                        globalCount
                    }
                }
            }
        &#34;&#34;&#34;
        )
        result = self.opencti.query(
            query,
            {
                &#34;filters&#34;: filters,
                &#34;search&#34;: search,
                &#34;first&#34;: first,
                &#34;after&#34;: after,
                &#34;orderBy&#34;: order_by,
                &#34;orderMode&#34;: order_mode,
            },
        )
        return self.opencti.process_multiple(result[&#34;data&#34;][&#34;incidents&#34;])

    &#34;&#34;&#34;
        Read a Incident object
        
        :param id: the id of the Incident
        :param filters: the filters to apply if no id provided
        :return Incident object
    &#34;&#34;&#34;

    def read(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        filters = kwargs.get(&#34;filters&#34;, None)
        custom_attributes = kwargs.get(&#34;customAttributes&#34;, None)
        if id is not None:
            self.opencti.log(&#34;info&#34;, &#34;Reading Incident {&#34; + id + &#34;}.&#34;)
            query = (
                &#34;&#34;&#34;
                query Incident($id: String!) {
                    incident(id: $id) {
                        &#34;&#34;&#34;
                + (
                    custom_attributes
                    if custom_attributes is not None
                    else self.properties
                )
                + &#34;&#34;&#34;
                    }
                }
             &#34;&#34;&#34;
            )
            result = self.opencti.query(query, {&#34;id&#34;: id})
            return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;incident&#34;])
        elif filters is not None:
            result = self.list(filters=filters)
            if len(result) &gt; 0:
                return result[0]
            else:
                return None
        else:
            self.opencti.log(
                &#34;error&#34;, &#34;[opencti_incident] Missing parameters: id or filters&#34;
            )
            return None

    &#34;&#34;&#34;
        Create a Incident object

        :param name: the name of the Incident
        :return Incident object
    &#34;&#34;&#34;

    def create_raw(self, **kwargs):
        name = kwargs.get(&#34;name&#34;, None)
        description = kwargs.get(&#34;description&#34;, None)
        alias = kwargs.get(&#34;alias&#34;, None)
        first_seen = kwargs.get(&#34;first_seen&#34;, None)
        last_seen = kwargs.get(&#34;last_seen&#34;, None)
        objective = kwargs.get(&#34;objective&#34;, None)
        id = kwargs.get(&#34;id&#34;, None)
        stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
        created = kwargs.get(&#34;created&#34;, None)
        modified = kwargs.get(&#34;modified&#34;, None)
        created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
        marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)

        if name is not None and description is not None:
            self.opencti.log(&#34;info&#34;, &#34;Creating Incident {&#34; + name + &#34;}.&#34;)
            query = (
                &#34;&#34;&#34;
                mutation IncidentAdd($input: IncidentAddInput) {
                    incidentAdd(input: $input) {
                        &#34;&#34;&#34;
                + self.properties
                + &#34;&#34;&#34;
                    }
               }
            &#34;&#34;&#34;
            )
            result = self.opencti.query(
                query,
                {
                    &#34;input&#34;: {
                        &#34;name&#34;: name,
                        &#34;description&#34;: description,
                        &#34;alias&#34;: alias,
                        &#34;objective&#34;: objective,
                        &#34;first_seen&#34;: first_seen,
                        &#34;last_seen&#34;: last_seen,
                        &#34;internal_id_key&#34;: id,
                        &#34;stix_id_key&#34;: stix_id_key,
                        &#34;created&#34;: created,
                        &#34;modified&#34;: modified,
                        &#34;createdByRef&#34;: created_by_ref,
                        &#34;markingDefinitions&#34;: marking_definitions,
                    }
                },
            )
            return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;incidentAdd&#34;])
        else:
            self.opencti.log(&#34;error&#34;, &#34;Missing parameters: name and description&#34;)

    &#34;&#34;&#34;
         Create a Incident object only if it not exists, update it on request

         :param name: the name of the Incident
         :return Incident object
     &#34;&#34;&#34;

    def create(self, **kwargs):
        name = kwargs.get(&#34;name&#34;, None)
        description = kwargs.get(&#34;description&#34;, None)
        alias = kwargs.get(&#34;alias&#34;, None)
        first_seen = kwargs.get(&#34;first_seen&#34;, None)
        last_seen = kwargs.get(&#34;last_seen&#34;, None)
        objective = kwargs.get(&#34;objective&#34;, None)
        id = kwargs.get(&#34;id&#34;, None)
        stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
        created = kwargs.get(&#34;created&#34;, None)
        modified = kwargs.get(&#34;modified&#34;, None)
        created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
        marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)
        update = kwargs.get(&#34;update&#34;, False)
        custom_attributes = &#34;&#34;&#34;
            id
            entity_type
            name
            description 
            alias
            ... on Incident {
                first_seen
                last_seen
                objective
            }
        &#34;&#34;&#34;
        object_result = self.opencti.stix_domain_entity.get_by_stix_id_or_name(
            types=[&#34;Incident&#34;],
            stix_id_key=stix_id_key,
            name=name,
            customAttributes=custom_attributes,
        )
        if object_result is not None:
            if update:
                # name
                if object_result[&#34;name&#34;] != name:
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;name&#34;, value=name
                    )
                    object_result[&#34;name&#34;] = name
                # description
                if object_result[&#34;description&#34;] != description:
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;description&#34;, value=description
                    )
                    object_result[&#34;description&#34;] = description
                # alias
                if alias is not None and object_result[&#34;alias&#34;] != alias:
                    if &#34;alias&#34; in object_result:
                        new_aliases = object_result[&#34;alias&#34;] + list(
                            set(alias) - set(object_result[&#34;alias&#34;])
                        )
                    else:
                        new_aliases = alias
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;alias&#34;, value=new_aliases
                    )
                    object_result[&#34;alias&#34;] = new_aliases
                # first_seen
                if first_seen is not None and object_result[&#34;first_seen&#34;] != first_seen:
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;first_seen&#34;, value=first_seen
                    )
                    object_result[&#34;first_seen&#34;] = first_seen
                # last_seen
                if last_seen is not None and object_result[&#34;last_seen&#34;] != last_seen:
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;last_seen&#34;, value=last_seen
                    )
                    object_result[&#34;last_seen&#34;] = last_seen
                # objective
                if objective is not None and object_result[&#34;objective&#34;] != objective:
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;objective&#34;, value=objective
                    )
                    object_result[&#34;objective&#34;] = objective
            return object_result
        else:
            return self.create_raw(
                name=name,
                description=description,
                alias=alias,
                first_seen=first_seen,
                last_seen=last_seen,
                objective=objective,
                id=id,
                stix_id_key=stix_id_key,
                created=created,
                modified=modified,
                createdByRef=created_by_ref,
                markingDefinitions=marking_definitions,
            )

    &#34;&#34;&#34;
        Add a Stix-Observable object to Incident object (observable_refs)

        :param id: the id of the Incident
        :param entity_id: the id of the Stix-Observable
        :return Boolean
    &#34;&#34;&#34;

    def add_stix_observable(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        incident = kwargs.get(&#34;incident&#34;, None)
        stix_observable_id = kwargs.get(&#34;stix_observable_id&#34;, None)
        if id is not None and stix_observable_id is not None:
            if incident is None:
                incident = self.read(id=id)
            if incident is None:
                self.opencti.log(
                    &#34;error&#34;,
                    &#34;[opencti_incident] Cannot add Object Ref, incident not found&#34;,
                )
                return False
            if stix_observable_id in incident[&#34;observableRefsIds&#34;]:
                return True
            else:
                self.opencti.log(
                    &#34;info&#34;,
                    &#34;Adding Stix-Observable {&#34;
                    + stix_observable_id
                    + &#34;} to Incident {&#34;
                    + id
                    + &#34;}&#34;,
                )
                query = &#34;&#34;&#34;
                   mutation IncidentEdit($id: ID!, $input: RelationAddInput) {
                       incidentEdit(id: $id) {
                            relationAdd(input: $input) {
                                id
                            }
                       }
                   }
                &#34;&#34;&#34;
                self.opencti.query(
                    query,
                    {
                        &#34;id&#34;: id,
                        &#34;input&#34;: {
                            &#34;fromRole&#34;: &#34;observables_aggregation&#34;,
                            &#34;toId&#34;: stix_observable_id,
                            &#34;toRole&#34;: &#34;soo&#34;,
                            &#34;through&#34;: &#34;observable_refs&#34;,
                        },
                    },
                )
                return True
        else:
            self.opencti.log(
                &#34;error&#34;,
                &#34;[opencti_incident] Missing parameters: id and stix_observable_id&#34;,
            )
            return False

    &#34;&#34;&#34;
        Export an Incident object in STIX2
    
        :param id: the id of the Incident
        :return Incident object
    &#34;&#34;&#34;

    def to_stix2(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        mode = kwargs.get(&#34;mode&#34;, &#34;simple&#34;)
        max_marking_definition_entity = kwargs.get(
            &#34;max_marking_definition_entity&#34;, None
        )
        entity = kwargs.get(&#34;entity&#34;, None)
        if id is not None and entity is None:
            entity = self.read(id=id)
        if entity is not None:
            incident = dict()
            incident[&#34;id&#34;] = entity[&#34;stix_id_key&#34;]
            incident[&#34;type&#34;] = &#34;x-opencti-incident&#34;
            incident[&#34;spec_version&#34;] = SPEC_VERSION
            incident[&#34;name&#34;] = entity[&#34;name&#34;]
            if self.opencti.not_empty(entity[&#34;stix_label&#34;]):
                incident[&#34;labels&#34;] = entity[&#34;stix_label&#34;]
            else:
                incident[&#34;labels&#34;] = [&#34;x-opencti-incident&#34;]
            if self.opencti.not_empty(entity[&#34;alias&#34;]):
                incident[&#34;aliases&#34;] = entity[&#34;alias&#34;]
            if self.opencti.not_empty(entity[&#34;description&#34;]):
                incident[&#34;description&#34;] = entity[&#34;description&#34;]
            if self.opencti.not_empty(entity[&#34;objective&#34;]):
                incident[&#34;objective&#34;] = entity[&#34;objective&#34;]
            if self.opencti.not_empty(entity[&#34;first_seen&#34;]):
                incident[&#34;first_seen&#34;] = self.opencti.stix2.format_date(
                    entity[&#34;first_seen&#34;]
                )
            if self.opencti.not_empty(entity[&#34;last_seen&#34;]):
                incident[&#34;last_seen&#34;] = self.opencti.stix2.format_date(
                    entity[&#34;last_seen&#34;]
                )
            incident[&#34;created&#34;] = self.opencti.stix2.format_date(entity[&#34;created&#34;])
            incident[&#34;modified&#34;] = self.opencti.stix2.format_date(entity[&#34;modified&#34;])
            incident[CustomProperties.ID] = entity[&#34;id&#34;]
            return self.opencti.stix2.prepare_export(
                entity, incident, mode, max_marking_definition_entity
            )
        else:
            self.opencti.log(&#34;error&#34;, &#34;Missing parameters: id or entity&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pycti.Incident.add_stix_observable"><code class="name flex">
<span>def <span class="ident">add_stix_observable</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_stix_observable(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    incident = kwargs.get(&#34;incident&#34;, None)
    stix_observable_id = kwargs.get(&#34;stix_observable_id&#34;, None)
    if id is not None and stix_observable_id is not None:
        if incident is None:
            incident = self.read(id=id)
        if incident is None:
            self.opencti.log(
                &#34;error&#34;,
                &#34;[opencti_incident] Cannot add Object Ref, incident not found&#34;,
            )
            return False
        if stix_observable_id in incident[&#34;observableRefsIds&#34;]:
            return True
        else:
            self.opencti.log(
                &#34;info&#34;,
                &#34;Adding Stix-Observable {&#34;
                + stix_observable_id
                + &#34;} to Incident {&#34;
                + id
                + &#34;}&#34;,
            )
            query = &#34;&#34;&#34;
               mutation IncidentEdit($id: ID!, $input: RelationAddInput) {
                   incidentEdit(id: $id) {
                        relationAdd(input: $input) {
                            id
                        }
                   }
               }
            &#34;&#34;&#34;
            self.opencti.query(
                query,
                {
                    &#34;id&#34;: id,
                    &#34;input&#34;: {
                        &#34;fromRole&#34;: &#34;observables_aggregation&#34;,
                        &#34;toId&#34;: stix_observable_id,
                        &#34;toRole&#34;: &#34;soo&#34;,
                        &#34;through&#34;: &#34;observable_refs&#34;,
                    },
                },
            )
            return True
    else:
        self.opencti.log(
            &#34;error&#34;,
            &#34;[opencti_incident] Missing parameters: id and stix_observable_id&#34;,
        )
        return False</code></pre>
</details>
</dd>
<dt id="pycti.Incident.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create(self, **kwargs):
    name = kwargs.get(&#34;name&#34;, None)
    description = kwargs.get(&#34;description&#34;, None)
    alias = kwargs.get(&#34;alias&#34;, None)
    first_seen = kwargs.get(&#34;first_seen&#34;, None)
    last_seen = kwargs.get(&#34;last_seen&#34;, None)
    objective = kwargs.get(&#34;objective&#34;, None)
    id = kwargs.get(&#34;id&#34;, None)
    stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
    created = kwargs.get(&#34;created&#34;, None)
    modified = kwargs.get(&#34;modified&#34;, None)
    created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
    marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)
    update = kwargs.get(&#34;update&#34;, False)
    custom_attributes = &#34;&#34;&#34;
        id
        entity_type
        name
        description 
        alias
        ... on Incident {
            first_seen
            last_seen
            objective
        }
    &#34;&#34;&#34;
    object_result = self.opencti.stix_domain_entity.get_by_stix_id_or_name(
        types=[&#34;Incident&#34;],
        stix_id_key=stix_id_key,
        name=name,
        customAttributes=custom_attributes,
    )
    if object_result is not None:
        if update:
            # name
            if object_result[&#34;name&#34;] != name:
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;name&#34;, value=name
                )
                object_result[&#34;name&#34;] = name
            # description
            if object_result[&#34;description&#34;] != description:
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;description&#34;, value=description
                )
                object_result[&#34;description&#34;] = description
            # alias
            if alias is not None and object_result[&#34;alias&#34;] != alias:
                if &#34;alias&#34; in object_result:
                    new_aliases = object_result[&#34;alias&#34;] + list(
                        set(alias) - set(object_result[&#34;alias&#34;])
                    )
                else:
                    new_aliases = alias
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;alias&#34;, value=new_aliases
                )
                object_result[&#34;alias&#34;] = new_aliases
            # first_seen
            if first_seen is not None and object_result[&#34;first_seen&#34;] != first_seen:
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;first_seen&#34;, value=first_seen
                )
                object_result[&#34;first_seen&#34;] = first_seen
            # last_seen
            if last_seen is not None and object_result[&#34;last_seen&#34;] != last_seen:
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;last_seen&#34;, value=last_seen
                )
                object_result[&#34;last_seen&#34;] = last_seen
            # objective
            if objective is not None and object_result[&#34;objective&#34;] != objective:
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;objective&#34;, value=objective
                )
                object_result[&#34;objective&#34;] = objective
        return object_result
    else:
        return self.create_raw(
            name=name,
            description=description,
            alias=alias,
            first_seen=first_seen,
            last_seen=last_seen,
            objective=objective,
            id=id,
            stix_id_key=stix_id_key,
            created=created,
            modified=modified,
            createdByRef=created_by_ref,
            markingDefinitions=marking_definitions,
        )</code></pre>
</details>
</dd>
<dt id="pycti.Incident.create_raw"><code class="name flex">
<span>def <span class="ident">create_raw</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_raw(self, **kwargs):
    name = kwargs.get(&#34;name&#34;, None)
    description = kwargs.get(&#34;description&#34;, None)
    alias = kwargs.get(&#34;alias&#34;, None)
    first_seen = kwargs.get(&#34;first_seen&#34;, None)
    last_seen = kwargs.get(&#34;last_seen&#34;, None)
    objective = kwargs.get(&#34;objective&#34;, None)
    id = kwargs.get(&#34;id&#34;, None)
    stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
    created = kwargs.get(&#34;created&#34;, None)
    modified = kwargs.get(&#34;modified&#34;, None)
    created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
    marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)

    if name is not None and description is not None:
        self.opencti.log(&#34;info&#34;, &#34;Creating Incident {&#34; + name + &#34;}.&#34;)
        query = (
            &#34;&#34;&#34;
            mutation IncidentAdd($input: IncidentAddInput) {
                incidentAdd(input: $input) {
                    &#34;&#34;&#34;
            + self.properties
            + &#34;&#34;&#34;
                }
           }
        &#34;&#34;&#34;
        )
        result = self.opencti.query(
            query,
            {
                &#34;input&#34;: {
                    &#34;name&#34;: name,
                    &#34;description&#34;: description,
                    &#34;alias&#34;: alias,
                    &#34;objective&#34;: objective,
                    &#34;first_seen&#34;: first_seen,
                    &#34;last_seen&#34;: last_seen,
                    &#34;internal_id_key&#34;: id,
                    &#34;stix_id_key&#34;: stix_id_key,
                    &#34;created&#34;: created,
                    &#34;modified&#34;: modified,
                    &#34;createdByRef&#34;: created_by_ref,
                    &#34;markingDefinitions&#34;: marking_definitions,
                }
            },
        )
        return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;incidentAdd&#34;])
    else:
        self.opencti.log(&#34;error&#34;, &#34;Missing parameters: name and description&#34;)</code></pre>
</details>
</dd>
<dt id="pycti.Incident.list"><code class="name flex">
<span>def <span class="ident">list</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list(self, **kwargs):
    filters = kwargs.get(&#34;filters&#34;, None)
    search = kwargs.get(&#34;search&#34;, None)
    first = kwargs.get(&#34;first&#34;, 500)
    after = kwargs.get(&#34;after&#34;, None)
    order_by = kwargs.get(&#34;orderBy&#34;, None)
    order_mode = kwargs.get(&#34;orderMode&#34;, None)
    get_all = kwargs.get(&#34;getAll&#34;, False)
    if get_all:
        first = 500

    self.opencti.log(
        &#34;info&#34;, &#34;Listing Incidents with filters &#34; + json.dumps(filters) + &#34;.&#34;
    )
    query = (
        &#34;&#34;&#34;
        query Incidents($filters: [IncidentsFiltering], $search: String, $first: Int, $after: ID, $orderBy: IncidentsOrdering, $orderMode: OrderingMode) {
            incidents(filters: $filters, search: $search, first: $first, after: $after, orderBy: $orderBy, orderMode: $orderMode) {
                edges {
                    node {
                        &#34;&#34;&#34;
        + self.properties
        + &#34;&#34;&#34;
                    }
                }
                pageInfo {
                    startCursor
                    endCursor
                    hasNextPage
                    hasPreviousPage
                    globalCount
                }
            }
        }
    &#34;&#34;&#34;
    )
    result = self.opencti.query(
        query,
        {
            &#34;filters&#34;: filters,
            &#34;search&#34;: search,
            &#34;first&#34;: first,
            &#34;after&#34;: after,
            &#34;orderBy&#34;: order_by,
            &#34;orderMode&#34;: order_mode,
        },
    )
    return self.opencti.process_multiple(result[&#34;data&#34;][&#34;incidents&#34;])</code></pre>
</details>
</dd>
<dt id="pycti.Incident.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    filters = kwargs.get(&#34;filters&#34;, None)
    custom_attributes = kwargs.get(&#34;customAttributes&#34;, None)
    if id is not None:
        self.opencti.log(&#34;info&#34;, &#34;Reading Incident {&#34; + id + &#34;}.&#34;)
        query = (
            &#34;&#34;&#34;
            query Incident($id: String!) {
                incident(id: $id) {
                    &#34;&#34;&#34;
            + (
                custom_attributes
                if custom_attributes is not None
                else self.properties
            )
            + &#34;&#34;&#34;
                }
            }
         &#34;&#34;&#34;
        )
        result = self.opencti.query(query, {&#34;id&#34;: id})
        return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;incident&#34;])
    elif filters is not None:
        result = self.list(filters=filters)
        if len(result) &gt; 0:
            return result[0]
        else:
            return None
    else:
        self.opencti.log(
            &#34;error&#34;, &#34;[opencti_incident] Missing parameters: id or filters&#34;
        )
        return None</code></pre>
</details>
</dd>
<dt id="pycti.Incident.to_stix2"><code class="name flex">
<span>def <span class="ident">to_stix2</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_stix2(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    mode = kwargs.get(&#34;mode&#34;, &#34;simple&#34;)
    max_marking_definition_entity = kwargs.get(
        &#34;max_marking_definition_entity&#34;, None
    )
    entity = kwargs.get(&#34;entity&#34;, None)
    if id is not None and entity is None:
        entity = self.read(id=id)
    if entity is not None:
        incident = dict()
        incident[&#34;id&#34;] = entity[&#34;stix_id_key&#34;]
        incident[&#34;type&#34;] = &#34;x-opencti-incident&#34;
        incident[&#34;spec_version&#34;] = SPEC_VERSION
        incident[&#34;name&#34;] = entity[&#34;name&#34;]
        if self.opencti.not_empty(entity[&#34;stix_label&#34;]):
            incident[&#34;labels&#34;] = entity[&#34;stix_label&#34;]
        else:
            incident[&#34;labels&#34;] = [&#34;x-opencti-incident&#34;]
        if self.opencti.not_empty(entity[&#34;alias&#34;]):
            incident[&#34;aliases&#34;] = entity[&#34;alias&#34;]
        if self.opencti.not_empty(entity[&#34;description&#34;]):
            incident[&#34;description&#34;] = entity[&#34;description&#34;]
        if self.opencti.not_empty(entity[&#34;objective&#34;]):
            incident[&#34;objective&#34;] = entity[&#34;objective&#34;]
        if self.opencti.not_empty(entity[&#34;first_seen&#34;]):
            incident[&#34;first_seen&#34;] = self.opencti.stix2.format_date(
                entity[&#34;first_seen&#34;]
            )
        if self.opencti.not_empty(entity[&#34;last_seen&#34;]):
            incident[&#34;last_seen&#34;] = self.opencti.stix2.format_date(
                entity[&#34;last_seen&#34;]
            )
        incident[&#34;created&#34;] = self.opencti.stix2.format_date(entity[&#34;created&#34;])
        incident[&#34;modified&#34;] = self.opencti.stix2.format_date(entity[&#34;modified&#34;])
        incident[CustomProperties.ID] = entity[&#34;id&#34;]
        return self.opencti.stix2.prepare_export(
            entity, incident, mode, max_marking_definition_entity
        )
    else:
        self.opencti.log(&#34;error&#34;, &#34;Missing parameters: id or entity&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pycti.Indicator"><code class="flex name class">
<span>class <span class="ident">Indicator</span></span>
<span>(</span><span>opencti)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Indicator:
    def __init__(self, opencti):
        self.opencti = opencti
        self.properties = &#34;&#34;&#34;
            id
            stix_id_key
            stix_label
            entity_type
            parent_types
            name
            alias
            description
            graph_data
            indicator_pattern
            pattern_type
            valid_from
            valid_until
            score
            created
            modified            
            created_at
            updated_at
            killChainPhases {
                edges {
                    node {
                        id
                        entity_type
                        stix_id_key
                        kill_chain_name
                        phase_name
                        phase_order
                        created
                        modified
                    }
                    relation {
                        id
                    }
                }
            }
            createdByRef {
                node {
                    id
                    entity_type
                    stix_id_key
                    stix_label
                    name
                    alias
                    description
                    created
                    modified
                    ... on Organization {
                        organization_class
                    }
                }
                relation {
                    id
                }
            }            
            markingDefinitions {
                edges {
                    node {
                        id
                        entity_type
                        stix_id_key
                        definition_type
                        definition
                        level
                        color
                        created
                        modified
                    }
                    relation {
                        id
                    }
                }
            }
            tags {
                edges {
                    node {
                        id
                        tag_type
                        value
                        color
                    }
                    relation {
                        id
                    }
                }
            }
            externalReferences {
                edges {
                    node {
                        id
                        entity_type
                        stix_id_key
                        source_name
                        description
                        url
                        hash
                        external_id
                        created
                        modified
                    }
                    relation {
                        id
                    }
                }
            }       
            observableRefs {
                edges {
                    node {
                        id
                        entity_type
                        stix_id_key
                        observable_value
                    }
                    relation {
                        id
                    }
                }
            }
        &#34;&#34;&#34;

    &#34;&#34;&#34;
        List Indicator objects

        :param filters: the filters to apply
        :param search: the search keyword
        :param first: return the first n rows from the after ID (or the beginning if not set)
        :param after: ID of the first row for pagination
        :return List of Indicator objects
    &#34;&#34;&#34;

    def list(self, **kwargs):
        filters = kwargs.get(&#34;filters&#34;, None)
        search = kwargs.get(&#34;search&#34;, None)
        first = kwargs.get(&#34;first&#34;, 500)
        after = kwargs.get(&#34;after&#34;, None)
        order_by = kwargs.get(&#34;orderBy&#34;, None)
        order_mode = kwargs.get(&#34;orderMode&#34;, None)
        get_all = kwargs.get(&#34;getAll&#34;, False)
        if get_all:
            first = 500

        self.opencti.log(
            &#34;info&#34;, &#34;Listing Indicators with filters &#34; + json.dumps(filters) + &#34;.&#34;
        )
        query = (
            &#34;&#34;&#34;
            query Indicators($filters: [IndicatorsFiltering], $search: String, $first: Int, $after: ID, $orderBy: IndicatorsOrdering, $orderMode: OrderingMode) {
                indicators(filters: $filters, search: $search, first: $first, after: $after, orderBy: $orderBy, orderMode: $orderMode) {
                    edges {
                        node {
                            &#34;&#34;&#34;
            + self.properties
            + &#34;&#34;&#34;
                        }
                    }
                    pageInfo {
                        startCursor
                        endCursor
                        hasNextPage
                        hasPreviousPage
                        globalCount
                    }
                }
            }
        &#34;&#34;&#34;
        )
        result = self.opencti.query(
            query,
            {
                &#34;filters&#34;: filters,
                &#34;search&#34;: search,
                &#34;first&#34;: first,
                &#34;after&#34;: after,
                &#34;orderBy&#34;: order_by,
                &#34;orderMode&#34;: order_mode,
            },
        )

        if get_all:
            final_data = []
            data = self.opencti.process_multiple(result[&#34;data&#34;][&#34;indicators&#34;])
            final_data = final_data + data
            while result[&#34;data&#34;][&#34;indicators&#34;][&#34;pageInfo&#34;][&#34;hasNextPage&#34;]:
                after = result[&#34;data&#34;][&#34;indicators&#34;][&#34;pageInfo&#34;][&#34;endCursor&#34;]
                self.opencti.log(&#34;info&#34;, &#34;Listing Indicators after &#34; + after)
                result = self.opencti.query(
                    query,
                    {
                        &#34;filters&#34;: filters,
                        &#34;search&#34;: search,
                        &#34;first&#34;: first,
                        &#34;after&#34;: after,
                        &#34;orderBy&#34;: order_by,
                        &#34;orderMode&#34;: order_mode,
                    },
                )
                data = self.opencti.process_multiple(result[&#34;data&#34;][&#34;indicators&#34;])
                final_data = final_data + data
            return final_data
        else:
            return self.opencti.process_multiple(result[&#34;data&#34;][&#34;indicators&#34;])

    &#34;&#34;&#34;
        Read a Indicator object
        
        :param id: the id of the Indicator
        :param filters: the filters to apply if no id provided
        :return Indicator object
    &#34;&#34;&#34;

    def read(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        filters = kwargs.get(&#34;filters&#34;, None)
        custom_attributes = kwargs.get(&#34;customAttributes&#34;, None)
        if id is not None:
            self.opencti.log(&#34;info&#34;, &#34;Reading Indicator {&#34; + id + &#34;}.&#34;)
            query = (
                &#34;&#34;&#34;
                query Indicator($id: String!) {
                    indicator(id: $id) {
                        &#34;&#34;&#34;
                + (
                    custom_attributes
                    if custom_attributes is not None
                    else self.properties
                )
                + &#34;&#34;&#34;
                    }
                }
             &#34;&#34;&#34;
            )
            result = self.opencti.query(query, {&#34;id&#34;: id})
            return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;indicator&#34;])
        elif filters is not None:
            result = self.list(filters=filters)
            if len(result) &gt; 0:
                return result[0]
            else:
                return None
        else:
            self.opencti.log(
                &#34;error&#34;, &#34;[opencti_indicator] Missing parameters: id or filters&#34;
            )
            return None

    &#34;&#34;&#34;
        Create a Indicator object

        :param name: the name of the Indicator
        :return Indicator object
    &#34;&#34;&#34;

    def create_raw(self, **kwargs):
        name = kwargs.get(&#34;name&#34;, None)
        description = kwargs.get(&#34;description&#34;, None)
        indicator_pattern = kwargs.get(&#34;indicator_pattern&#34;, None)
        main_observable_type = kwargs.get(&#34;main_observable_type&#34;, None)
        pattern_type = kwargs.get(&#34;pattern_type&#34;, None)
        valid_from = kwargs.get(&#34;valid_from&#34;, None)
        valid_until = kwargs.get(&#34;valid_until&#34;, None)
        score = kwargs.get(&#34;score&#34;, None)
        id = kwargs.get(&#34;id&#34;, None)
        stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
        created = kwargs.get(&#34;created&#34;, None)
        modified = kwargs.get(&#34;modified&#34;, None)
        created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
        marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)

        if (
            name is not None
            and indicator_pattern is not None
            and main_observable_type is not None
        ):
            self.opencti.log(&#34;info&#34;, &#34;Creating Indicator {&#34; + name + &#34;}.&#34;)
            query = (
                &#34;&#34;&#34;
                mutation IndicatorAdd($input: IndicatorAddInput) {
                    indicatorAdd(input: $input) {
                        &#34;&#34;&#34;
                + self.properties
                + &#34;&#34;&#34;
                    }
                }
            &#34;&#34;&#34;
            )
            if pattern_type is None:
                pattern_type = &#34;stix2&#34;
            result = self.opencti.query(
                query,
                {
                    &#34;input&#34;: {
                        &#34;name&#34;: name,
                        &#34;description&#34;: description,
                        &#34;indicator_pattern&#34;: indicator_pattern,
                        &#34;main_observable_type&#34;: main_observable_type,
                        &#34;pattern_type&#34;: pattern_type,
                        &#34;valid_from&#34;: valid_from,
                        &#34;valid_until&#34;: valid_until,
                        &#34;score&#34;: score,
                        &#34;internal_id_key&#34;: id,
                        &#34;stix_id_key&#34;: stix_id_key,
                        &#34;created&#34;: created,
                        &#34;modified&#34;: modified,
                        &#34;createdByRef&#34;: created_by_ref,
                        &#34;markingDefinitions&#34;: marking_definitions,
                    }
                },
            )
            return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;indicatorAdd&#34;])
        else:
            self.opencti.log(
                &#34;error&#34;,
                &#34;[opencti_indicator] Missing parameters: name and indicator_pattern and main_observable_type&#34;,
            )

    &#34;&#34;&#34;
        Create a Indicator object only if it not exists, update it on request

        :param name: the name of the Indicator
        :return Indicator object
    &#34;&#34;&#34;

    def create(self, **kwargs):
        name = kwargs.get(&#34;name&#34;, None)
        description = kwargs.get(&#34;description&#34;, None)
        indicator_pattern = kwargs.get(&#34;indicator_pattern&#34;, None)
        main_observable_type = kwargs.get(&#34;main_observable_type&#34;, None)
        pattern_type = kwargs.get(&#34;pattern_type&#34;, None)
        valid_from = kwargs.get(&#34;valid_from&#34;, None)
        valid_until = kwargs.get(&#34;valid_until&#34;, None)
        id = kwargs.get(&#34;id&#34;, None)
        stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
        created = kwargs.get(&#34;created&#34;, None)
        modified = kwargs.get(&#34;modified&#34;, None)
        created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
        marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)
        update = kwargs.get(&#34;update&#34;, False)
        custom_attributes = &#34;&#34;&#34;
                    id
                    entity_type
                    name
                    description
                    ... on Indicator {
                        observableRefs {
                            edges {
                                node {
                                    id
                                    entity_type
                                    stix_id_key
                                    observable_value
                                }
                                relation {
                                    id
                                }
                            }
                        }
                    }
                &#34;&#34;&#34;
        object_result = None
        if stix_id_key is not None:
            object_result = self.opencti.indicator.read(
                id=stix_id_key, customAttributes=custom_attributes
            )
        if object_result is None:
            object_result = self.read(
                filters=[
                    {
                        &#34;key&#34;: &#34;indicator_pattern&#34;,
                        &#34;values&#34;: [indicator_pattern],
                        &#34;operator&#34;: &#34;match&#34; if len(indicator_pattern) &gt; 500 else &#34;eq&#34;,
                    }
                ],
                customAttributes=custom_attributes,
            )
        if object_result is not None:
            if update:
                # name
                if object_result[&#34;name&#34;] != name:
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;name&#34;, value=name
                    )
                    object_result[&#34;name&#34;] = name
                # description
                if object_result[&#34;description&#34;] != description:
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;description&#34;, value=description
                    )
                    object_result[&#34;description&#34;] = description
            return object_result
        else:
            return self.create_raw(
                name=name,
                description=description,
                indicator_pattern=indicator_pattern,
                main_observable_type=main_observable_type,
                pattern_type=pattern_type,
                valid_from=valid_from,
                valid_until=valid_until,
                id=id,
                stix_id_key=stix_id_key,
                created=created,
                modified=modified,
                createdByRef=created_by_ref,
                markingDefinitions=marking_definitions,
            )

    &#34;&#34;&#34;
        Add a Stix-Observable object to Indicator object (observable_refs)

        :param id: the id of the Indicator
        :param entity_id: the id of the Stix-Observable
        :return Boolean
    &#34;&#34;&#34;

    def add_stix_observable(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        indicator = kwargs.get(&#34;indicator&#34;, None)
        stix_observable_id = kwargs.get(&#34;stix_observable_id&#34;, None)
        if id is not None and stix_observable_id is not None:
            if indicator is None:
                indicator = self.read(id=id)
            if indicator is None:
                self.opencti.log(
                    &#34;error&#34;,
                    &#34;[opencti_indicator] Cannot add Object Ref, indicator not found&#34;,
                )
                return False
            if stix_observable_id in indicator[&#34;observableRefsIds&#34;]:
                return True
            else:
                self.opencti.log(
                    &#34;info&#34;,
                    &#34;Adding Stix-Observable {&#34;
                    + stix_observable_id
                    + &#34;} to Indicator {&#34;
                    + id
                    + &#34;}&#34;,
                )
                query = &#34;&#34;&#34;
                   mutation IndicatorEdit($id: ID!, $input: RelationAddInput) {
                       indicatorEdit(id: $id) {
                            relationAdd(input: $input) {
                                id
                            }
                       }
                   }
                &#34;&#34;&#34;
                self.opencti.query(
                    query,
                    {
                        &#34;id&#34;: id,
                        &#34;input&#34;: {
                            &#34;fromRole&#34;: &#34;observables_aggregation&#34;,
                            &#34;toId&#34;: stix_observable_id,
                            &#34;toRole&#34;: &#34;soo&#34;,
                            &#34;through&#34;: &#34;observable_refs&#34;,
                        },
                    },
                )
                return True
        else:
            self.opencti.log(
                &#34;error&#34;,
                &#34;[opencti_indicator] Missing parameters: id and stix_observable_id&#34;,
            )
            return False

    &#34;&#34;&#34;
        Export an Indicator object in STIX2
    
        :param id: the id of the Indicator
        :return Indicator object
    &#34;&#34;&#34;

    def to_stix2(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        mode = kwargs.get(&#34;mode&#34;, &#34;simple&#34;)
        max_marking_definition_entity = kwargs.get(
            &#34;max_marking_definition_entity&#34;, None
        )
        entity = kwargs.get(&#34;entity&#34;, None)
        if id is not None and entity is None:
            entity = self.read(id=id)
        if entity is not None:
            indicator = dict()
            indicator[&#34;id&#34;] = entity[&#34;stix_id_key&#34;]
            indicator[&#34;type&#34;] = &#34;indicator&#34;
            indicator[&#34;spec_version&#34;] = SPEC_VERSION
            indicator[&#34;name&#34;] = entity[&#34;name&#34;]
            if self.opencti.not_empty(entity[&#34;stix_label&#34;]):
                indicator[&#34;labels&#34;] = entity[&#34;stix_label&#34;]
            else:
                indicator[&#34;labels&#34;] = [&#34;indicator&#34;]
            if self.opencti.not_empty(entity[&#34;description&#34;]):
                indicator[&#34;description&#34;] = entity[&#34;description&#34;]
            indicator[&#34;pattern&#34;] = entity[&#34;indicator_pattern&#34;]
            indicator[&#34;valid_from&#34;] = self.opencti.stix2.format_date(
                entity[&#34;valid_from&#34;]
            )
            indicator[&#34;valid_until&#34;] = self.opencti.stix2.format_date(
                entity[&#34;valid_until&#34;]
            )
            if self.opencti.not_empty(entity[&#34;pattern_type&#34;]):
                indicator[CustomProperties.PATTERN_TYPE] = entity[&#34;pattern_type&#34;]
            else:
                indicator[CustomProperties.PATTERN_TYPE] = &#34;stix&#34;
            indicator[&#34;created&#34;] = self.opencti.stix2.format_date(entity[&#34;created&#34;])
            indicator[&#34;modified&#34;] = self.opencti.stix2.format_date(entity[&#34;modified&#34;])
            if self.opencti.not_empty(entity[&#34;alias&#34;]):
                indicator[CustomProperties.ALIASES] = entity[&#34;alias&#34;]
            indicator[CustomProperties.ID] = entity[&#34;id&#34;]
            return self.opencti.stix2.prepare_export(
                entity, indicator, mode, max_marking_definition_entity
            )
        else:
            self.opencti.log(&#34;error&#34;, &#34;Missing parameters: id or entity&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pycti.Indicator.add_stix_observable"><code class="name flex">
<span>def <span class="ident">add_stix_observable</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_stix_observable(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    indicator = kwargs.get(&#34;indicator&#34;, None)
    stix_observable_id = kwargs.get(&#34;stix_observable_id&#34;, None)
    if id is not None and stix_observable_id is not None:
        if indicator is None:
            indicator = self.read(id=id)
        if indicator is None:
            self.opencti.log(
                &#34;error&#34;,
                &#34;[opencti_indicator] Cannot add Object Ref, indicator not found&#34;,
            )
            return False
        if stix_observable_id in indicator[&#34;observableRefsIds&#34;]:
            return True
        else:
            self.opencti.log(
                &#34;info&#34;,
                &#34;Adding Stix-Observable {&#34;
                + stix_observable_id
                + &#34;} to Indicator {&#34;
                + id
                + &#34;}&#34;,
            )
            query = &#34;&#34;&#34;
               mutation IndicatorEdit($id: ID!, $input: RelationAddInput) {
                   indicatorEdit(id: $id) {
                        relationAdd(input: $input) {
                            id
                        }
                   }
               }
            &#34;&#34;&#34;
            self.opencti.query(
                query,
                {
                    &#34;id&#34;: id,
                    &#34;input&#34;: {
                        &#34;fromRole&#34;: &#34;observables_aggregation&#34;,
                        &#34;toId&#34;: stix_observable_id,
                        &#34;toRole&#34;: &#34;soo&#34;,
                        &#34;through&#34;: &#34;observable_refs&#34;,
                    },
                },
            )
            return True
    else:
        self.opencti.log(
            &#34;error&#34;,
            &#34;[opencti_indicator] Missing parameters: id and stix_observable_id&#34;,
        )
        return False</code></pre>
</details>
</dd>
<dt id="pycti.Indicator.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create(self, **kwargs):
    name = kwargs.get(&#34;name&#34;, None)
    description = kwargs.get(&#34;description&#34;, None)
    indicator_pattern = kwargs.get(&#34;indicator_pattern&#34;, None)
    main_observable_type = kwargs.get(&#34;main_observable_type&#34;, None)
    pattern_type = kwargs.get(&#34;pattern_type&#34;, None)
    valid_from = kwargs.get(&#34;valid_from&#34;, None)
    valid_until = kwargs.get(&#34;valid_until&#34;, None)
    id = kwargs.get(&#34;id&#34;, None)
    stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
    created = kwargs.get(&#34;created&#34;, None)
    modified = kwargs.get(&#34;modified&#34;, None)
    created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
    marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)
    update = kwargs.get(&#34;update&#34;, False)
    custom_attributes = &#34;&#34;&#34;
                id
                entity_type
                name
                description
                ... on Indicator {
                    observableRefs {
                        edges {
                            node {
                                id
                                entity_type
                                stix_id_key
                                observable_value
                            }
                            relation {
                                id
                            }
                        }
                    }
                }
            &#34;&#34;&#34;
    object_result = None
    if stix_id_key is not None:
        object_result = self.opencti.indicator.read(
            id=stix_id_key, customAttributes=custom_attributes
        )
    if object_result is None:
        object_result = self.read(
            filters=[
                {
                    &#34;key&#34;: &#34;indicator_pattern&#34;,
                    &#34;values&#34;: [indicator_pattern],
                    &#34;operator&#34;: &#34;match&#34; if len(indicator_pattern) &gt; 500 else &#34;eq&#34;,
                }
            ],
            customAttributes=custom_attributes,
        )
    if object_result is not None:
        if update:
            # name
            if object_result[&#34;name&#34;] != name:
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;name&#34;, value=name
                )
                object_result[&#34;name&#34;] = name
            # description
            if object_result[&#34;description&#34;] != description:
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;description&#34;, value=description
                )
                object_result[&#34;description&#34;] = description
        return object_result
    else:
        return self.create_raw(
            name=name,
            description=description,
            indicator_pattern=indicator_pattern,
            main_observable_type=main_observable_type,
            pattern_type=pattern_type,
            valid_from=valid_from,
            valid_until=valid_until,
            id=id,
            stix_id_key=stix_id_key,
            created=created,
            modified=modified,
            createdByRef=created_by_ref,
            markingDefinitions=marking_definitions,
        )</code></pre>
</details>
</dd>
<dt id="pycti.Indicator.create_raw"><code class="name flex">
<span>def <span class="ident">create_raw</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_raw(self, **kwargs):
    name = kwargs.get(&#34;name&#34;, None)
    description = kwargs.get(&#34;description&#34;, None)
    indicator_pattern = kwargs.get(&#34;indicator_pattern&#34;, None)
    main_observable_type = kwargs.get(&#34;main_observable_type&#34;, None)
    pattern_type = kwargs.get(&#34;pattern_type&#34;, None)
    valid_from = kwargs.get(&#34;valid_from&#34;, None)
    valid_until = kwargs.get(&#34;valid_until&#34;, None)
    score = kwargs.get(&#34;score&#34;, None)
    id = kwargs.get(&#34;id&#34;, None)
    stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
    created = kwargs.get(&#34;created&#34;, None)
    modified = kwargs.get(&#34;modified&#34;, None)
    created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
    marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)

    if (
        name is not None
        and indicator_pattern is not None
        and main_observable_type is not None
    ):
        self.opencti.log(&#34;info&#34;, &#34;Creating Indicator {&#34; + name + &#34;}.&#34;)
        query = (
            &#34;&#34;&#34;
            mutation IndicatorAdd($input: IndicatorAddInput) {
                indicatorAdd(input: $input) {
                    &#34;&#34;&#34;
            + self.properties
            + &#34;&#34;&#34;
                }
            }
        &#34;&#34;&#34;
        )
        if pattern_type is None:
            pattern_type = &#34;stix2&#34;
        result = self.opencti.query(
            query,
            {
                &#34;input&#34;: {
                    &#34;name&#34;: name,
                    &#34;description&#34;: description,
                    &#34;indicator_pattern&#34;: indicator_pattern,
                    &#34;main_observable_type&#34;: main_observable_type,
                    &#34;pattern_type&#34;: pattern_type,
                    &#34;valid_from&#34;: valid_from,
                    &#34;valid_until&#34;: valid_until,
                    &#34;score&#34;: score,
                    &#34;internal_id_key&#34;: id,
                    &#34;stix_id_key&#34;: stix_id_key,
                    &#34;created&#34;: created,
                    &#34;modified&#34;: modified,
                    &#34;createdByRef&#34;: created_by_ref,
                    &#34;markingDefinitions&#34;: marking_definitions,
                }
            },
        )
        return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;indicatorAdd&#34;])
    else:
        self.opencti.log(
            &#34;error&#34;,
            &#34;[opencti_indicator] Missing parameters: name and indicator_pattern and main_observable_type&#34;,
        )</code></pre>
</details>
</dd>
<dt id="pycti.Indicator.list"><code class="name flex">
<span>def <span class="ident">list</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list(self, **kwargs):
    filters = kwargs.get(&#34;filters&#34;, None)
    search = kwargs.get(&#34;search&#34;, None)
    first = kwargs.get(&#34;first&#34;, 500)
    after = kwargs.get(&#34;after&#34;, None)
    order_by = kwargs.get(&#34;orderBy&#34;, None)
    order_mode = kwargs.get(&#34;orderMode&#34;, None)
    get_all = kwargs.get(&#34;getAll&#34;, False)
    if get_all:
        first = 500

    self.opencti.log(
        &#34;info&#34;, &#34;Listing Indicators with filters &#34; + json.dumps(filters) + &#34;.&#34;
    )
    query = (
        &#34;&#34;&#34;
        query Indicators($filters: [IndicatorsFiltering], $search: String, $first: Int, $after: ID, $orderBy: IndicatorsOrdering, $orderMode: OrderingMode) {
            indicators(filters: $filters, search: $search, first: $first, after: $after, orderBy: $orderBy, orderMode: $orderMode) {
                edges {
                    node {
                        &#34;&#34;&#34;
        + self.properties
        + &#34;&#34;&#34;
                    }
                }
                pageInfo {
                    startCursor
                    endCursor
                    hasNextPage
                    hasPreviousPage
                    globalCount
                }
            }
        }
    &#34;&#34;&#34;
    )
    result = self.opencti.query(
        query,
        {
            &#34;filters&#34;: filters,
            &#34;search&#34;: search,
            &#34;first&#34;: first,
            &#34;after&#34;: after,
            &#34;orderBy&#34;: order_by,
            &#34;orderMode&#34;: order_mode,
        },
    )

    if get_all:
        final_data = []
        data = self.opencti.process_multiple(result[&#34;data&#34;][&#34;indicators&#34;])
        final_data = final_data + data
        while result[&#34;data&#34;][&#34;indicators&#34;][&#34;pageInfo&#34;][&#34;hasNextPage&#34;]:
            after = result[&#34;data&#34;][&#34;indicators&#34;][&#34;pageInfo&#34;][&#34;endCursor&#34;]
            self.opencti.log(&#34;info&#34;, &#34;Listing Indicators after &#34; + after)
            result = self.opencti.query(
                query,
                {
                    &#34;filters&#34;: filters,
                    &#34;search&#34;: search,
                    &#34;first&#34;: first,
                    &#34;after&#34;: after,
                    &#34;orderBy&#34;: order_by,
                    &#34;orderMode&#34;: order_mode,
                },
            )
            data = self.opencti.process_multiple(result[&#34;data&#34;][&#34;indicators&#34;])
            final_data = final_data + data
        return final_data
    else:
        return self.opencti.process_multiple(result[&#34;data&#34;][&#34;indicators&#34;])</code></pre>
</details>
</dd>
<dt id="pycti.Indicator.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    filters = kwargs.get(&#34;filters&#34;, None)
    custom_attributes = kwargs.get(&#34;customAttributes&#34;, None)
    if id is not None:
        self.opencti.log(&#34;info&#34;, &#34;Reading Indicator {&#34; + id + &#34;}.&#34;)
        query = (
            &#34;&#34;&#34;
            query Indicator($id: String!) {
                indicator(id: $id) {
                    &#34;&#34;&#34;
            + (
                custom_attributes
                if custom_attributes is not None
                else self.properties
            )
            + &#34;&#34;&#34;
                }
            }
         &#34;&#34;&#34;
        )
        result = self.opencti.query(query, {&#34;id&#34;: id})
        return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;indicator&#34;])
    elif filters is not None:
        result = self.list(filters=filters)
        if len(result) &gt; 0:
            return result[0]
        else:
            return None
    else:
        self.opencti.log(
            &#34;error&#34;, &#34;[opencti_indicator] Missing parameters: id or filters&#34;
        )
        return None</code></pre>
</details>
</dd>
<dt id="pycti.Indicator.to_stix2"><code class="name flex">
<span>def <span class="ident">to_stix2</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_stix2(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    mode = kwargs.get(&#34;mode&#34;, &#34;simple&#34;)
    max_marking_definition_entity = kwargs.get(
        &#34;max_marking_definition_entity&#34;, None
    )
    entity = kwargs.get(&#34;entity&#34;, None)
    if id is not None and entity is None:
        entity = self.read(id=id)
    if entity is not None:
        indicator = dict()
        indicator[&#34;id&#34;] = entity[&#34;stix_id_key&#34;]
        indicator[&#34;type&#34;] = &#34;indicator&#34;
        indicator[&#34;spec_version&#34;] = SPEC_VERSION
        indicator[&#34;name&#34;] = entity[&#34;name&#34;]
        if self.opencti.not_empty(entity[&#34;stix_label&#34;]):
            indicator[&#34;labels&#34;] = entity[&#34;stix_label&#34;]
        else:
            indicator[&#34;labels&#34;] = [&#34;indicator&#34;]
        if self.opencti.not_empty(entity[&#34;description&#34;]):
            indicator[&#34;description&#34;] = entity[&#34;description&#34;]
        indicator[&#34;pattern&#34;] = entity[&#34;indicator_pattern&#34;]
        indicator[&#34;valid_from&#34;] = self.opencti.stix2.format_date(
            entity[&#34;valid_from&#34;]
        )
        indicator[&#34;valid_until&#34;] = self.opencti.stix2.format_date(
            entity[&#34;valid_until&#34;]
        )
        if self.opencti.not_empty(entity[&#34;pattern_type&#34;]):
            indicator[CustomProperties.PATTERN_TYPE] = entity[&#34;pattern_type&#34;]
        else:
            indicator[CustomProperties.PATTERN_TYPE] = &#34;stix&#34;
        indicator[&#34;created&#34;] = self.opencti.stix2.format_date(entity[&#34;created&#34;])
        indicator[&#34;modified&#34;] = self.opencti.stix2.format_date(entity[&#34;modified&#34;])
        if self.opencti.not_empty(entity[&#34;alias&#34;]):
            indicator[CustomProperties.ALIASES] = entity[&#34;alias&#34;]
        indicator[CustomProperties.ID] = entity[&#34;id&#34;]
        return self.opencti.stix2.prepare_export(
            entity, indicator, mode, max_marking_definition_entity
        )
    else:
        self.opencti.log(&#34;error&#34;, &#34;Missing parameters: id or entity&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pycti.IntrusionSet"><code class="flex name class">
<span>class <span class="ident">IntrusionSet</span></span>
<span>(</span><span>opencti)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IntrusionSet:
    def __init__(self, opencti):
        self.opencti = opencti
        self.properties = &#34;&#34;&#34;
            id
            stix_id_key
            stix_label
            entity_type
            parent_types
            name
            alias
            description
            graph_data
            first_seen
            last_seen
            goal
            sophistication
            resource_level
            primary_motivation
            secondary_motivation
            created
            modified
            created_at
            updated_at
            createdByRef {
                node {
                    id
                    entity_type
                    stix_id_key
                    stix_label
                    name
                    alias
                    description
                    created
                    modified
                    ... on Organization {
                        organization_class
                    }
                }
                relation {
                    id
                }
            }            
            markingDefinitions {
                edges {
                    node {
                        id
                        entity_type
                        stix_id_key
                        definition_type
                        definition
                        level
                        color
                        created
                        modified
                    }
                    relation {
                        id
                    }
                }
            }
            tags {
                edges {
                    node {
                        id
                        tag_type
                        value
                        color
                    }
                    relation {
                        id
                    }
                }
            }
            externalReferences {
                edges {
                    node {
                        id
                        entity_type
                        stix_id_key
                        source_name
                        description
                        url
                        hash
                        external_id
                        created
                        modified
                    }
                    relation {
                        id
                    }
                }
            }          
        &#34;&#34;&#34;

    &#34;&#34;&#34;
        List Intrusion-Set objects

        :param filters: the filters to apply
        :param search: the search keyword
        :param first: return the first n rows from the after ID (or the beginning if not set)
        :param after: ID of the first row for pagination
        :return List of Intrusion-Set objects
    &#34;&#34;&#34;

    def list(self, **kwargs):
        filters = kwargs.get(&#34;filters&#34;, None)
        search = kwargs.get(&#34;search&#34;, None)
        first = kwargs.get(&#34;first&#34;, 500)
        after = kwargs.get(&#34;after&#34;, None)
        order_by = kwargs.get(&#34;orderBy&#34;, None)
        order_mode = kwargs.get(&#34;orderMode&#34;, None)
        get_all = kwargs.get(&#34;getAll&#34;, False)
        if get_all:
            first = 500

        self.opencti.log(
            &#34;info&#34;, &#34;Listing Intrusion-Sets with filters &#34; + json.dumps(filters) + &#34;.&#34;
        )
        query = (
            &#34;&#34;&#34;
            query IntrusionSets($filters: [IntrusionSetsFiltering], $search: String, $first: Int, $after: ID, $orderBy: IntrusionSetsOrdering, $orderMode: OrderingMode) {
                intrusionSets(filters: $filters, search: $search, first: $first, after: $after, orderBy: $orderBy, orderMode: $orderMode) {
                    edges {
                        node {
                            &#34;&#34;&#34;
            + self.properties
            + &#34;&#34;&#34;
                        }
                    }
                    pageInfo {
                        startCursor
                        endCursor
                        hasNextPage
                        hasPreviousPage
                        globalCount
                    }
                }
            }
        &#34;&#34;&#34;
        )
        result = self.opencti.query(
            query,
            {
                &#34;filters&#34;: filters,
                &#34;search&#34;: search,
                &#34;first&#34;: first,
                &#34;after&#34;: after,
                &#34;orderBy&#34;: order_by,
                &#34;orderMode&#34;: order_mode,
            },
        )
        return self.opencti.process_multiple(result[&#34;data&#34;][&#34;intrusionSets&#34;])

    &#34;&#34;&#34;
        Read a Intrusion-Set object
        
        :param id: the id of the Intrusion-Set
        :param filters: the filters to apply if no id provided
        :return Intrusion-Set object
    &#34;&#34;&#34;

    def read(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        filters = kwargs.get(&#34;filters&#34;, None)
        custom_attributes = kwargs.get(&#34;customAttributes&#34;, None)
        if id is not None:
            self.opencti.log(&#34;info&#34;, &#34;Reading Intrusion-Set {&#34; + id + &#34;}.&#34;)
            query = (
                &#34;&#34;&#34;
                query IntrusionSet($id: String!) {
                    intrusionSet(id: $id) {
                        &#34;&#34;&#34;
                + (
                    custom_attributes
                    if custom_attributes is not None
                    else self.properties
                )
                + &#34;&#34;&#34;
                    }
                }
             &#34;&#34;&#34;
            )
            result = self.opencti.query(query, {&#34;id&#34;: id})
            return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;intrusionSet&#34;])
        elif filters is not None:
            result = self.list(filters=filters)
            if len(result) &gt; 0:
                return result[0]
            else:
                return None
        else:
            self.opencti.log(
                &#34;error&#34;, &#34;[opencti_intrusion_set] Missing parameters: id or filters&#34;
            )
            return None

    &#34;&#34;&#34;
        Create a Intrusion-Set object

        :param name: the name of the Intrusion Set
        :return Intrusion-Set object
    &#34;&#34;&#34;

    def create_raw(self, **kwargs):
        name = kwargs.get(&#34;name&#34;, None)
        description = kwargs.get(&#34;description&#34;, None)
        alias = kwargs.get(&#34;alias&#34;, None)
        first_seen = kwargs.get(&#34;first_seen&#34;, None)
        last_seen = kwargs.get(&#34;last_seen&#34;, None)
        goal = kwargs.get(&#34;goal&#34;, None)
        sophistication = kwargs.get(&#34;sophistication&#34;, None)
        resource_level = kwargs.get(&#34;resource_level&#34;, None)
        primary_motivation = kwargs.get(&#34;primary_motivation&#34;, None)
        secondary_motivation = kwargs.get(&#34;secondary_motivation&#34;, None)
        id = kwargs.get(&#34;id&#34;, None)
        stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
        created = kwargs.get(&#34;created&#34;, None)
        modified = kwargs.get(&#34;modified&#34;, None)
        created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
        marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)

        if name is not None and description is not None:
            self.opencti.log(&#34;info&#34;, &#34;Creating Intrusion-Set {&#34; + name + &#34;}.&#34;)
            query = (
                &#34;&#34;&#34;
                mutation IntrusionSetAdd($input: IntrusionSetAddInput) {
                    intrusionSetAdd(input: $input) {
                        &#34;&#34;&#34;
                + self.properties
                + &#34;&#34;&#34;
                    }
                }
            &#34;&#34;&#34;
            )
            result = self.opencti.query(
                query,
                {
                    &#34;input&#34;: {
                        &#34;name&#34;: name,
                        &#34;description&#34;: description,
                        &#34;alias&#34;: alias,
                        &#34;first_seen&#34;: first_seen,
                        &#34;last_seen&#34;: last_seen,
                        &#34;goal&#34;: goal,
                        &#34;sophistication&#34;: sophistication,
                        &#34;resource_level&#34;: resource_level,
                        &#34;primary_motivation&#34;: primary_motivation,
                        &#34;secondary_motivation&#34;: secondary_motivation,
                        &#34;internal_id_key&#34;: id,
                        &#34;stix_id_key&#34;: stix_id_key,
                        &#34;created&#34;: created,
                        &#34;modified&#34;: modified,
                        &#34;createdByRef&#34;: created_by_ref,
                        &#34;markingDefinitions&#34;: marking_definitions,
                    }
                },
            )
            return self.opencti.process_multiple_fields(
                result[&#34;data&#34;][&#34;intrusionSetAdd&#34;]
            )
        else:
            self.opencti.log(
                &#34;error&#34;,
                &#34;[opencti_intrusion_set] Missing parameters: name and description&#34;,
            )

    &#34;&#34;&#34;
        Create a Intrusion-Set object only if it not exists, update it on request

        :param name: the name of the Intrusion Set
        :return Intrusion-Set object
    &#34;&#34;&#34;

    def create(self, **kwargs):
        name = kwargs.get(&#34;name&#34;, None)
        description = kwargs.get(&#34;description&#34;, None)
        alias = kwargs.get(&#34;alias&#34;, None)
        first_seen = kwargs.get(&#34;first_seen&#34;, None)
        last_seen = kwargs.get(&#34;last_seen&#34;, None)
        goal = kwargs.get(&#34;goal&#34;, None)
        sophistication = kwargs.get(&#34;sophistication&#34;, None)
        resource_level = kwargs.get(&#34;resource_level&#34;, None)
        primary_motivation = kwargs.get(&#34;primary_motivation&#34;, None)
        secondary_motivation = kwargs.get(&#34;secondary_motivation&#34;, None)
        id = kwargs.get(&#34;id&#34;, None)
        stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
        created = kwargs.get(&#34;created&#34;, None)
        modified = kwargs.get(&#34;modified&#34;, None)
        created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
        marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)
        update = kwargs.get(&#34;update&#34;, False)
        custom_attributes = &#34;&#34;&#34;
            id
            entity_type
            name
            description 
            alias
            ... on IntrusionSet {
                first_seen
                last_seen
                goal
                sophistication
                resource_level
                primary_motivation
                secondary_motivation
            }
        &#34;&#34;&#34;
        object_result = self.opencti.stix_domain_entity.get_by_stix_id_or_name(
            types=[&#34;Intrusion-Set&#34;],
            stix_id_key=stix_id_key,
            name=name,
            customAttributes=custom_attributes,
        )
        if object_result is not None:
            if update:
                # name
                if object_result[&#34;name&#34;] != name:
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;name&#34;, value=name
                    )
                    object_result[&#34;name&#34;] = name
                # description
                if object_result[&#34;description&#34;] != description:
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;description&#34;, value=description
                    )
                    object_result[&#34;description&#34;] = description
                # alias
                if alias is not None and object_result[&#34;alias&#34;] != alias:
                    if &#34;alias&#34; in object_result:
                        new_aliases = object_result[&#34;alias&#34;] + list(
                            set(alias) - set(object_result[&#34;alias&#34;])
                        )
                    else:
                        new_aliases = alias
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;alias&#34;, value=new_aliases
                    )
                    object_result[&#34;alias&#34;] = new_aliases
                # first_seen
                if first_seen is not None and object_result[&#34;first_seen&#34;] != first_seen:
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;first_seen&#34;, value=first_seen
                    )
                    object_result[&#34;first_seen&#34;] = first_seen
                # last_seen
                if last_seen is not None and object_result[&#34;last_seen&#34;] != last_seen:
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;last_seen&#34;, value=last_seen
                    )
                    object_result[&#34;last_seen&#34;] = last_seen
                # goal
                if goal is not None and object_result[&#34;goal&#34;] != goal:
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;goal&#34;, value=goal
                    )
                    object_result[&#34;goal&#34;] = goal
                # sophistication
                if (
                    sophistication is not None
                    and object_result[&#34;sophistication&#34;] != sophistication
                ):
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;],
                        key=&#34;sophistication&#34;,
                        value=sophistication,
                    )
                    object_result[&#34;sophistication&#34;] = sophistication
                # resource_level
                if (
                    resource_level is not None
                    and object_result[&#34;resource_level&#34;] != resource_level
                ):
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;],
                        key=&#34;resource_level&#34;,
                        value=resource_level,
                    )
                    object_result[&#34;resource_level&#34;] = resource_level
                # primary_motivation
                if (
                    primary_motivation is not None
                    and object_result[&#34;primary_motivation&#34;] != primary_motivation
                ):
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;],
                        key=&#34;primary_motivation&#34;,
                        value=primary_motivation,
                    )
                    object_result[&#34;primary_motivation&#34;] = primary_motivation
                # secondary_motivation
                if (
                    secondary_motivation is not None
                    and object_result[&#34;secondary_motivation&#34;] != secondary_motivation
                ):
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;],
                        key=&#34;secondary_motivation&#34;,
                        value=secondary_motivation,
                    )
                    object_result[&#34;secondary_motivation&#34;] = secondary_motivation
            return object_result
        else:
            return self.create_raw(
                name=name,
                description=description,
                alias=alias,
                first_seen=first_seen,
                last_seen=last_seen,
                goal=goal,
                sophistication=sophistication,
                resource_level=resource_level,
                primary_motivation=primary_motivation,
                secondary_motivation=secondary_motivation,
                id=id,
                stix_id_key=stix_id_key,
                created=created,
                modified=modified,
                createdByRef=created_by_ref,
                markingDefinitions=marking_definitions,
            )

    &#34;&#34;&#34;
        Export an Intrusion-Set object in STIX2
    
        :param id: the id of the Intrusion-Set
        :return Intrusion-Set object
    &#34;&#34;&#34;

    def to_stix2(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        mode = kwargs.get(&#34;mode&#34;, &#34;simple&#34;)
        max_marking_definition_entity = kwargs.get(
            &#34;max_marking_definition_entity&#34;, None
        )
        entity = kwargs.get(&#34;entity&#34;, None)
        if id is not None and entity is None:
            entity = self.read(id=id)
        if entity is not None:
            intrusion_set = dict()
            intrusion_set[&#34;id&#34;] = entity[&#34;stix_id_key&#34;]
            intrusion_set[&#34;type&#34;] = &#34;intrusion-set&#34;
            intrusion_set[&#34;spec_version&#34;] = SPEC_VERSION
            intrusion_set[&#34;name&#34;] = entity[&#34;name&#34;]
            if self.opencti.not_empty(entity[&#34;stix_label&#34;]):
                intrusion_set[&#34;labels&#34;] = entity[&#34;stix_label&#34;]
            else:
                intrusion_set[&#34;labels&#34;] = [&#34;intrusion-set&#34;]
            if self.opencti.not_empty(entity[&#34;alias&#34;]):
                intrusion_set[&#34;aliases&#34;] = entity[&#34;alias&#34;]
            if self.opencti.not_empty(entity[&#34;description&#34;]):
                intrusion_set[&#34;description&#34;] = entity[&#34;description&#34;]
            if self.opencti.not_empty(entity[&#34;goal&#34;]):
                intrusion_set[&#34;goals&#34;] = entity[&#34;goal&#34;]
            if self.opencti.not_empty(entity[&#34;sophistication&#34;]):
                intrusion_set[&#34;sophistication&#34;] = entity[&#34;sophistication&#34;]
            if self.opencti.not_empty(entity[&#34;resource_level&#34;]):
                intrusion_set[&#34;resource_level&#34;] = entity[&#34;resource_level&#34;]
            if self.opencti.not_empty(entity[&#34;primary_motivation&#34;]):
                intrusion_set[&#34;primary_motivation&#34;] = entity[&#34;primary_motivation&#34;]
            if self.opencti.not_empty(entity[&#34;secondary_motivation&#34;]):
                intrusion_set[&#34;secondary_motivations&#34;] = entity[&#34;secondary_motivation&#34;]
            if self.opencti.not_empty(entity[&#34;first_seen&#34;]):
                intrusion_set[
                    CustomProperties.FIRST_SEEN
                ] = self.opencti.stix2.format_date(entity[&#34;first_seen&#34;])
            if self.opencti.not_empty(entity[&#34;last_seen&#34;]):
                intrusion_set[
                    CustomProperties.LAST_SEEN
                ] = self.opencti.stix2.format_date(entity[&#34;last_seen&#34;])
            intrusion_set[&#34;created&#34;] = self.opencti.stix2.format_date(entity[&#34;created&#34;])
            intrusion_set[&#34;modified&#34;] = self.opencti.stix2.format_date(
                entity[&#34;modified&#34;]
            )
            intrusion_set[CustomProperties.ID] = entity[&#34;id&#34;]
            return self.opencti.stix2.prepare_export(
                entity, intrusion_set, mode, max_marking_definition_entity
            )
        else:
            self.opencti.log(
                &#34;error&#34;, &#34;[opencti_intrusion_set] Missing parameters: id or entity&#34;
            )</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pycti.IntrusionSet.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create(self, **kwargs):
    name = kwargs.get(&#34;name&#34;, None)
    description = kwargs.get(&#34;description&#34;, None)
    alias = kwargs.get(&#34;alias&#34;, None)
    first_seen = kwargs.get(&#34;first_seen&#34;, None)
    last_seen = kwargs.get(&#34;last_seen&#34;, None)
    goal = kwargs.get(&#34;goal&#34;, None)
    sophistication = kwargs.get(&#34;sophistication&#34;, None)
    resource_level = kwargs.get(&#34;resource_level&#34;, None)
    primary_motivation = kwargs.get(&#34;primary_motivation&#34;, None)
    secondary_motivation = kwargs.get(&#34;secondary_motivation&#34;, None)
    id = kwargs.get(&#34;id&#34;, None)
    stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
    created = kwargs.get(&#34;created&#34;, None)
    modified = kwargs.get(&#34;modified&#34;, None)
    created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
    marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)
    update = kwargs.get(&#34;update&#34;, False)
    custom_attributes = &#34;&#34;&#34;
        id
        entity_type
        name
        description 
        alias
        ... on IntrusionSet {
            first_seen
            last_seen
            goal
            sophistication
            resource_level
            primary_motivation
            secondary_motivation
        }
    &#34;&#34;&#34;
    object_result = self.opencti.stix_domain_entity.get_by_stix_id_or_name(
        types=[&#34;Intrusion-Set&#34;],
        stix_id_key=stix_id_key,
        name=name,
        customAttributes=custom_attributes,
    )
    if object_result is not None:
        if update:
            # name
            if object_result[&#34;name&#34;] != name:
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;name&#34;, value=name
                )
                object_result[&#34;name&#34;] = name
            # description
            if object_result[&#34;description&#34;] != description:
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;description&#34;, value=description
                )
                object_result[&#34;description&#34;] = description
            # alias
            if alias is not None and object_result[&#34;alias&#34;] != alias:
                if &#34;alias&#34; in object_result:
                    new_aliases = object_result[&#34;alias&#34;] + list(
                        set(alias) - set(object_result[&#34;alias&#34;])
                    )
                else:
                    new_aliases = alias
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;alias&#34;, value=new_aliases
                )
                object_result[&#34;alias&#34;] = new_aliases
            # first_seen
            if first_seen is not None and object_result[&#34;first_seen&#34;] != first_seen:
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;first_seen&#34;, value=first_seen
                )
                object_result[&#34;first_seen&#34;] = first_seen
            # last_seen
            if last_seen is not None and object_result[&#34;last_seen&#34;] != last_seen:
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;last_seen&#34;, value=last_seen
                )
                object_result[&#34;last_seen&#34;] = last_seen
            # goal
            if goal is not None and object_result[&#34;goal&#34;] != goal:
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;goal&#34;, value=goal
                )
                object_result[&#34;goal&#34;] = goal
            # sophistication
            if (
                sophistication is not None
                and object_result[&#34;sophistication&#34;] != sophistication
            ):
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;],
                    key=&#34;sophistication&#34;,
                    value=sophistication,
                )
                object_result[&#34;sophistication&#34;] = sophistication
            # resource_level
            if (
                resource_level is not None
                and object_result[&#34;resource_level&#34;] != resource_level
            ):
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;],
                    key=&#34;resource_level&#34;,
                    value=resource_level,
                )
                object_result[&#34;resource_level&#34;] = resource_level
            # primary_motivation
            if (
                primary_motivation is not None
                and object_result[&#34;primary_motivation&#34;] != primary_motivation
            ):
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;],
                    key=&#34;primary_motivation&#34;,
                    value=primary_motivation,
                )
                object_result[&#34;primary_motivation&#34;] = primary_motivation
            # secondary_motivation
            if (
                secondary_motivation is not None
                and object_result[&#34;secondary_motivation&#34;] != secondary_motivation
            ):
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;],
                    key=&#34;secondary_motivation&#34;,
                    value=secondary_motivation,
                )
                object_result[&#34;secondary_motivation&#34;] = secondary_motivation
        return object_result
    else:
        return self.create_raw(
            name=name,
            description=description,
            alias=alias,
            first_seen=first_seen,
            last_seen=last_seen,
            goal=goal,
            sophistication=sophistication,
            resource_level=resource_level,
            primary_motivation=primary_motivation,
            secondary_motivation=secondary_motivation,
            id=id,
            stix_id_key=stix_id_key,
            created=created,
            modified=modified,
            createdByRef=created_by_ref,
            markingDefinitions=marking_definitions,
        )</code></pre>
</details>
</dd>
<dt id="pycti.IntrusionSet.create_raw"><code class="name flex">
<span>def <span class="ident">create_raw</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_raw(self, **kwargs):
    name = kwargs.get(&#34;name&#34;, None)
    description = kwargs.get(&#34;description&#34;, None)
    alias = kwargs.get(&#34;alias&#34;, None)
    first_seen = kwargs.get(&#34;first_seen&#34;, None)
    last_seen = kwargs.get(&#34;last_seen&#34;, None)
    goal = kwargs.get(&#34;goal&#34;, None)
    sophistication = kwargs.get(&#34;sophistication&#34;, None)
    resource_level = kwargs.get(&#34;resource_level&#34;, None)
    primary_motivation = kwargs.get(&#34;primary_motivation&#34;, None)
    secondary_motivation = kwargs.get(&#34;secondary_motivation&#34;, None)
    id = kwargs.get(&#34;id&#34;, None)
    stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
    created = kwargs.get(&#34;created&#34;, None)
    modified = kwargs.get(&#34;modified&#34;, None)
    created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
    marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)

    if name is not None and description is not None:
        self.opencti.log(&#34;info&#34;, &#34;Creating Intrusion-Set {&#34; + name + &#34;}.&#34;)
        query = (
            &#34;&#34;&#34;
            mutation IntrusionSetAdd($input: IntrusionSetAddInput) {
                intrusionSetAdd(input: $input) {
                    &#34;&#34;&#34;
            + self.properties
            + &#34;&#34;&#34;
                }
            }
        &#34;&#34;&#34;
        )
        result = self.opencti.query(
            query,
            {
                &#34;input&#34;: {
                    &#34;name&#34;: name,
                    &#34;description&#34;: description,
                    &#34;alias&#34;: alias,
                    &#34;first_seen&#34;: first_seen,
                    &#34;last_seen&#34;: last_seen,
                    &#34;goal&#34;: goal,
                    &#34;sophistication&#34;: sophistication,
                    &#34;resource_level&#34;: resource_level,
                    &#34;primary_motivation&#34;: primary_motivation,
                    &#34;secondary_motivation&#34;: secondary_motivation,
                    &#34;internal_id_key&#34;: id,
                    &#34;stix_id_key&#34;: stix_id_key,
                    &#34;created&#34;: created,
                    &#34;modified&#34;: modified,
                    &#34;createdByRef&#34;: created_by_ref,
                    &#34;markingDefinitions&#34;: marking_definitions,
                }
            },
        )
        return self.opencti.process_multiple_fields(
            result[&#34;data&#34;][&#34;intrusionSetAdd&#34;]
        )
    else:
        self.opencti.log(
            &#34;error&#34;,
            &#34;[opencti_intrusion_set] Missing parameters: name and description&#34;,
        )</code></pre>
</details>
</dd>
<dt id="pycti.IntrusionSet.list"><code class="name flex">
<span>def <span class="ident">list</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list(self, **kwargs):
    filters = kwargs.get(&#34;filters&#34;, None)
    search = kwargs.get(&#34;search&#34;, None)
    first = kwargs.get(&#34;first&#34;, 500)
    after = kwargs.get(&#34;after&#34;, None)
    order_by = kwargs.get(&#34;orderBy&#34;, None)
    order_mode = kwargs.get(&#34;orderMode&#34;, None)
    get_all = kwargs.get(&#34;getAll&#34;, False)
    if get_all:
        first = 500

    self.opencti.log(
        &#34;info&#34;, &#34;Listing Intrusion-Sets with filters &#34; + json.dumps(filters) + &#34;.&#34;
    )
    query = (
        &#34;&#34;&#34;
        query IntrusionSets($filters: [IntrusionSetsFiltering], $search: String, $first: Int, $after: ID, $orderBy: IntrusionSetsOrdering, $orderMode: OrderingMode) {
            intrusionSets(filters: $filters, search: $search, first: $first, after: $after, orderBy: $orderBy, orderMode: $orderMode) {
                edges {
                    node {
                        &#34;&#34;&#34;
        + self.properties
        + &#34;&#34;&#34;
                    }
                }
                pageInfo {
                    startCursor
                    endCursor
                    hasNextPage
                    hasPreviousPage
                    globalCount
                }
            }
        }
    &#34;&#34;&#34;
    )
    result = self.opencti.query(
        query,
        {
            &#34;filters&#34;: filters,
            &#34;search&#34;: search,
            &#34;first&#34;: first,
            &#34;after&#34;: after,
            &#34;orderBy&#34;: order_by,
            &#34;orderMode&#34;: order_mode,
        },
    )
    return self.opencti.process_multiple(result[&#34;data&#34;][&#34;intrusionSets&#34;])</code></pre>
</details>
</dd>
<dt id="pycti.IntrusionSet.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    filters = kwargs.get(&#34;filters&#34;, None)
    custom_attributes = kwargs.get(&#34;customAttributes&#34;, None)
    if id is not None:
        self.opencti.log(&#34;info&#34;, &#34;Reading Intrusion-Set {&#34; + id + &#34;}.&#34;)
        query = (
            &#34;&#34;&#34;
            query IntrusionSet($id: String!) {
                intrusionSet(id: $id) {
                    &#34;&#34;&#34;
            + (
                custom_attributes
                if custom_attributes is not None
                else self.properties
            )
            + &#34;&#34;&#34;
                }
            }
         &#34;&#34;&#34;
        )
        result = self.opencti.query(query, {&#34;id&#34;: id})
        return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;intrusionSet&#34;])
    elif filters is not None:
        result = self.list(filters=filters)
        if len(result) &gt; 0:
            return result[0]
        else:
            return None
    else:
        self.opencti.log(
            &#34;error&#34;, &#34;[opencti_intrusion_set] Missing parameters: id or filters&#34;
        )
        return None</code></pre>
</details>
</dd>
<dt id="pycti.IntrusionSet.to_stix2"><code class="name flex">
<span>def <span class="ident">to_stix2</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_stix2(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    mode = kwargs.get(&#34;mode&#34;, &#34;simple&#34;)
    max_marking_definition_entity = kwargs.get(
        &#34;max_marking_definition_entity&#34;, None
    )
    entity = kwargs.get(&#34;entity&#34;, None)
    if id is not None and entity is None:
        entity = self.read(id=id)
    if entity is not None:
        intrusion_set = dict()
        intrusion_set[&#34;id&#34;] = entity[&#34;stix_id_key&#34;]
        intrusion_set[&#34;type&#34;] = &#34;intrusion-set&#34;
        intrusion_set[&#34;spec_version&#34;] = SPEC_VERSION
        intrusion_set[&#34;name&#34;] = entity[&#34;name&#34;]
        if self.opencti.not_empty(entity[&#34;stix_label&#34;]):
            intrusion_set[&#34;labels&#34;] = entity[&#34;stix_label&#34;]
        else:
            intrusion_set[&#34;labels&#34;] = [&#34;intrusion-set&#34;]
        if self.opencti.not_empty(entity[&#34;alias&#34;]):
            intrusion_set[&#34;aliases&#34;] = entity[&#34;alias&#34;]
        if self.opencti.not_empty(entity[&#34;description&#34;]):
            intrusion_set[&#34;description&#34;] = entity[&#34;description&#34;]
        if self.opencti.not_empty(entity[&#34;goal&#34;]):
            intrusion_set[&#34;goals&#34;] = entity[&#34;goal&#34;]
        if self.opencti.not_empty(entity[&#34;sophistication&#34;]):
            intrusion_set[&#34;sophistication&#34;] = entity[&#34;sophistication&#34;]
        if self.opencti.not_empty(entity[&#34;resource_level&#34;]):
            intrusion_set[&#34;resource_level&#34;] = entity[&#34;resource_level&#34;]
        if self.opencti.not_empty(entity[&#34;primary_motivation&#34;]):
            intrusion_set[&#34;primary_motivation&#34;] = entity[&#34;primary_motivation&#34;]
        if self.opencti.not_empty(entity[&#34;secondary_motivation&#34;]):
            intrusion_set[&#34;secondary_motivations&#34;] = entity[&#34;secondary_motivation&#34;]
        if self.opencti.not_empty(entity[&#34;first_seen&#34;]):
            intrusion_set[
                CustomProperties.FIRST_SEEN
            ] = self.opencti.stix2.format_date(entity[&#34;first_seen&#34;])
        if self.opencti.not_empty(entity[&#34;last_seen&#34;]):
            intrusion_set[
                CustomProperties.LAST_SEEN
            ] = self.opencti.stix2.format_date(entity[&#34;last_seen&#34;])
        intrusion_set[&#34;created&#34;] = self.opencti.stix2.format_date(entity[&#34;created&#34;])
        intrusion_set[&#34;modified&#34;] = self.opencti.stix2.format_date(
            entity[&#34;modified&#34;]
        )
        intrusion_set[CustomProperties.ID] = entity[&#34;id&#34;]
        return self.opencti.stix2.prepare_export(
            entity, intrusion_set, mode, max_marking_definition_entity
        )
    else:
        self.opencti.log(
            &#34;error&#34;, &#34;[opencti_intrusion_set] Missing parameters: id or entity&#34;
        )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pycti.KillChainPhase"><code class="flex name class">
<span>class <span class="ident">KillChainPhase</span></span>
<span>(</span><span>opencti)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class KillChainPhase:
    def __init__(self, opencti):
        self.opencti = opencti
        self.properties = &#34;&#34;&#34;
            id
            entity_type
            stix_id_key
            kill_chain_name
            phase_name
            phase_order
            created
            modified
            created_at
            updated_at
        &#34;&#34;&#34;

    &#34;&#34;&#34;
        List Kill-Chain-Phase objects

        :param filters: the filters to apply
        :param first: return the first n rows from the after ID (or the beginning if not set)
        :param after: ID of the first row for pagination
        :return List of Kill-Chain-Phase objects
    &#34;&#34;&#34;

    def list(self, **kwargs):
        filters = kwargs.get(&#34;filters&#34;, None)
        first = kwargs.get(&#34;first&#34;, 500)
        after = kwargs.get(&#34;after&#34;, None)
        order_by = kwargs.get(&#34;orderBy&#34;, None)
        order_mode = kwargs.get(&#34;orderMode&#34;, None)
        get_all = kwargs.get(&#34;getAll&#34;, False)
        if get_all:
            first = 500

        self.opencti.log(
            &#34;info&#34;, &#34;Listing Kill-Chain-Phase with filters &#34; + json.dumps(filters) + &#34;.&#34;
        )
        query = (
            &#34;&#34;&#34;
            query KillChainPhases($filters: [KillChainPhasesFiltering], $first: Int, $after: ID, $orderBy: KillChainPhasesOrdering, $orderMode: OrderingMode) {
                killChainPhases(filters: $filters, first: $first, after: $after, orderBy: $orderBy, orderMode: $orderMode) {
                    edges {
                        node {
                            &#34;&#34;&#34;
            + self.properties
            + &#34;&#34;&#34;
                        }
                    }
                    pageInfo {
                        startCursor
                        endCursor
                        hasNextPage
                        hasPreviousPage
                        globalCount
                    }
                }
            }
        &#34;&#34;&#34;
        )
        result = self.opencti.query(
            query,
            {
                &#34;filters&#34;: filters,
                &#34;first&#34;: first,
                &#34;after&#34;: after,
                &#34;orderBy&#34;: order_by,
                &#34;orderMode&#34;: order_mode,
            },
        )
        return self.opencti.process_multiple(result[&#34;data&#34;][&#34;killChainPhases&#34;])

    &#34;&#34;&#34;
        Read a Kill-Chain-Phase object

        :param id: the id of the Kill-Chain-Phase
        :param filters: the filters to apply if no id provided
        :return Kill-Chain-Phase object
    &#34;&#34;&#34;

    def read(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        filters = kwargs.get(&#34;filters&#34;, None)
        if id is not None:
            self.opencti.log(&#34;info&#34;, &#34;Reading Kill-Chain-Phase {&#34; + id + &#34;}.&#34;)
            query = (
                &#34;&#34;&#34;
                query KillChainPhase($id: String!) {
                    killChainPhase(id: $id) {
                        &#34;&#34;&#34;
                + self.properties
                + &#34;&#34;&#34;
                    }
                }
            &#34;&#34;&#34;
            )
            result = self.opencti.query(query, {&#34;id&#34;: id})
            return self.opencti.process_multiple_fields(
                result[&#34;data&#34;][&#34;killChainPhase&#34;]
            )
        elif filters is not None:
            result = self.list(filters=filters)
            if len(result) &gt; 0:
                return result[0]
            else:
                return None
        else:
            self.opencti.log(
                &#34;error&#34;, &#34;[opencti_kill_chain_phase] Missing parameters: id or filters&#34;
            )
            return None

    &#34;&#34;&#34;
        Create a Kill-Chain-Phase object

        :param name: the name of the Kill-Chain-Phase
        :return Kill-Chain-Phase object
    &#34;&#34;&#34;

    def create_raw(self, **kwargs):
        kill_chain_name = kwargs.get(&#34;kill_chain_name&#34;, None)
        phase_name = kwargs.get(&#34;phase_name&#34;, None)
        phase_order = kwargs.get(&#34;phase_order&#34;, 0)
        id = kwargs.get(&#34;id&#34;, None)
        stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
        created = kwargs.get(&#34;created&#34;, None)
        modified = kwargs.get(&#34;modified&#34;, None)

        if kill_chain_name is not None and phase_name is not None:
            self.opencti.log(&#34;info&#34;, &#34;Creating Kill-Chain-Phase {&#34; + phase_name + &#34;}.&#34;)
            query = (
                &#34;&#34;&#34;
                mutation KillChainPhaseAdd($input: KillChainPhaseAddInput) {
                    killChainPhaseAdd(input: $input) {
                        &#34;&#34;&#34;
                + self.properties
                + &#34;&#34;&#34;
                    }
                }
            &#34;&#34;&#34;
            )
            result = self.opencti.query(
                query,
                {
                    &#34;input&#34;: {
                        &#34;kill_chain_name&#34;: kill_chain_name,
                        &#34;phase_name&#34;: phase_name,
                        &#34;phase_order&#34;: phase_order,
                        &#34;internal_id_key&#34;: id,
                        &#34;stix_id_key&#34;: stix_id_key,
                        &#34;created&#34;: created,
                        &#34;modified&#34;: modified,
                    }
                },
            )
            return self.opencti.process_multiple_fields(
                result[&#34;data&#34;][&#34;killChainPhaseAdd&#34;]
            )
        else:
            self.opencti.log(
                &#34;error&#34;,
                &#34;[opencti_kill_chain_phase] Missing parameters: kill_chain_name and phase_name&#34;,
            )

    &#34;&#34;&#34;
        Create a Kill-Chain-Phase object only if it not exists, update it on request

        :param name: the name of the Kill-Chain-Phase
        :return Kill-Chain-Phase object
    &#34;&#34;&#34;

    def create(self, **kwargs):
        kill_chain_name = kwargs.get(&#34;kill_chain_name&#34;, None)
        phase_name = kwargs.get(&#34;phase_name&#34;, None)
        phase_order = kwargs.get(&#34;phase_order&#34;, 0)
        id = kwargs.get(&#34;id&#34;, None)
        stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
        created = kwargs.get(&#34;created&#34;, None)
        modified = kwargs.get(&#34;modified&#34;, None)

        kill_chain_phase_result = self.read(
            filters=[{&#34;key&#34;: &#34;phase_name&#34;, &#34;values&#34;: [phase_name]}]
        )
        if kill_chain_phase_result is not None:
            return kill_chain_phase_result
        else:
            return self.create_raw(
                kill_chain_name=kill_chain_name,
                phase_name=phase_name,
                phase_order=phase_order,
                id=id,
                stix_id_key=stix_id_key,
                created=created,
                modified=modified,
            )</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pycti.KillChainPhase.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create(self, **kwargs):
    kill_chain_name = kwargs.get(&#34;kill_chain_name&#34;, None)
    phase_name = kwargs.get(&#34;phase_name&#34;, None)
    phase_order = kwargs.get(&#34;phase_order&#34;, 0)
    id = kwargs.get(&#34;id&#34;, None)
    stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
    created = kwargs.get(&#34;created&#34;, None)
    modified = kwargs.get(&#34;modified&#34;, None)

    kill_chain_phase_result = self.read(
        filters=[{&#34;key&#34;: &#34;phase_name&#34;, &#34;values&#34;: [phase_name]}]
    )
    if kill_chain_phase_result is not None:
        return kill_chain_phase_result
    else:
        return self.create_raw(
            kill_chain_name=kill_chain_name,
            phase_name=phase_name,
            phase_order=phase_order,
            id=id,
            stix_id_key=stix_id_key,
            created=created,
            modified=modified,
        )</code></pre>
</details>
</dd>
<dt id="pycti.KillChainPhase.create_raw"><code class="name flex">
<span>def <span class="ident">create_raw</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_raw(self, **kwargs):
    kill_chain_name = kwargs.get(&#34;kill_chain_name&#34;, None)
    phase_name = kwargs.get(&#34;phase_name&#34;, None)
    phase_order = kwargs.get(&#34;phase_order&#34;, 0)
    id = kwargs.get(&#34;id&#34;, None)
    stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
    created = kwargs.get(&#34;created&#34;, None)
    modified = kwargs.get(&#34;modified&#34;, None)

    if kill_chain_name is not None and phase_name is not None:
        self.opencti.log(&#34;info&#34;, &#34;Creating Kill-Chain-Phase {&#34; + phase_name + &#34;}.&#34;)
        query = (
            &#34;&#34;&#34;
            mutation KillChainPhaseAdd($input: KillChainPhaseAddInput) {
                killChainPhaseAdd(input: $input) {
                    &#34;&#34;&#34;
            + self.properties
            + &#34;&#34;&#34;
                }
            }
        &#34;&#34;&#34;
        )
        result = self.opencti.query(
            query,
            {
                &#34;input&#34;: {
                    &#34;kill_chain_name&#34;: kill_chain_name,
                    &#34;phase_name&#34;: phase_name,
                    &#34;phase_order&#34;: phase_order,
                    &#34;internal_id_key&#34;: id,
                    &#34;stix_id_key&#34;: stix_id_key,
                    &#34;created&#34;: created,
                    &#34;modified&#34;: modified,
                }
            },
        )
        return self.opencti.process_multiple_fields(
            result[&#34;data&#34;][&#34;killChainPhaseAdd&#34;]
        )
    else:
        self.opencti.log(
            &#34;error&#34;,
            &#34;[opencti_kill_chain_phase] Missing parameters: kill_chain_name and phase_name&#34;,
        )</code></pre>
</details>
</dd>
<dt id="pycti.KillChainPhase.list"><code class="name flex">
<span>def <span class="ident">list</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list(self, **kwargs):
    filters = kwargs.get(&#34;filters&#34;, None)
    first = kwargs.get(&#34;first&#34;, 500)
    after = kwargs.get(&#34;after&#34;, None)
    order_by = kwargs.get(&#34;orderBy&#34;, None)
    order_mode = kwargs.get(&#34;orderMode&#34;, None)
    get_all = kwargs.get(&#34;getAll&#34;, False)
    if get_all:
        first = 500

    self.opencti.log(
        &#34;info&#34;, &#34;Listing Kill-Chain-Phase with filters &#34; + json.dumps(filters) + &#34;.&#34;
    )
    query = (
        &#34;&#34;&#34;
        query KillChainPhases($filters: [KillChainPhasesFiltering], $first: Int, $after: ID, $orderBy: KillChainPhasesOrdering, $orderMode: OrderingMode) {
            killChainPhases(filters: $filters, first: $first, after: $after, orderBy: $orderBy, orderMode: $orderMode) {
                edges {
                    node {
                        &#34;&#34;&#34;
        + self.properties
        + &#34;&#34;&#34;
                    }
                }
                pageInfo {
                    startCursor
                    endCursor
                    hasNextPage
                    hasPreviousPage
                    globalCount
                }
            }
        }
    &#34;&#34;&#34;
    )
    result = self.opencti.query(
        query,
        {
            &#34;filters&#34;: filters,
            &#34;first&#34;: first,
            &#34;after&#34;: after,
            &#34;orderBy&#34;: order_by,
            &#34;orderMode&#34;: order_mode,
        },
    )
    return self.opencti.process_multiple(result[&#34;data&#34;][&#34;killChainPhases&#34;])</code></pre>
</details>
</dd>
<dt id="pycti.KillChainPhase.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    filters = kwargs.get(&#34;filters&#34;, None)
    if id is not None:
        self.opencti.log(&#34;info&#34;, &#34;Reading Kill-Chain-Phase {&#34; + id + &#34;}.&#34;)
        query = (
            &#34;&#34;&#34;
            query KillChainPhase($id: String!) {
                killChainPhase(id: $id) {
                    &#34;&#34;&#34;
            + self.properties
            + &#34;&#34;&#34;
                }
            }
        &#34;&#34;&#34;
        )
        result = self.opencti.query(query, {&#34;id&#34;: id})
        return self.opencti.process_multiple_fields(
            result[&#34;data&#34;][&#34;killChainPhase&#34;]
        )
    elif filters is not None:
        result = self.list(filters=filters)
        if len(result) &gt; 0:
            return result[0]
        else:
            return None
    else:
        self.opencti.log(
            &#34;error&#34;, &#34;[opencti_kill_chain_phase] Missing parameters: id or filters&#34;
        )
        return None</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pycti.Malware"><code class="flex name class">
<span>class <span class="ident">Malware</span></span>
<span>(</span><span>opencti)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Malware:
    def __init__(self, opencti):
        self.opencti = opencti
        self.properties = &#34;&#34;&#34;
            id
            stix_id_key
            stix_label
            entity_type
            parent_types
            name
            alias
            description
            graph_data
            created
            modified            
            created_at
            updated_at
            killChainPhases {
                edges {
                    node {
                        id
                        entity_type
                        stix_id_key
                        kill_chain_name
                        phase_name
                        phase_order
                        created
                        modified
                    }
                    relation {
                        id
                    }
                }
            }
            createdByRef {
                node {
                    id
                    entity_type
                    stix_id_key
                    stix_label
                    name
                    alias
                    description
                    created
                    modified
                    ... on Organization {
                        organization_class
                    }
                }
                relation {
                    id
                }
            }            
            markingDefinitions {
                edges {
                    node {
                        id
                        entity_type
                        stix_id_key
                        definition_type
                        definition
                        level
                        color
                        created
                        modified
                    }
                    relation {
                        id
                    }
                }
            }
            tags {
                edges {
                    node {
                        id
                        tag_type
                        value
                        color
                    }
                    relation {
                        id
                    }
                }
            }
            externalReferences {
                edges {
                    node {
                        id
                        entity_type
                        stix_id_key
                        source_name
                        description
                        url
                        hash
                        external_id
                        created
                        modified
                    }
                    relation {
                        id
                    }
                }
            }         
        &#34;&#34;&#34;

    &#34;&#34;&#34;
        List Malware objects

        :param filters: the filters to apply
        :param search: the search keyword
        :param first: return the first n rows from the after ID (or the beginning if not set)
        :param after: ID of the first row for pagination
        :return List of Malware objects
    &#34;&#34;&#34;

    def list(self, **kwargs):
        filters = kwargs.get(&#34;filters&#34;, None)
        search = kwargs.get(&#34;search&#34;, None)
        first = kwargs.get(&#34;first&#34;, 500)
        after = kwargs.get(&#34;after&#34;, None)
        order_by = kwargs.get(&#34;orderBy&#34;, None)
        order_mode = kwargs.get(&#34;orderMode&#34;, None)
        get_all = kwargs.get(&#34;getAll&#34;, False)
        if get_all:
            first = 500

        self.opencti.log(
            &#34;info&#34;, &#34;Listing Malwares with filters &#34; + json.dumps(filters) + &#34;.&#34;
        )
        query = (
            &#34;&#34;&#34;
            query Malwares($filters: [MalwaresFiltering], $search: String, $first: Int, $after: ID, $orderBy: MalwaresOrdering, $orderMode: OrderingMode) {
                malwares(filters: $filters, search: $search, first: $first, after: $after, orderBy: $orderBy, orderMode: $orderMode) {
                    edges {
                        node {
                            &#34;&#34;&#34;
            + self.properties
            + &#34;&#34;&#34;
                        }
                    }
                    pageInfo {
                        startCursor
                        endCursor
                        hasNextPage
                        hasPreviousPage
                        globalCount
                    }
                }
            }
        &#34;&#34;&#34;
        )
        result = self.opencti.query(
            query,
            {
                &#34;filters&#34;: filters,
                &#34;search&#34;: search,
                &#34;first&#34;: first,
                &#34;after&#34;: after,
                &#34;orderBy&#34;: order_by,
                &#34;orderMode&#34;: order_mode,
            },
        )
        return self.opencti.process_multiple(result[&#34;data&#34;][&#34;malwares&#34;])

    &#34;&#34;&#34;
        Read a Malware object
        
        :param id: the id of the Malware
        :param filters: the filters to apply if no id provided
        :return Malware object
    &#34;&#34;&#34;

    def read(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        filters = kwargs.get(&#34;filters&#34;, None)
        custom_attributes = kwargs.get(&#34;customAttributes&#34;, None)
        if id is not None:
            self.opencti.log(&#34;info&#34;, &#34;Reading Malware {&#34; + id + &#34;}.&#34;)
            query = (
                &#34;&#34;&#34;
                query Malware($id: String!) {
                    malware(id: $id) {
                        &#34;&#34;&#34;
                + (
                    custom_attributes
                    if custom_attributes is not None
                    else self.properties
                )
                + &#34;&#34;&#34;
                    }
                }
             &#34;&#34;&#34;
            )
            result = self.opencti.query(query, {&#34;id&#34;: id})
            return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;malware&#34;])
        elif filters is not None:
            result = self.list(filters=filters)
            if len(result) &gt; 0:
                return result[0]
            else:
                return None
        else:
            self.opencti.log(
                &#34;error&#34;, &#34;[opencti_malware] Missing parameters: id or filters&#34;
            )
            return None

    &#34;&#34;&#34;
        Create a Malware object

        :param name: the name of the Malware
        :return Malware object
    &#34;&#34;&#34;

    def create_raw(self, **kwargs):
        name = kwargs.get(&#34;name&#34;, None)
        description = kwargs.get(&#34;description&#34;, None)
        alias = kwargs.get(&#34;alias&#34;, None)
        id = kwargs.get(&#34;id&#34;, None)
        stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
        created = kwargs.get(&#34;created&#34;, None)
        modified = kwargs.get(&#34;modified&#34;, None)
        created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
        marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)

        if name is not None and description is not None:
            self.opencti.log(&#34;info&#34;, &#34;Creating Malware {&#34; + name + &#34;}.&#34;)
            query = (
                &#34;&#34;&#34;
                mutation MalwareAdd($input: MalwareAddInput) {
                    malwareAdd(input: $input) {
                        &#34;&#34;&#34;
                + self.properties
                + &#34;&#34;&#34;
                    }
                }
            &#34;&#34;&#34;
            )
            result = self.opencti.query(
                query,
                {
                    &#34;input&#34;: {
                        &#34;name&#34;: name,
                        &#34;description&#34;: description,
                        &#34;alias&#34;: alias,
                        &#34;internal_id_key&#34;: id,
                        &#34;stix_id_key&#34;: stix_id_key,
                        &#34;created&#34;: created,
                        &#34;modified&#34;: modified,
                        &#34;createdByRef&#34;: created_by_ref,
                        &#34;markingDefinitions&#34;: marking_definitions,
                    }
                },
            )
            return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;malwareAdd&#34;])
        else:
            self.opencti.log(
                &#34;error&#34;, &#34;[opencti_malware] Missing parameters: name and description&#34;
            )

    &#34;&#34;&#34;
        Create a Malware object only if it not exists, update it on request

        :param name: the name of the Malware
        :return Malware object
    &#34;&#34;&#34;

    def create(self, **kwargs):
        name = kwargs.get(&#34;name&#34;, None)
        description = kwargs.get(&#34;description&#34;, None)
        alias = kwargs.get(&#34;alias&#34;, None)
        id = kwargs.get(&#34;id&#34;, None)
        stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
        created = kwargs.get(&#34;created&#34;, None)
        modified = kwargs.get(&#34;modified&#34;, None)
        created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
        marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)
        update = kwargs.get(&#34;update&#34;, False)
        custom_attributes = &#34;&#34;&#34;
            id
            entity_type
            name
            description 
            alias
        &#34;&#34;&#34;
        object_result = self.opencti.stix_domain_entity.get_by_stix_id_or_name(
            types=[&#34;Malware&#34;],
            stix_id_key=stix_id_key,
            name=name,
            customAttributes=custom_attributes,
        )
        if object_result is not None:
            if update:
                # name
                if object_result[&#34;name&#34;] != name:
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;name&#34;, value=name
                    )
                    object_result[&#34;name&#34;] = name
                # description
                if object_result[&#34;description&#34;] != description:
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;description&#34;, value=description
                    )
                    object_result[&#34;description&#34;] = description
                # alias
                if alias is not None and object_result[&#34;alias&#34;] != alias:
                    if &#34;alias&#34; in object_result:
                        new_aliases = object_result[&#34;alias&#34;] + list(
                            set(alias) - set(object_result[&#34;alias&#34;])
                        )
                    else:
                        new_aliases = alias
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;alias&#34;, value=new_aliases
                    )
                    object_result[&#34;alias&#34;] = new_aliases
            return object_result
        else:
            return self.create_raw(
                name=name,
                description=description,
                alias=alias,
                id=id,
                stix_id_key=stix_id_key,
                created=created,
                modified=modified,
                createdByRef=created_by_ref,
                markingDefinitions=marking_definitions,
            )

    &#34;&#34;&#34;
        Export an Malware object in STIX2
    
        :param id: the id of the Malware
        :return Malware object
    &#34;&#34;&#34;

    def to_stix2(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        mode = kwargs.get(&#34;mode&#34;, &#34;simple&#34;)
        max_marking_definition_entity = kwargs.get(
            &#34;max_marking_definition_entity&#34;, None
        )
        entity = kwargs.get(&#34;entity&#34;, None)
        if id is not None and entity is None:
            entity = self.read(id=id)
        if entity is not None:
            malware = dict()
            malware[&#34;id&#34;] = entity[&#34;stix_id_key&#34;]
            malware[&#34;type&#34;] = &#34;malware&#34;
            malware[&#34;spec_version&#34;] = SPEC_VERSION
            malware[&#34;name&#34;] = entity[&#34;name&#34;]
            if self.opencti.not_empty(entity[&#34;stix_label&#34;]):
                malware[&#34;labels&#34;] = entity[&#34;stix_label&#34;]
            else:
                malware[&#34;labels&#34;] = [&#34;malware&#34;]
            if self.opencti.not_empty(entity[&#34;description&#34;]):
                malware[&#34;description&#34;] = entity[&#34;description&#34;]
            malware[&#34;created&#34;] = self.opencti.stix2.format_date(entity[&#34;created&#34;])
            malware[&#34;modified&#34;] = self.opencti.stix2.format_date(entity[&#34;modified&#34;])
            if self.opencti.not_empty(entity[&#34;alias&#34;]):
                malware[CustomProperties.ALIASES] = entity[&#34;alias&#34;]
            malware[CustomProperties.ID] = entity[&#34;id&#34;]
            return self.opencti.stix2.prepare_export(
                entity, malware, mode, max_marking_definition_entity
            )
        else:
            self.opencti.log(&#34;error&#34;, &#34;Missing parameters: id or entity&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pycti.Malware.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create(self, **kwargs):
    name = kwargs.get(&#34;name&#34;, None)
    description = kwargs.get(&#34;description&#34;, None)
    alias = kwargs.get(&#34;alias&#34;, None)
    id = kwargs.get(&#34;id&#34;, None)
    stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
    created = kwargs.get(&#34;created&#34;, None)
    modified = kwargs.get(&#34;modified&#34;, None)
    created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
    marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)
    update = kwargs.get(&#34;update&#34;, False)
    custom_attributes = &#34;&#34;&#34;
        id
        entity_type
        name
        description 
        alias
    &#34;&#34;&#34;
    object_result = self.opencti.stix_domain_entity.get_by_stix_id_or_name(
        types=[&#34;Malware&#34;],
        stix_id_key=stix_id_key,
        name=name,
        customAttributes=custom_attributes,
    )
    if object_result is not None:
        if update:
            # name
            if object_result[&#34;name&#34;] != name:
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;name&#34;, value=name
                )
                object_result[&#34;name&#34;] = name
            # description
            if object_result[&#34;description&#34;] != description:
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;description&#34;, value=description
                )
                object_result[&#34;description&#34;] = description
            # alias
            if alias is not None and object_result[&#34;alias&#34;] != alias:
                if &#34;alias&#34; in object_result:
                    new_aliases = object_result[&#34;alias&#34;] + list(
                        set(alias) - set(object_result[&#34;alias&#34;])
                    )
                else:
                    new_aliases = alias
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;alias&#34;, value=new_aliases
                )
                object_result[&#34;alias&#34;] = new_aliases
        return object_result
    else:
        return self.create_raw(
            name=name,
            description=description,
            alias=alias,
            id=id,
            stix_id_key=stix_id_key,
            created=created,
            modified=modified,
            createdByRef=created_by_ref,
            markingDefinitions=marking_definitions,
        )</code></pre>
</details>
</dd>
<dt id="pycti.Malware.create_raw"><code class="name flex">
<span>def <span class="ident">create_raw</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_raw(self, **kwargs):
    name = kwargs.get(&#34;name&#34;, None)
    description = kwargs.get(&#34;description&#34;, None)
    alias = kwargs.get(&#34;alias&#34;, None)
    id = kwargs.get(&#34;id&#34;, None)
    stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
    created = kwargs.get(&#34;created&#34;, None)
    modified = kwargs.get(&#34;modified&#34;, None)
    created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
    marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)

    if name is not None and description is not None:
        self.opencti.log(&#34;info&#34;, &#34;Creating Malware {&#34; + name + &#34;}.&#34;)
        query = (
            &#34;&#34;&#34;
            mutation MalwareAdd($input: MalwareAddInput) {
                malwareAdd(input: $input) {
                    &#34;&#34;&#34;
            + self.properties
            + &#34;&#34;&#34;
                }
            }
        &#34;&#34;&#34;
        )
        result = self.opencti.query(
            query,
            {
                &#34;input&#34;: {
                    &#34;name&#34;: name,
                    &#34;description&#34;: description,
                    &#34;alias&#34;: alias,
                    &#34;internal_id_key&#34;: id,
                    &#34;stix_id_key&#34;: stix_id_key,
                    &#34;created&#34;: created,
                    &#34;modified&#34;: modified,
                    &#34;createdByRef&#34;: created_by_ref,
                    &#34;markingDefinitions&#34;: marking_definitions,
                }
            },
        )
        return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;malwareAdd&#34;])
    else:
        self.opencti.log(
            &#34;error&#34;, &#34;[opencti_malware] Missing parameters: name and description&#34;
        )</code></pre>
</details>
</dd>
<dt id="pycti.Malware.list"><code class="name flex">
<span>def <span class="ident">list</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list(self, **kwargs):
    filters = kwargs.get(&#34;filters&#34;, None)
    search = kwargs.get(&#34;search&#34;, None)
    first = kwargs.get(&#34;first&#34;, 500)
    after = kwargs.get(&#34;after&#34;, None)
    order_by = kwargs.get(&#34;orderBy&#34;, None)
    order_mode = kwargs.get(&#34;orderMode&#34;, None)
    get_all = kwargs.get(&#34;getAll&#34;, False)
    if get_all:
        first = 500

    self.opencti.log(
        &#34;info&#34;, &#34;Listing Malwares with filters &#34; + json.dumps(filters) + &#34;.&#34;
    )
    query = (
        &#34;&#34;&#34;
        query Malwares($filters: [MalwaresFiltering], $search: String, $first: Int, $after: ID, $orderBy: MalwaresOrdering, $orderMode: OrderingMode) {
            malwares(filters: $filters, search: $search, first: $first, after: $after, orderBy: $orderBy, orderMode: $orderMode) {
                edges {
                    node {
                        &#34;&#34;&#34;
        + self.properties
        + &#34;&#34;&#34;
                    }
                }
                pageInfo {
                    startCursor
                    endCursor
                    hasNextPage
                    hasPreviousPage
                    globalCount
                }
            }
        }
    &#34;&#34;&#34;
    )
    result = self.opencti.query(
        query,
        {
            &#34;filters&#34;: filters,
            &#34;search&#34;: search,
            &#34;first&#34;: first,
            &#34;after&#34;: after,
            &#34;orderBy&#34;: order_by,
            &#34;orderMode&#34;: order_mode,
        },
    )
    return self.opencti.process_multiple(result[&#34;data&#34;][&#34;malwares&#34;])</code></pre>
</details>
</dd>
<dt id="pycti.Malware.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    filters = kwargs.get(&#34;filters&#34;, None)
    custom_attributes = kwargs.get(&#34;customAttributes&#34;, None)
    if id is not None:
        self.opencti.log(&#34;info&#34;, &#34;Reading Malware {&#34; + id + &#34;}.&#34;)
        query = (
            &#34;&#34;&#34;
            query Malware($id: String!) {
                malware(id: $id) {
                    &#34;&#34;&#34;
            + (
                custom_attributes
                if custom_attributes is not None
                else self.properties
            )
            + &#34;&#34;&#34;
                }
            }
         &#34;&#34;&#34;
        )
        result = self.opencti.query(query, {&#34;id&#34;: id})
        return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;malware&#34;])
    elif filters is not None:
        result = self.list(filters=filters)
        if len(result) &gt; 0:
            return result[0]
        else:
            return None
    else:
        self.opencti.log(
            &#34;error&#34;, &#34;[opencti_malware] Missing parameters: id or filters&#34;
        )
        return None</code></pre>
</details>
</dd>
<dt id="pycti.Malware.to_stix2"><code class="name flex">
<span>def <span class="ident">to_stix2</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_stix2(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    mode = kwargs.get(&#34;mode&#34;, &#34;simple&#34;)
    max_marking_definition_entity = kwargs.get(
        &#34;max_marking_definition_entity&#34;, None
    )
    entity = kwargs.get(&#34;entity&#34;, None)
    if id is not None and entity is None:
        entity = self.read(id=id)
    if entity is not None:
        malware = dict()
        malware[&#34;id&#34;] = entity[&#34;stix_id_key&#34;]
        malware[&#34;type&#34;] = &#34;malware&#34;
        malware[&#34;spec_version&#34;] = SPEC_VERSION
        malware[&#34;name&#34;] = entity[&#34;name&#34;]
        if self.opencti.not_empty(entity[&#34;stix_label&#34;]):
            malware[&#34;labels&#34;] = entity[&#34;stix_label&#34;]
        else:
            malware[&#34;labels&#34;] = [&#34;malware&#34;]
        if self.opencti.not_empty(entity[&#34;description&#34;]):
            malware[&#34;description&#34;] = entity[&#34;description&#34;]
        malware[&#34;created&#34;] = self.opencti.stix2.format_date(entity[&#34;created&#34;])
        malware[&#34;modified&#34;] = self.opencti.stix2.format_date(entity[&#34;modified&#34;])
        if self.opencti.not_empty(entity[&#34;alias&#34;]):
            malware[CustomProperties.ALIASES] = entity[&#34;alias&#34;]
        malware[CustomProperties.ID] = entity[&#34;id&#34;]
        return self.opencti.stix2.prepare_export(
            entity, malware, mode, max_marking_definition_entity
        )
    else:
        self.opencti.log(&#34;error&#34;, &#34;Missing parameters: id or entity&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pycti.MarkingDefinition"><code class="flex name class">
<span>class <span class="ident">MarkingDefinition</span></span>
<span>(</span><span>opencti)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MarkingDefinition:
    def __init__(self, opencti):
        self.opencti = opencti
        self.properties = &#34;&#34;&#34;
            id
            stix_id_key
            entity_type
            definition_type
            definition
            level
            color
            created
            modified
            created_at
            updated_at
        &#34;&#34;&#34;

    &#34;&#34;&#34;
        List Marking-Definition objects

        :param filters: the filters to apply
        :param first: return the first n rows from the after ID (or the beginning if not set)
        :param after: ID of the first row for pagination
        :return List of Marking-Definition objects
    &#34;&#34;&#34;

    def list(self, **kwargs):
        filters = kwargs.get(&#34;filters&#34;, None)
        first = kwargs.get(&#34;first&#34;, 500)
        after = kwargs.get(&#34;after&#34;, None)
        order_by = kwargs.get(&#34;orderBy&#34;, None)
        order_mode = kwargs.get(&#34;orderMode&#34;, None)
        get_all = kwargs.get(&#34;getAll&#34;, False)
        if get_all:
            first = 500

        self.opencti.log(
            &#34;info&#34;,
            &#34;Listing Marking-Definitions with filters &#34; + json.dumps(filters) + &#34;.&#34;,
        )
        query = (
            &#34;&#34;&#34;
            query MarkingDefinitions($filters: [MarkingDefinitionsFiltering], $first: Int, $after: ID, $orderBy: MarkingDefinitionsOrdering, $orderMode: OrderingMode) {
                markingDefinitions(filters: $filters, first: $first, after: $after, orderBy: $orderBy, orderMode: $orderMode) {
                    edges {
                        node {
                            &#34;&#34;&#34;
            + self.properties
            + &#34;&#34;&#34;
                        }
                    }
                    pageInfo {
                        startCursor
                        endCursor
                        hasNextPage
                        hasPreviousPage
                        globalCount
                    }                    
                }
            }
        &#34;&#34;&#34;
        )
        result = self.opencti.query(
            query,
            {
                &#34;filters&#34;: filters,
                &#34;first&#34;: first,
                &#34;after&#34;: after,
                &#34;orderBy&#34;: order_by,
                &#34;orderMode&#34;: order_mode,
            },
        )
        return self.opencti.process_multiple(result[&#34;data&#34;][&#34;markingDefinitions&#34;])

    &#34;&#34;&#34;
        Read a Marking-Definition object

        :param id: the id of the Marking-Definition
        :param filters: the filters to apply if no id provided
        :return Marking-Definition object
    &#34;&#34;&#34;

    def read(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        filters = kwargs.get(&#34;filters&#34;, None)
        if id is not None:
            self.opencti.log(&#34;info&#34;, &#34;Reading Marking-Definition {&#34; + id + &#34;}.&#34;)
            query = (
                &#34;&#34;&#34;
                query MarkingDefinition($id: String!) {
                    markingDefinition(id: $id) {
                        &#34;&#34;&#34;
                + self.properties
                + &#34;&#34;&#34;
                    }
                }
            &#34;&#34;&#34;
            )
            result = self.opencti.query(query, {&#34;id&#34;: id})
            return self.opencti.process_multiple_fields(
                result[&#34;data&#34;][&#34;markingDefinition&#34;]
            )
        elif filters is not None:
            result = self.list(filters=filters)
            if len(result) &gt; 0:
                return result[0]
            else:
                return None
        else:
            self.opencti.log(
                &#34;error&#34;,
                &#34;[opencti_marking_definition] Missing parameters: id or filters&#34;,
            )
            return None

    &#34;&#34;&#34;
        Create a Marking-Definition object

        :param definition_type: the definition_type
        :param definition: the definition
        :return Marking-Definition object
    &#34;&#34;&#34;

    def create_raw(self, **kwargs):
        definition_type = kwargs.get(&#34;definition_type&#34;, None)
        definition = kwargs.get(&#34;definition&#34;, None)
        level = kwargs.get(&#34;level&#34;, 0)
        color = kwargs.get(&#34;color&#34;, None)
        id = kwargs.get(&#34;id&#34;, None)
        stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
        created = kwargs.get(&#34;created&#34;, None)
        modified = kwargs.get(&#34;modified&#34;, None)

        if definition is not None and definition_type is not None:
            query = (
                &#34;&#34;&#34;
                mutation MarkingDefinitionAdd($input: MarkingDefinitionAddInput) {
                    markingDefinitionAdd(input: $input) {
                        &#34;&#34;&#34;
                + self.properties
                + &#34;&#34;&#34;
                    }
                }
            &#34;&#34;&#34;
            )
            result = self.opencti.query(
                query,
                {
                    &#34;input&#34;: {
                        &#34;definition_type&#34;: definition_type,
                        &#34;definition&#34;: definition,
                        &#34;internal_id_key&#34;: id,
                        &#34;level&#34;: level,
                        &#34;color&#34;: color,
                        &#34;stix_id_key&#34;: stix_id_key,
                        &#34;created&#34;: created,
                        &#34;modified&#34;: modified,
                    }
                },
            )
            return self.opencti.process_multiple_fields(
                result[&#34;data&#34;][&#34;markingDefinitionAdd&#34;]
            )
        else:
            self.opencti.log(
                &#34;error&#34;,
                &#34;[opencti_marking_definition] Missing parameters: definition and definition_type&#34;,
            )

    &#34;&#34;&#34;
        Create a Marking-Definition object only if it not exists, update it on request

        :param definition_type: the definition_type
        :param definition: the definition
        :return Marking-Definition object
    &#34;&#34;&#34;

    def create(self, **kwargs):
        definition_type = kwargs.get(&#34;definition_type&#34;, None)
        definition = kwargs.get(&#34;definition&#34;, None)
        level = kwargs.get(&#34;level&#34;, 0)
        color = kwargs.get(&#34;color&#34;, None)
        id = kwargs.get(&#34;id&#34;, None)
        stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
        created = kwargs.get(&#34;created&#34;, None)
        modified = kwargs.get(&#34;modified&#34;, None)

        object_result = None
        if stix_id_key is not None:
            object_result = self.read(id=stix_id_key)
        if object_result is None:
            object_result = self.read(
                filters=[
                    {&#34;key&#34;: &#34;definition_type&#34;, &#34;values&#34;: [definition_type]},
                    {&#34;key&#34;: &#34;definition&#34;, &#34;values&#34;: [definition]},
                ]
            )
        if object_result is not None:
            return object_result
        else:
            return self.create_raw(
                definition_type=definition_type,
                definition=definition,
                level=level,
                color=color,
                id=id,
                stix_id_key=stix_id_key,
                created=created,
                modified=modified,
            )</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pycti.MarkingDefinition.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create(self, **kwargs):
    definition_type = kwargs.get(&#34;definition_type&#34;, None)
    definition = kwargs.get(&#34;definition&#34;, None)
    level = kwargs.get(&#34;level&#34;, 0)
    color = kwargs.get(&#34;color&#34;, None)
    id = kwargs.get(&#34;id&#34;, None)
    stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
    created = kwargs.get(&#34;created&#34;, None)
    modified = kwargs.get(&#34;modified&#34;, None)

    object_result = None
    if stix_id_key is not None:
        object_result = self.read(id=stix_id_key)
    if object_result is None:
        object_result = self.read(
            filters=[
                {&#34;key&#34;: &#34;definition_type&#34;, &#34;values&#34;: [definition_type]},
                {&#34;key&#34;: &#34;definition&#34;, &#34;values&#34;: [definition]},
            ]
        )
    if object_result is not None:
        return object_result
    else:
        return self.create_raw(
            definition_type=definition_type,
            definition=definition,
            level=level,
            color=color,
            id=id,
            stix_id_key=stix_id_key,
            created=created,
            modified=modified,
        )</code></pre>
</details>
</dd>
<dt id="pycti.MarkingDefinition.create_raw"><code class="name flex">
<span>def <span class="ident">create_raw</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_raw(self, **kwargs):
    definition_type = kwargs.get(&#34;definition_type&#34;, None)
    definition = kwargs.get(&#34;definition&#34;, None)
    level = kwargs.get(&#34;level&#34;, 0)
    color = kwargs.get(&#34;color&#34;, None)
    id = kwargs.get(&#34;id&#34;, None)
    stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
    created = kwargs.get(&#34;created&#34;, None)
    modified = kwargs.get(&#34;modified&#34;, None)

    if definition is not None and definition_type is not None:
        query = (
            &#34;&#34;&#34;
            mutation MarkingDefinitionAdd($input: MarkingDefinitionAddInput) {
                markingDefinitionAdd(input: $input) {
                    &#34;&#34;&#34;
            + self.properties
            + &#34;&#34;&#34;
                }
            }
        &#34;&#34;&#34;
        )
        result = self.opencti.query(
            query,
            {
                &#34;input&#34;: {
                    &#34;definition_type&#34;: definition_type,
                    &#34;definition&#34;: definition,
                    &#34;internal_id_key&#34;: id,
                    &#34;level&#34;: level,
                    &#34;color&#34;: color,
                    &#34;stix_id_key&#34;: stix_id_key,
                    &#34;created&#34;: created,
                    &#34;modified&#34;: modified,
                }
            },
        )
        return self.opencti.process_multiple_fields(
            result[&#34;data&#34;][&#34;markingDefinitionAdd&#34;]
        )
    else:
        self.opencti.log(
            &#34;error&#34;,
            &#34;[opencti_marking_definition] Missing parameters: definition and definition_type&#34;,
        )</code></pre>
</details>
</dd>
<dt id="pycti.MarkingDefinition.list"><code class="name flex">
<span>def <span class="ident">list</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list(self, **kwargs):
    filters = kwargs.get(&#34;filters&#34;, None)
    first = kwargs.get(&#34;first&#34;, 500)
    after = kwargs.get(&#34;after&#34;, None)
    order_by = kwargs.get(&#34;orderBy&#34;, None)
    order_mode = kwargs.get(&#34;orderMode&#34;, None)
    get_all = kwargs.get(&#34;getAll&#34;, False)
    if get_all:
        first = 500

    self.opencti.log(
        &#34;info&#34;,
        &#34;Listing Marking-Definitions with filters &#34; + json.dumps(filters) + &#34;.&#34;,
    )
    query = (
        &#34;&#34;&#34;
        query MarkingDefinitions($filters: [MarkingDefinitionsFiltering], $first: Int, $after: ID, $orderBy: MarkingDefinitionsOrdering, $orderMode: OrderingMode) {
            markingDefinitions(filters: $filters, first: $first, after: $after, orderBy: $orderBy, orderMode: $orderMode) {
                edges {
                    node {
                        &#34;&#34;&#34;
        + self.properties
        + &#34;&#34;&#34;
                    }
                }
                pageInfo {
                    startCursor
                    endCursor
                    hasNextPage
                    hasPreviousPage
                    globalCount
                }                    
            }
        }
    &#34;&#34;&#34;
    )
    result = self.opencti.query(
        query,
        {
            &#34;filters&#34;: filters,
            &#34;first&#34;: first,
            &#34;after&#34;: after,
            &#34;orderBy&#34;: order_by,
            &#34;orderMode&#34;: order_mode,
        },
    )
    return self.opencti.process_multiple(result[&#34;data&#34;][&#34;markingDefinitions&#34;])</code></pre>
</details>
</dd>
<dt id="pycti.MarkingDefinition.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    filters = kwargs.get(&#34;filters&#34;, None)
    if id is not None:
        self.opencti.log(&#34;info&#34;, &#34;Reading Marking-Definition {&#34; + id + &#34;}.&#34;)
        query = (
            &#34;&#34;&#34;
            query MarkingDefinition($id: String!) {
                markingDefinition(id: $id) {
                    &#34;&#34;&#34;
            + self.properties
            + &#34;&#34;&#34;
                }
            }
        &#34;&#34;&#34;
        )
        result = self.opencti.query(query, {&#34;id&#34;: id})
        return self.opencti.process_multiple_fields(
            result[&#34;data&#34;][&#34;markingDefinition&#34;]
        )
    elif filters is not None:
        result = self.list(filters=filters)
        if len(result) &gt; 0:
            return result[0]
        else:
            return None
    else:
        self.opencti.log(
            &#34;error&#34;,
            &#34;[opencti_marking_definition] Missing parameters: id or filters&#34;,
        )
        return None</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pycti.Note"><code class="flex name class">
<span>class <span class="ident">Note</span></span>
<span>(</span><span>opencti)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Note:
    def __init__(self, opencti):
        self.opencti = opencti
        self.properties = &#34;&#34;&#34;
            id
            stix_id_key
            entity_type
            stix_label
            name
            alias
            description
            content
            graph_data
            created
            modified
            created_at
            updated_at
            createdByRef {
                node {
                    id
                    entity_type
                    stix_id_key
                    stix_label
                    name
                    alias
                    description
                    created
                    modified
                    ... on Organization {
                        organization_class
                    }
                }
                relation {
                    id
                }
            }
            markingDefinitions {
                edges {
                    node {
                        id
                        entity_type
                        stix_id_key
                        definition_type
                        definition
                        level
                        color
                        created
                        modified
                    }
                    relation {
                        id
                    }
                }
            }
            tags {
                edges {
                    node {
                        id
                        tag_type
                        value
                        color
                    }
                    relation {
                        id
                    }
                }
            }            
            externalReferences {
                edges {
                    node {
                        id
                        entity_type
                        stix_id_key
                        source_name
                        description
                        url
                        hash
                        external_id
                        created
                        modified
                    }
                    relation {
                        id
                    }
                }
            }
            objectRefs {
                edges {
                    node {
                        id
                        stix_id_key
                        entity_type
                    }
                }
            }
            observableRefs {
                edges {
                    node {
                        id
                        stix_id_key
                        entity_type
                        observable_value
                    }
                }
            }
            relationRefs {
                edges {
                    node {
                        id
                        stix_id_key
                    }
                }
            }
        &#34;&#34;&#34;

    &#34;&#34;&#34;
        List Note objects

        :param filters: the filters to apply
        :param search: the search keyword
        :param first: return the first n rows from the after ID (or the beginning if not set)
        :param after: ID of the first row for pagination
        :return List of Note objects
    &#34;&#34;&#34;

    def list(self, **kwargs):
        filters = kwargs.get(&#34;filters&#34;, None)
        search = kwargs.get(&#34;search&#34;, None)
        first = kwargs.get(&#34;first&#34;, 500)
        after = kwargs.get(&#34;after&#34;, None)
        order_by = kwargs.get(&#34;orderBy&#34;, None)
        order_mode = kwargs.get(&#34;orderMode&#34;, None)
        get_all = kwargs.get(&#34;getAll&#34;, False)
        if get_all:
            first = 500

        self.opencti.log(
            &#34;info&#34;, &#34;Listing Notes with filters &#34; + json.dumps(filters) + &#34;.&#34;
        )
        query = (
            &#34;&#34;&#34;
            query Notes($filters: [NotesFiltering], $search: String, $first: Int, $after: ID, $orderBy: NotesOrdering, $orderMode: OrderingMode) {
                notes(filters: $filters, search: $search, first: $first, after: $after, orderBy: $orderBy, orderMode: $orderMode) {
                    edges {
                        node {
                            &#34;&#34;&#34;
            + self.properties
            + &#34;&#34;&#34;
                        }
                    }
                    pageInfo {
                        startCursor
                        endCursor
                        hasNextPage
                        hasPreviousPage
                        globalCount
                    }                    
                }
            }
        &#34;&#34;&#34;
        )
        result = self.opencti.query(
            query,
            {
                &#34;filters&#34;: filters,
                &#34;search&#34;: search,
                &#34;first&#34;: first,
                &#34;after&#34;: after,
                &#34;orderBy&#34;: order_by,
                &#34;orderMode&#34;: order_mode,
            },
        )
        return self.opencti.process_multiple(result[&#34;data&#34;][&#34;notes&#34;])

    &#34;&#34;&#34;
        Read a Note object

        :param id: the id of the Note
        :param filters: the filters to apply if no id provided
        :return Note object
    &#34;&#34;&#34;

    def read(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        filters = kwargs.get(&#34;filters&#34;, None)
        custom_attributes = kwargs.get(&#34;customAttributes&#34;, None)
        if id is not None:
            self.opencti.log(&#34;info&#34;, &#34;Reading Note {&#34; + id + &#34;}.&#34;)
            query = (
                &#34;&#34;&#34;
                query Note($id: String!) {
                    note(id: $id) {
                        &#34;&#34;&#34;
                + (
                    custom_attributes
                    if custom_attributes is not None
                    else self.properties
                )
                + &#34;&#34;&#34;
                    }
                }
            &#34;&#34;&#34;
            )
            result = self.opencti.query(query, {&#34;id&#34;: id})
            return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;note&#34;])
        elif filters is not None:
            result = self.list(filters=filters)
            if len(result) &gt; 0:
                return result[0]
            else:
                return None

    &#34;&#34;&#34;
        Read a Note object by stix_id or name

        :param type: the Stix-Domain-Entity type
        :param stix_id_key: the STIX ID of the Stix-Domain-Entity
        :param name: the name of the Stix-Domain-Entity
        :return Stix-Domain-Entity object
    &#34;&#34;&#34;

    def get_by_stix_id_or_name(self, **kwargs):
        stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
        description = kwargs.get(&#34;description&#34;, None)
        content = kwargs.get(&#34;content&#34;, None)
        custom_attributes = kwargs.get(&#34;customAttributes&#34;, None)
        object_result = None
        if stix_id_key is not None:
            object_result = self.read(
                id=stix_id_key, customAttributes=custom_attributes
            )
        if object_result is None and description is not None and content is not None:
            object_result = self.read(
                filters=[
                    {&#34;key&#34;: &#34;description&#34;, &#34;values&#34;: [description]},
                    {&#34;key&#34;: &#34;content&#34;, &#34;values&#34;: [content]},
                ],
                customAttributes=custom_attributes,
            )
        return object_result

    &#34;&#34;&#34;
        Check if a note already contains a STIX entity
        
        :return Boolean
    &#34;&#34;&#34;

    def contains_stix_entity(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        entity_id = kwargs.get(&#34;entity_id&#34;, None)
        if id is not None and entity_id is not None:
            self.opencti.log(
                &#34;info&#34;, &#34;Checking Stix-Entity {&#34; + entity_id + &#34;} in Note {&#34; + id + &#34;}&#34;,
            )
            query = &#34;&#34;&#34;
                query NoteContainsStixDomainEntity($id: String!, $objectId: String!) {
                    noteContainsStixDomainEntity(id: $id, objectId: $objectId)
                }
            &#34;&#34;&#34;
            result = self.opencti.query(query, {&#34;id&#34;: id, &#34;objectId&#34;: entity_id})
            if result[&#34;data&#34;][&#34;noteContainsStixDomainEntity&#34;]:
                return True
            query = &#34;&#34;&#34;
                query NoteContainsStixRelation($id: String!, $objectId: String!) {
                    noteContainsStixRelation(id: $id, objectId: $objectId)
                }
            &#34;&#34;&#34;
            result = self.opencti.query(query, {&#34;id&#34;: id, &#34;objectId&#34;: entity_id})
            return result[&#34;data&#34;][&#34;noteContainsStixRelation&#34;]
        else:
            self.opencti.log(
                &#34;error&#34;, &#34;[opencti_note] Missing parameters: id or entity_id&#34;,
            )

    &#34;&#34;&#34;
        Check if a note already contains a STIX observable

        :return Boolean
    &#34;&#34;&#34;

    def contains_stix_observable(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        stix_observable_id = kwargs.get(&#34;stix_observable_id&#34;, None)
        if id is not None and stix_observable_id is not None:
            self.opencti.log(
                &#34;info&#34;,
                &#34;Checking Stix-Observable {&#34;
                + stix_observable_id
                + &#34;} in Note {&#34;
                + id
                + &#34;}&#34;,
            )
            query = &#34;&#34;&#34;
                query NoteContainsStixObservable($id: String!, $objectId: String!) {
                    noteContainsStixObservable(id: $id, objectId: $objectId)
                }
            &#34;&#34;&#34;
            result = self.opencti.query(
                query, {&#34;id&#34;: id, &#34;objectId&#34;: stix_observable_id}
            )
            return result[&#34;data&#34;][&#34;noteContainsStixObservable&#34;]
        else:
            self.opencti.log(
                &#34;error&#34;, &#34;[opencti_note] Missing parameters: id or stix_observable_id&#34;,
            )

    &#34;&#34;&#34;
        Create a Note object

        :param name: the name of the Note
        :return Note object
    &#34;&#34;&#34;

    def create_raw(self, **kwargs):
        name = kwargs.get(&#34;name&#34;, None)
        description = kwargs.get(&#34;description&#34;, None)
        content = kwargs.get(&#34;content&#34;, None)
        graph_data = kwargs.get(&#34;graph_data&#34;, None)
        id = kwargs.get(&#34;id&#34;, None)
        stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
        created = kwargs.get(&#34;created&#34;, None)
        modified = kwargs.get(&#34;modified&#34;, None)
        created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
        marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)

        if name is not None and description is not None and content is not None:
            self.opencti.log(&#34;info&#34;, &#34;Creating Note {&#34; + description + &#34;}.&#34;)
            query = (
                &#34;&#34;&#34;
                mutation NoteAdd($input: NoteAddInput) {
                    noteAdd(input: $input) {
                        &#34;&#34;&#34;
                + self.properties
                + &#34;&#34;&#34;
                    }
                }
            &#34;&#34;&#34;
            )
            result = self.opencti.query(
                query,
                {
                    &#34;input&#34;: {
                        &#34;name&#34;: name,
                        &#34;description&#34;: description,
                        &#34;content&#34;: content,
                        &#34;graph_data&#34;: graph_data,
                        &#34;internal_id_key&#34;: id,
                        &#34;stix_id_key&#34;: stix_id_key,
                        &#34;created&#34;: created,
                        &#34;modified&#34;: modified,
                        &#34;createdByRef&#34;: created_by_ref,
                        &#34;markingDefinitions&#34;: marking_definitions,
                    }
                },
            )
            return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;noteAdd&#34;])
        else:
            self.opencti.log(
                &#34;error&#34;,
                &#34;[opencti_note] Missing parameters: name and description and published and note_class&#34;,
            )

    &#34;&#34;&#34;
         Create a Note object only if it not exists, update it on request

         :param name: the name of the Note
         :param description: the description of the Note
         :param published: the publication date of the Note
         :return Note object
     &#34;&#34;&#34;

    def create(self, **kwargs):
        name = kwargs.get(&#34;name&#34;, None)
        external_reference_id = kwargs.get(&#34;external_reference_id&#34;, None)
        description = kwargs.get(&#34;description&#34;, None)
        content = kwargs.get(&#34;content&#34;, None)
        graph_data = kwargs.get(&#34;graph_data&#34;, None)
        id = kwargs.get(&#34;id&#34;, None)
        stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
        created = kwargs.get(&#34;created&#34;, None)
        modified = kwargs.get(&#34;modified&#34;, None)
        created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
        marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)
        update = kwargs.get(&#34;update&#34;, False)
        custom_attributes = &#34;&#34;&#34;
            id
            entity_type
            name
            description 
            ... on Note {
                observableRefs {
                    edges {
                        node {
                            id
                            entity_type
                            stix_id_key
                            observable_value
                        }
                        relation {
                            id
                        }
                    }
                }
            }
        &#34;&#34;&#34;
        object_result = None
        if external_reference_id is not None:
            object_result = self.opencti.stix_domain_entity.read(
                types=[&#34;Note&#34;],
                filters=[
                    {&#34;key&#34;: &#34;hasExternalReference&#34;, &#34;values&#34;: [external_reference_id]}
                ],
                customAttributes=custom_attributes,
            )
        if object_result is None and description is not None and content is not None:
            object_result = self.get_by_stix_id_or_name(
                stix_id_key=stix_id_key,
                description=description,
                content=content,
                custom_attributes=custom_attributes,
            )
        if object_result is not None:
            if update:
                if object_result[&#34;name&#34;] != name:
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;name&#34;, value=name
                    )
                    object_result[&#34;name&#34;] = name
                if object_result[&#34;description&#34;] != description:
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;description&#34;, value=description
                    )
                    object_result[&#34;description&#34;] = description
                if object_result[&#34;content&#34;] != content:
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;content&#34;, value=content
                    )
                    object_result[&#34;content&#34;] = content
            if external_reference_id is not None:
                self.opencti.stix_entity.add_external_reference(
                    id=object_result[&#34;id&#34;],
                    entity=object_result,
                    external_reference_id=external_reference_id,
                )
            return object_result
        else:
            note = self.create_raw(
                name=name,
                description=description,
                content=content,
                graph_data=graph_data,
                id=id,
                stix_id_key=stix_id_key,
                created=created,
                modified=modified,
                createdByRef=created_by_ref,
                markingDefinitions=marking_definitions,
            )
            if external_reference_id is not None:
                self.opencti.stix_entity.add_external_reference(
                    id=note[&#34;id&#34;],
                    entity=note,
                    external_reference_id=external_reference_id,
                )
            return note

    &#34;&#34;&#34;
        Add a Stix-Entity object to Note object (object_refs)

        :param id: the id of the Note
        :param entity_id: the id of the Stix-Entity
        :return Boolean
    &#34;&#34;&#34;

    def add_stix_entity(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        note = kwargs.get(&#34;note&#34;, None)
        entity_id = kwargs.get(&#34;entity_id&#34;, None)
        if id is not None and entity_id is not None:
            if note is not None:
                if (
                    entity_id in note[&#34;objectRefsIds&#34;]
                    or entity_id in note[&#34;relationRefsIds&#34;]
                ):
                    return True
            else:
                if self.contains_stix_entity(id=id, entity_id=entity_id):
                    return True
            self.opencti.log(
                &#34;info&#34;, &#34;Adding Stix-Entity {&#34; + entity_id + &#34;} to Note {&#34; + id + &#34;}&#34;,
            )
            query = &#34;&#34;&#34;
               mutation NoteEdit($id: ID!, $input: RelationAddInput) {
                   noteEdit(id: $id) {
                        relationAdd(input: $input) {
                            id
                        }
                   }
               }
            &#34;&#34;&#34;
            self.opencti.query(
                query,
                {
                    &#34;id&#34;: id,
                    &#34;input&#34;: {
                        &#34;fromRole&#34;: &#34;knowledge_aggregation&#34;,
                        &#34;toId&#34;: entity_id,
                        &#34;toRole&#34;: &#34;so&#34;,
                        &#34;through&#34;: &#34;object_refs&#34;,
                    },
                },
            )
            return True
        else:
            self.opencti.log(
                &#34;error&#34;, &#34;[opencti_note] Missing parameters: id and entity_id&#34;
            )
            return False

    &#34;&#34;&#34;
        Add a Stix-Observable object to Note object (observable_refs)

        :param id: the id of the Note
        :param entity_id: the id of the Stix-Observable
        :return Boolean
    &#34;&#34;&#34;

    def add_stix_observable(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        note = kwargs.get(&#34;note&#34;, None)
        stix_observable_id = kwargs.get(&#34;stix_observable_id&#34;, None)
        if id is not None and stix_observable_id is not None:
            if note is not None:
                if stix_observable_id in note[&#34;observableRefsIds&#34;]:
                    return True
            else:
                if self.contains_stix_observable(
                    id=id, stix_observable_id=stix_observable_id
                ):
                    return True
            self.opencti.log(
                &#34;info&#34;,
                &#34;Adding Stix-Observable {&#34;
                + stix_observable_id
                + &#34;} to Note {&#34;
                + id
                + &#34;}&#34;,
            )
            query = &#34;&#34;&#34;
               mutation NoteEdit($id: ID!, $input: RelationAddInput) {
                   noteEdit(id: $id) {
                        relationAdd(input: $input) {
                            id
                        }
                   }
               }
            &#34;&#34;&#34;
            self.opencti.query(
                query,
                {
                    &#34;id&#34;: id,
                    &#34;input&#34;: {
                        &#34;fromRole&#34;: &#34;observables_aggregation&#34;,
                        &#34;toId&#34;: stix_observable_id,
                        &#34;toRole&#34;: &#34;soo&#34;,
                        &#34;through&#34;: &#34;observable_refs&#34;,
                    },
                },
            )
            return True
        else:
            self.opencti.log(
                &#34;error&#34;, &#34;[opencti_note] Missing parameters: id and stix_observable_id&#34;,
            )
            return False

    &#34;&#34;&#34;
        Import a Note object from a STIX2 object

        :param stixObject: the Stix-Object Note
        :return Note object
    &#34;&#34;&#34;

    def import_from_stix2(self, **kwargs):
        stix_object = kwargs.get(&#34;stixObject&#34;, None)
        extras = kwargs.get(&#34;extras&#34;, {})
        update = kwargs.get(&#34;update&#34;, False)
        if stix_object is not None:
            return self.create(
                description=self.opencti.stix2.convert_markdown(stix_object[&#34;abstract&#34;])
                if &#34;abstract&#34; in stix_object
                else &#34;&#34;,
                content=self.opencti.stix2.convert_markdown(stix_object[&#34;content&#34;])
                if &#34;content&#34; in stix_object
                else &#34;&#34;,
                name=stix_object[CustomProperties.NAME]
                if CustomProperties.NAME in stix_object
                else &#34;&#34;,
                graph_data=stix_object[CustomProperties.GRAPH_DATA]
                if CustomProperties.GRAPH_DATA in stix_object
                else &#34;&#34;,
                id=stix_object[CustomProperties.ID]
                if CustomProperties.ID in stix_object
                else None,
                stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
                created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
                modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
                createdByRef=extras[&#34;created_by_ref_id&#34;]
                if &#34;created_by_ref_id&#34; in extras
                else None,
                markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
                if &#34;marking_definitions_ids&#34; in extras
                else [],
                update=update,
            )
        else:
            self.opencti.log(
                &#34;error&#34;, &#34;[opencti_attack_pattern] Missing parameters: stixObject&#34;
            )

    &#34;&#34;&#34;
        Export a Note object in STIX2

        :param id: the id of the Note
        :return Note object
    &#34;&#34;&#34;

    def to_stix2(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        mode = kwargs.get(&#34;mode&#34;, &#34;simple&#34;)
        max_marking_definition_entity = kwargs.get(
            &#34;max_marking_definition_entity&#34;, None
        )
        entity = kwargs.get(&#34;entity&#34;, None)
        if id is not None and entity is None:
            entity = self.read(id=id)
        if entity is not None:
            note = dict()
            note[&#34;id&#34;] = entity[&#34;stix_id_key&#34;]
            note[&#34;type&#34;] = &#34;note&#34;
            note[&#34;spec_version&#34;] = SPEC_VERSION
            note[&#34;abstract&#34;] = entity[&#34;description&#34;]
            note[&#34;content&#34;] = entity[&#34;content&#34;]
            if self.opencti.not_empty(entity[&#34;stix_label&#34;]):
                note[&#34;labels&#34;] = entity[&#34;stix_label&#34;]
            else:
                note[&#34;labels&#34;] = [&#34;note&#34;]
            if self.opencti.not_empty(entity[&#34;description&#34;]):
                note[&#34;abstract&#34;] = entity[&#34;description&#34;]
            note[&#34;created&#34;] = self.opencti.stix2.format_date(entity[&#34;created&#34;])
            note[&#34;modified&#34;] = self.opencti.stix2.format_date(entity[&#34;modified&#34;])
            if self.opencti.not_empty(entity[&#34;alias&#34;]):
                note[CustomProperties.ALIASES] = entity[&#34;alias&#34;]
            if self.opencti.not_empty(entity[&#34;name&#34;]):
                note[CustomProperties.NAME] = entity[&#34;name&#34;]
            if self.opencti.not_empty(entity[&#34;graph_data&#34;]):
                note[CustomProperties.GRAPH_DATA] = entity[&#34;graph_data&#34;]
            note[CustomProperties.ID] = entity[&#34;id&#34;]
            return self.opencti.stix2.prepare_export(
                entity, note, mode, max_marking_definition_entity
            )
        else:
            self.opencti.log(&#34;error&#34;, &#34;[opencti_note] Missing parameters: id or entity&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pycti.Note.add_stix_entity"><code class="name flex">
<span>def <span class="ident">add_stix_entity</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_stix_entity(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    note = kwargs.get(&#34;note&#34;, None)
    entity_id = kwargs.get(&#34;entity_id&#34;, None)
    if id is not None and entity_id is not None:
        if note is not None:
            if (
                entity_id in note[&#34;objectRefsIds&#34;]
                or entity_id in note[&#34;relationRefsIds&#34;]
            ):
                return True
        else:
            if self.contains_stix_entity(id=id, entity_id=entity_id):
                return True
        self.opencti.log(
            &#34;info&#34;, &#34;Adding Stix-Entity {&#34; + entity_id + &#34;} to Note {&#34; + id + &#34;}&#34;,
        )
        query = &#34;&#34;&#34;
           mutation NoteEdit($id: ID!, $input: RelationAddInput) {
               noteEdit(id: $id) {
                    relationAdd(input: $input) {
                        id
                    }
               }
           }
        &#34;&#34;&#34;
        self.opencti.query(
            query,
            {
                &#34;id&#34;: id,
                &#34;input&#34;: {
                    &#34;fromRole&#34;: &#34;knowledge_aggregation&#34;,
                    &#34;toId&#34;: entity_id,
                    &#34;toRole&#34;: &#34;so&#34;,
                    &#34;through&#34;: &#34;object_refs&#34;,
                },
            },
        )
        return True
    else:
        self.opencti.log(
            &#34;error&#34;, &#34;[opencti_note] Missing parameters: id and entity_id&#34;
        )
        return False</code></pre>
</details>
</dd>
<dt id="pycti.Note.add_stix_observable"><code class="name flex">
<span>def <span class="ident">add_stix_observable</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_stix_observable(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    note = kwargs.get(&#34;note&#34;, None)
    stix_observable_id = kwargs.get(&#34;stix_observable_id&#34;, None)
    if id is not None and stix_observable_id is not None:
        if note is not None:
            if stix_observable_id in note[&#34;observableRefsIds&#34;]:
                return True
        else:
            if self.contains_stix_observable(
                id=id, stix_observable_id=stix_observable_id
            ):
                return True
        self.opencti.log(
            &#34;info&#34;,
            &#34;Adding Stix-Observable {&#34;
            + stix_observable_id
            + &#34;} to Note {&#34;
            + id
            + &#34;}&#34;,
        )
        query = &#34;&#34;&#34;
           mutation NoteEdit($id: ID!, $input: RelationAddInput) {
               noteEdit(id: $id) {
                    relationAdd(input: $input) {
                        id
                    }
               }
           }
        &#34;&#34;&#34;
        self.opencti.query(
            query,
            {
                &#34;id&#34;: id,
                &#34;input&#34;: {
                    &#34;fromRole&#34;: &#34;observables_aggregation&#34;,
                    &#34;toId&#34;: stix_observable_id,
                    &#34;toRole&#34;: &#34;soo&#34;,
                    &#34;through&#34;: &#34;observable_refs&#34;,
                },
            },
        )
        return True
    else:
        self.opencti.log(
            &#34;error&#34;, &#34;[opencti_note] Missing parameters: id and stix_observable_id&#34;,
        )
        return False</code></pre>
</details>
</dd>
<dt id="pycti.Note.contains_stix_entity"><code class="name flex">
<span>def <span class="ident">contains_stix_entity</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def contains_stix_entity(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    entity_id = kwargs.get(&#34;entity_id&#34;, None)
    if id is not None and entity_id is not None:
        self.opencti.log(
            &#34;info&#34;, &#34;Checking Stix-Entity {&#34; + entity_id + &#34;} in Note {&#34; + id + &#34;}&#34;,
        )
        query = &#34;&#34;&#34;
            query NoteContainsStixDomainEntity($id: String!, $objectId: String!) {
                noteContainsStixDomainEntity(id: $id, objectId: $objectId)
            }
        &#34;&#34;&#34;
        result = self.opencti.query(query, {&#34;id&#34;: id, &#34;objectId&#34;: entity_id})
        if result[&#34;data&#34;][&#34;noteContainsStixDomainEntity&#34;]:
            return True
        query = &#34;&#34;&#34;
            query NoteContainsStixRelation($id: String!, $objectId: String!) {
                noteContainsStixRelation(id: $id, objectId: $objectId)
            }
        &#34;&#34;&#34;
        result = self.opencti.query(query, {&#34;id&#34;: id, &#34;objectId&#34;: entity_id})
        return result[&#34;data&#34;][&#34;noteContainsStixRelation&#34;]
    else:
        self.opencti.log(
            &#34;error&#34;, &#34;[opencti_note] Missing parameters: id or entity_id&#34;,
        )</code></pre>
</details>
</dd>
<dt id="pycti.Note.contains_stix_observable"><code class="name flex">
<span>def <span class="ident">contains_stix_observable</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def contains_stix_observable(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    stix_observable_id = kwargs.get(&#34;stix_observable_id&#34;, None)
    if id is not None and stix_observable_id is not None:
        self.opencti.log(
            &#34;info&#34;,
            &#34;Checking Stix-Observable {&#34;
            + stix_observable_id
            + &#34;} in Note {&#34;
            + id
            + &#34;}&#34;,
        )
        query = &#34;&#34;&#34;
            query NoteContainsStixObservable($id: String!, $objectId: String!) {
                noteContainsStixObservable(id: $id, objectId: $objectId)
            }
        &#34;&#34;&#34;
        result = self.opencti.query(
            query, {&#34;id&#34;: id, &#34;objectId&#34;: stix_observable_id}
        )
        return result[&#34;data&#34;][&#34;noteContainsStixObservable&#34;]
    else:
        self.opencti.log(
            &#34;error&#34;, &#34;[opencti_note] Missing parameters: id or stix_observable_id&#34;,
        )</code></pre>
</details>
</dd>
<dt id="pycti.Note.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create(self, **kwargs):
    name = kwargs.get(&#34;name&#34;, None)
    external_reference_id = kwargs.get(&#34;external_reference_id&#34;, None)
    description = kwargs.get(&#34;description&#34;, None)
    content = kwargs.get(&#34;content&#34;, None)
    graph_data = kwargs.get(&#34;graph_data&#34;, None)
    id = kwargs.get(&#34;id&#34;, None)
    stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
    created = kwargs.get(&#34;created&#34;, None)
    modified = kwargs.get(&#34;modified&#34;, None)
    created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
    marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)
    update = kwargs.get(&#34;update&#34;, False)
    custom_attributes = &#34;&#34;&#34;
        id
        entity_type
        name
        description 
        ... on Note {
            observableRefs {
                edges {
                    node {
                        id
                        entity_type
                        stix_id_key
                        observable_value
                    }
                    relation {
                        id
                    }
                }
            }
        }
    &#34;&#34;&#34;
    object_result = None
    if external_reference_id is not None:
        object_result = self.opencti.stix_domain_entity.read(
            types=[&#34;Note&#34;],
            filters=[
                {&#34;key&#34;: &#34;hasExternalReference&#34;, &#34;values&#34;: [external_reference_id]}
            ],
            customAttributes=custom_attributes,
        )
    if object_result is None and description is not None and content is not None:
        object_result = self.get_by_stix_id_or_name(
            stix_id_key=stix_id_key,
            description=description,
            content=content,
            custom_attributes=custom_attributes,
        )
    if object_result is not None:
        if update:
            if object_result[&#34;name&#34;] != name:
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;name&#34;, value=name
                )
                object_result[&#34;name&#34;] = name
            if object_result[&#34;description&#34;] != description:
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;description&#34;, value=description
                )
                object_result[&#34;description&#34;] = description
            if object_result[&#34;content&#34;] != content:
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;content&#34;, value=content
                )
                object_result[&#34;content&#34;] = content
        if external_reference_id is not None:
            self.opencti.stix_entity.add_external_reference(
                id=object_result[&#34;id&#34;],
                entity=object_result,
                external_reference_id=external_reference_id,
            )
        return object_result
    else:
        note = self.create_raw(
            name=name,
            description=description,
            content=content,
            graph_data=graph_data,
            id=id,
            stix_id_key=stix_id_key,
            created=created,
            modified=modified,
            createdByRef=created_by_ref,
            markingDefinitions=marking_definitions,
        )
        if external_reference_id is not None:
            self.opencti.stix_entity.add_external_reference(
                id=note[&#34;id&#34;],
                entity=note,
                external_reference_id=external_reference_id,
            )
        return note</code></pre>
</details>
</dd>
<dt id="pycti.Note.create_raw"><code class="name flex">
<span>def <span class="ident">create_raw</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_raw(self, **kwargs):
    name = kwargs.get(&#34;name&#34;, None)
    description = kwargs.get(&#34;description&#34;, None)
    content = kwargs.get(&#34;content&#34;, None)
    graph_data = kwargs.get(&#34;graph_data&#34;, None)
    id = kwargs.get(&#34;id&#34;, None)
    stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
    created = kwargs.get(&#34;created&#34;, None)
    modified = kwargs.get(&#34;modified&#34;, None)
    created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
    marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)

    if name is not None and description is not None and content is not None:
        self.opencti.log(&#34;info&#34;, &#34;Creating Note {&#34; + description + &#34;}.&#34;)
        query = (
            &#34;&#34;&#34;
            mutation NoteAdd($input: NoteAddInput) {
                noteAdd(input: $input) {
                    &#34;&#34;&#34;
            + self.properties
            + &#34;&#34;&#34;
                }
            }
        &#34;&#34;&#34;
        )
        result = self.opencti.query(
            query,
            {
                &#34;input&#34;: {
                    &#34;name&#34;: name,
                    &#34;description&#34;: description,
                    &#34;content&#34;: content,
                    &#34;graph_data&#34;: graph_data,
                    &#34;internal_id_key&#34;: id,
                    &#34;stix_id_key&#34;: stix_id_key,
                    &#34;created&#34;: created,
                    &#34;modified&#34;: modified,
                    &#34;createdByRef&#34;: created_by_ref,
                    &#34;markingDefinitions&#34;: marking_definitions,
                }
            },
        )
        return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;noteAdd&#34;])
    else:
        self.opencti.log(
            &#34;error&#34;,
            &#34;[opencti_note] Missing parameters: name and description and published and note_class&#34;,
        )</code></pre>
</details>
</dd>
<dt id="pycti.Note.get_by_stix_id_or_name"><code class="name flex">
<span>def <span class="ident">get_by_stix_id_or_name</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_by_stix_id_or_name(self, **kwargs):
    stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
    description = kwargs.get(&#34;description&#34;, None)
    content = kwargs.get(&#34;content&#34;, None)
    custom_attributes = kwargs.get(&#34;customAttributes&#34;, None)
    object_result = None
    if stix_id_key is not None:
        object_result = self.read(
            id=stix_id_key, customAttributes=custom_attributes
        )
    if object_result is None and description is not None and content is not None:
        object_result = self.read(
            filters=[
                {&#34;key&#34;: &#34;description&#34;, &#34;values&#34;: [description]},
                {&#34;key&#34;: &#34;content&#34;, &#34;values&#34;: [content]},
            ],
            customAttributes=custom_attributes,
        )
    return object_result</code></pre>
</details>
</dd>
<dt id="pycti.Note.import_from_stix2"><code class="name flex">
<span>def <span class="ident">import_from_stix2</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def import_from_stix2(self, **kwargs):
    stix_object = kwargs.get(&#34;stixObject&#34;, None)
    extras = kwargs.get(&#34;extras&#34;, {})
    update = kwargs.get(&#34;update&#34;, False)
    if stix_object is not None:
        return self.create(
            description=self.opencti.stix2.convert_markdown(stix_object[&#34;abstract&#34;])
            if &#34;abstract&#34; in stix_object
            else &#34;&#34;,
            content=self.opencti.stix2.convert_markdown(stix_object[&#34;content&#34;])
            if &#34;content&#34; in stix_object
            else &#34;&#34;,
            name=stix_object[CustomProperties.NAME]
            if CustomProperties.NAME in stix_object
            else &#34;&#34;,
            graph_data=stix_object[CustomProperties.GRAPH_DATA]
            if CustomProperties.GRAPH_DATA in stix_object
            else &#34;&#34;,
            id=stix_object[CustomProperties.ID]
            if CustomProperties.ID in stix_object
            else None,
            stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
            created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
            modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
            createdByRef=extras[&#34;created_by_ref_id&#34;]
            if &#34;created_by_ref_id&#34; in extras
            else None,
            markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
            if &#34;marking_definitions_ids&#34; in extras
            else [],
            update=update,
        )
    else:
        self.opencti.log(
            &#34;error&#34;, &#34;[opencti_attack_pattern] Missing parameters: stixObject&#34;
        )</code></pre>
</details>
</dd>
<dt id="pycti.Note.list"><code class="name flex">
<span>def <span class="ident">list</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list(self, **kwargs):
    filters = kwargs.get(&#34;filters&#34;, None)
    search = kwargs.get(&#34;search&#34;, None)
    first = kwargs.get(&#34;first&#34;, 500)
    after = kwargs.get(&#34;after&#34;, None)
    order_by = kwargs.get(&#34;orderBy&#34;, None)
    order_mode = kwargs.get(&#34;orderMode&#34;, None)
    get_all = kwargs.get(&#34;getAll&#34;, False)
    if get_all:
        first = 500

    self.opencti.log(
        &#34;info&#34;, &#34;Listing Notes with filters &#34; + json.dumps(filters) + &#34;.&#34;
    )
    query = (
        &#34;&#34;&#34;
        query Notes($filters: [NotesFiltering], $search: String, $first: Int, $after: ID, $orderBy: NotesOrdering, $orderMode: OrderingMode) {
            notes(filters: $filters, search: $search, first: $first, after: $after, orderBy: $orderBy, orderMode: $orderMode) {
                edges {
                    node {
                        &#34;&#34;&#34;
        + self.properties
        + &#34;&#34;&#34;
                    }
                }
                pageInfo {
                    startCursor
                    endCursor
                    hasNextPage
                    hasPreviousPage
                    globalCount
                }                    
            }
        }
    &#34;&#34;&#34;
    )
    result = self.opencti.query(
        query,
        {
            &#34;filters&#34;: filters,
            &#34;search&#34;: search,
            &#34;first&#34;: first,
            &#34;after&#34;: after,
            &#34;orderBy&#34;: order_by,
            &#34;orderMode&#34;: order_mode,
        },
    )
    return self.opencti.process_multiple(result[&#34;data&#34;][&#34;notes&#34;])</code></pre>
</details>
</dd>
<dt id="pycti.Note.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    filters = kwargs.get(&#34;filters&#34;, None)
    custom_attributes = kwargs.get(&#34;customAttributes&#34;, None)
    if id is not None:
        self.opencti.log(&#34;info&#34;, &#34;Reading Note {&#34; + id + &#34;}.&#34;)
        query = (
            &#34;&#34;&#34;
            query Note($id: String!) {
                note(id: $id) {
                    &#34;&#34;&#34;
            + (
                custom_attributes
                if custom_attributes is not None
                else self.properties
            )
            + &#34;&#34;&#34;
                }
            }
        &#34;&#34;&#34;
        )
        result = self.opencti.query(query, {&#34;id&#34;: id})
        return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;note&#34;])
    elif filters is not None:
        result = self.list(filters=filters)
        if len(result) &gt; 0:
            return result[0]
        else:
            return None</code></pre>
</details>
</dd>
<dt id="pycti.Note.to_stix2"><code class="name flex">
<span>def <span class="ident">to_stix2</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_stix2(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    mode = kwargs.get(&#34;mode&#34;, &#34;simple&#34;)
    max_marking_definition_entity = kwargs.get(
        &#34;max_marking_definition_entity&#34;, None
    )
    entity = kwargs.get(&#34;entity&#34;, None)
    if id is not None and entity is None:
        entity = self.read(id=id)
    if entity is not None:
        note = dict()
        note[&#34;id&#34;] = entity[&#34;stix_id_key&#34;]
        note[&#34;type&#34;] = &#34;note&#34;
        note[&#34;spec_version&#34;] = SPEC_VERSION
        note[&#34;abstract&#34;] = entity[&#34;description&#34;]
        note[&#34;content&#34;] = entity[&#34;content&#34;]
        if self.opencti.not_empty(entity[&#34;stix_label&#34;]):
            note[&#34;labels&#34;] = entity[&#34;stix_label&#34;]
        else:
            note[&#34;labels&#34;] = [&#34;note&#34;]
        if self.opencti.not_empty(entity[&#34;description&#34;]):
            note[&#34;abstract&#34;] = entity[&#34;description&#34;]
        note[&#34;created&#34;] = self.opencti.stix2.format_date(entity[&#34;created&#34;])
        note[&#34;modified&#34;] = self.opencti.stix2.format_date(entity[&#34;modified&#34;])
        if self.opencti.not_empty(entity[&#34;alias&#34;]):
            note[CustomProperties.ALIASES] = entity[&#34;alias&#34;]
        if self.opencti.not_empty(entity[&#34;name&#34;]):
            note[CustomProperties.NAME] = entity[&#34;name&#34;]
        if self.opencti.not_empty(entity[&#34;graph_data&#34;]):
            note[CustomProperties.GRAPH_DATA] = entity[&#34;graph_data&#34;]
        note[CustomProperties.ID] = entity[&#34;id&#34;]
        return self.opencti.stix2.prepare_export(
            entity, note, mode, max_marking_definition_entity
        )
    else:
        self.opencti.log(&#34;error&#34;, &#34;[opencti_note] Missing parameters: id or entity&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pycti.ObservableTypes"><code class="flex name class">
<span>class <span class="ident">ObservableTypes</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>These are the possible values for OpenCTI's observable types.
Use in conjuction with the STIX custom property 'x_opencti_observable_type'.
ref: <a href="https://github.com/OpenCTI-Platform/opencti/blob/8854c2576dc17da9da54e54b116779bd2131617c/opencti-front/src/private/components/report/ReportAddObservable.js">https://github.com/OpenCTI-Platform/opencti/blob/8854c2576dc17da9da54e54b116779bd2131617c/opencti-front/src/private/components/report/ReportAddObservable.js</a>
NOTE: should this be a mapping between the stix2 SDO objects (i.e. stix2/v20/sdo.py)?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ObservableTypes(Enum):
    &#34;&#34;&#34;These are the possible values for OpenCTI&#39;s observable types.
    Use in conjuction with the STIX custom property &#39;x_opencti_observable_type&#39;.
    ref: https://github.com/OpenCTI-Platform/opencti/blob/8854c2576dc17da9da54e54b116779bd2131617c/opencti-front/src/private/components/report/ReportAddObservable.js
    NOTE: should this be a mapping between the stix2 SDO objects (i.e. stix2/v20/sdo.py)?
    &#34;&#34;&#34;

    AUTONOMOUS_SYSTEM = &#34;Autonomous-System&#34;
    DOMAIN = &#34;Domain&#34;
    EMAIL_ADDR = &#34;Email-Address&#34;
    EMAIL_SUBJECT = &#34;Email-Subject&#34;
    DIRECTORY = &#34;Directory&#34;
    FILE_NAME = &#34;File-Name&#34;
    FILE_PATH = &#34;File-Path&#34;
    FILE_HASH_MD5 = &#34;File-MD5&#34;
    FILE_HASH_SHA1 = &#34;File-SHA1&#34;
    FILE_HASH_SHA256 = &#34;File-SHA256&#34;
    IPV4_ADDR = &#34;IPv4-Addr&#34;
    IPV6_ADDR = &#34;IPv6-Addr&#34;
    MAC_ADDR = &#34;Mac-Addr&#34;
    MUTEX = &#34;Mutex&#34;
    PDB_PATH = &#34;PDB-Path&#34;
    REGISTRY_KEY = &#34;Registry-Key&#34;
    REGISTRY_VALUE = &#34;Registry-Key-Value&#34;
    URL = &#34;URL&#34;
    WIN_SERVICE_NAME = &#34;Windows-Service-Name&#34;
    WIN_SERVICE_DISPLAY = &#34;Windows-Service-Display-Name&#34;
    WIN_SCHEDULED_TASK = &#34;Windows-Scheduled-Task&#34;
    X509_CERT_ISSUER = &#34;X509-Certificate-Issuer&#34;
    X509_CERT_SN = &#34;X509-Certificate-Serial-Number&#34;

    @classmethod
    def has_value(cls, value):
        lower_attr = list(map(lambda x: x.lower(), cls._value2member_map_))
        return value in lower_attr</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pycti.ObservableTypes.AUTONOMOUS_SYSTEM"><code class="name">var <span class="ident">AUTONOMOUS_SYSTEM</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.ObservableTypes.DIRECTORY"><code class="name">var <span class="ident">DIRECTORY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.ObservableTypes.DOMAIN"><code class="name">var <span class="ident">DOMAIN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.ObservableTypes.EMAIL_ADDR"><code class="name">var <span class="ident">EMAIL_ADDR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.ObservableTypes.EMAIL_SUBJECT"><code class="name">var <span class="ident">EMAIL_SUBJECT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.ObservableTypes.FILE_HASH_MD5"><code class="name">var <span class="ident">FILE_HASH_MD5</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.ObservableTypes.FILE_HASH_SHA1"><code class="name">var <span class="ident">FILE_HASH_SHA1</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.ObservableTypes.FILE_HASH_SHA256"><code class="name">var <span class="ident">FILE_HASH_SHA256</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.ObservableTypes.FILE_NAME"><code class="name">var <span class="ident">FILE_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.ObservableTypes.FILE_PATH"><code class="name">var <span class="ident">FILE_PATH</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.ObservableTypes.IPV4_ADDR"><code class="name">var <span class="ident">IPV4_ADDR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.ObservableTypes.IPV6_ADDR"><code class="name">var <span class="ident">IPV6_ADDR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.ObservableTypes.MAC_ADDR"><code class="name">var <span class="ident">MAC_ADDR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.ObservableTypes.MUTEX"><code class="name">var <span class="ident">MUTEX</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.ObservableTypes.PDB_PATH"><code class="name">var <span class="ident">PDB_PATH</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.ObservableTypes.REGISTRY_KEY"><code class="name">var <span class="ident">REGISTRY_KEY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.ObservableTypes.REGISTRY_VALUE"><code class="name">var <span class="ident">REGISTRY_VALUE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.ObservableTypes.URL"><code class="name">var <span class="ident">URL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.ObservableTypes.WIN_SCHEDULED_TASK"><code class="name">var <span class="ident">WIN_SCHEDULED_TASK</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.ObservableTypes.WIN_SERVICE_DISPLAY"><code class="name">var <span class="ident">WIN_SERVICE_DISPLAY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.ObservableTypes.WIN_SERVICE_NAME"><code class="name">var <span class="ident">WIN_SERVICE_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.ObservableTypes.X509_CERT_ISSUER"><code class="name">var <span class="ident">X509_CERT_ISSUER</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pycti.ObservableTypes.X509_CERT_SN"><code class="name">var <span class="ident">X509_CERT_SN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="pycti.OpenCTIApiClient"><code class="flex name class">
<span>class <span class="ident">OpenCTIApiClient</span></span>
<span>(</span><span>url, token, log_level='info', ssl_verify=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Python API for OpenCTI
:param url: OpenCTI URL
:param token: The API key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OpenCTIApiClient:
    &#34;&#34;&#34;
        Python API for OpenCTI
        :param url: OpenCTI URL
        :param token: The API key
    &#34;&#34;&#34;

    def __init__(self, url, token, log_level=&#34;info&#34;, ssl_verify=False):
        # Check configuration
        self.ssl_verify = ssl_verify
        if url is None or len(token) == 0:
            raise ValueError(&#34;Url configuration must be configured&#34;)
        if token is None or len(token) == 0 or token == &#34;ChangeMe&#34;:
            raise ValueError(
                &#34;Token configuration must be the same as APP__ADMIN__TOKEN&#34;
            )

        # Configure logger
        self.log_level = log_level
        numeric_level = getattr(logging, self.log_level.upper(), None)
        if not isinstance(numeric_level, int):
            raise ValueError(&#34;Invalid log level: &#34; + self.log_level)
        logging.basicConfig(level=numeric_level)

        # Define API
        self.api_url = url + &#34;/graphql&#34;
        self.request_headers = {&#34;Authorization&#34;: &#34;Bearer &#34; + token}

        # Define the dependencies
        self.job = OpenCTIApiJob(self)
        self.connector = OpenCTIApiConnector(self)
        self.stix2 = OpenCTIStix2(self)

        # Define the entities
        self.tag = Tag(self)
        self.marking_definition = MarkingDefinition(self)
        self.external_reference = ExternalReference(self)
        self.kill_chain_phase = KillChainPhase(self)
        self.stix_entity = StixEntity(self)
        self.stix_domain_entity = StixDomainEntity(self, File)
        self.stix_observable = StixObservable(self)
        self.stix_relation = StixRelation(self)
        self.stix_observable_relation = StixObservableRelation(self)
        self.identity = Identity(self)
        self.threat_actor = ThreatActor(self)
        self.intrusion_set = IntrusionSet(self)
        self.campaign = Campaign(self)
        self.incident = Incident(self)
        self.malware = Malware(self)
        self.tool = Tool(self)
        self.vulnerability = Vulnerability(self)
        self.attack_pattern = AttackPattern(self)
        self.course_of_action = CourseOfAction(self)
        self.report = Report(self)
        self.note = Note(self)
        self.opinion = Opinion(self)
        self.indicator = Indicator(self)

        # Check if openCTI is available
        if not self.health_check():
            raise ValueError(
                &#34;OpenCTI API is not reachable. Waiting for OpenCTI API to start or check your configuration...&#34;
            )

    def query(self, query, variables={}):
        query_var = {}
        files_vars = []
        # Implementation of spec https://github.com/jaydenseric/graphql-multipart-request-spec
        # Support for single or multiple upload
        # Batching or mixed upload or not supported
        var_keys = variables.keys()
        for key in var_keys:
            val = variables[key]
            is_file = type(val) is File
            is_files = (
                isinstance(val, list)
                and len(val) &gt; 0
                and all(map(lambda x: isinstance(x, File), val))
            )
            if is_file or is_files:
                files_vars.append({&#34;key&#34;: key, &#34;file&#34;: val, &#34;multiple&#34;: is_files})
                query_var[key] = None if is_file else [None] * len(val)
            else:
                query_var[key] = val

        # If yes, transform variable (file to null) and create multipart query
        if len(files_vars) &gt; 0:
            multipart_data = {
                &#34;operations&#34;: json.dumps({&#34;query&#34;: query, &#34;variables&#34;: query_var})
            }
            # Build the multipart map
            map_index = 0
            file_vars = {}
            for file_var_item in files_vars:
                is_multiple_files = file_var_item[&#34;multiple&#34;]
                var_name = &#34;variables.&#34; + file_var_item[&#34;key&#34;]
                if is_multiple_files:
                    # [(var_name + &#34;.&#34; + i)] if is_multiple_files else
                    for _ in file_var_item[&#34;file&#34;]:
                        file_vars[str(map_index)] = [(var_name + &#34;.&#34; + str(map_index))]
                        map_index += 1
                else:
                    file_vars[str(map_index)] = [var_name]
                    map_index += 1
            multipart_data[&#34;map&#34;] = json.dumps(file_vars)
            # Add the files
            file_index = 0
            multipart_files = []
            for file_var_item in files_vars:
                files = file_var_item[&#34;file&#34;]
                is_multiple_files = file_var_item[&#34;multiple&#34;]
                if is_multiple_files:
                    for file in files:
                        if isinstance(file.data, str):
                            file_multi = (
                                str(file_index),
                                (file.name, io.BytesIO(file.data.encode()), file.mime,),
                            )
                        else:
                            file_multi = (
                                str(file_index),
                                (file.name, file.data, file.mime),
                            )
                        multipart_files.append(file_multi)
                        file_index += 1
                else:
                    if isinstance(files.data, str):
                        file_multi = (
                            str(file_index),
                            (files.name, io.BytesIO(files.data.encode()), files.mime),
                        )
                    else:
                        file_multi = (
                            str(file_index),
                            (files.name, files.data, files.mime),
                        )
                    multipart_files.append(file_multi)
                    file_index += 1
            # Send the multipart request
            r = requests.post(
                self.api_url,
                data=multipart_data,
                files=multipart_files,
                headers=self.request_headers,
                verify=self.ssl_verify,
            )
        # If no
        else:
            r = requests.post(
                self.api_url,
                json={&#34;query&#34;: query, &#34;variables&#34;: variables},
                headers=self.request_headers,
                verify=self.ssl_verify,
            )
        # Build response
        if r.status_code == requests.codes.ok:
            result = r.json()
            if &#34;errors&#34; in result:
                logging.error(result[&#34;errors&#34;][0][&#34;message&#34;])
            else:
                return result
        else:
            logging.info(r.text)

    def fetch_opencti_file(self, fetch_uri, binary=False):
        r = requests.get(fetch_uri, headers=self.request_headers)
        if binary:
            return r.content
        return r.text

    def log(self, level, message):
        if level == &#34;debug&#34;:
            logging.debug(message)
        elif level == &#34;info&#34;:
            logging.info(message)
        elif level == &#34;warning&#34;:
            logging.warn(message)
        elif level == &#34;error&#34;:
            logging.error(message)

    def health_check(self):
        try:
            test = self.threat_actor.list(first=1)
            if test is not None:
                return True
        except:
            return False
        return False

    def not_empty(self, value):
        if value is not None:
            if isinstance(value, str):
                if len(value) &gt; 0:
                    return True
                else:
                    return False
            if isinstance(value, list):
                is_not_empty = False
                for v in value:
                    if len(v) &gt; 0:
                        is_not_empty = True
                return is_not_empty
            if isinstance(value, int):
                return True
            else:
                return False
        else:
            return False

    def process_multiple(self, data):
        result = []
        if data is None:
            return result
        for edge in (
            data[&#34;edges&#34;] if &#34;edges&#34; in data and data[&#34;edges&#34;] is not None else []
        ):
            row = edge[&#34;node&#34;]
            # Handle remote relation ID
            if (
                &#34;relation&#34; in edge
                and edge[&#34;relation&#34;] is not None
                and &#34;id&#34; in edge[&#34;relation&#34;]
            ):
                row[&#34;remote_relation_id&#34;] = edge[&#34;relation&#34;][&#34;id&#34;]
            result.append(self.process_multiple_fields(row))
        return result

    def process_multiple_ids(self, data):
        result = []
        if data is None:
            return result
        if isinstance(data, list):
            for d in data:
                if isinstance(d, dict) and &#34;id&#34; in d:
                    result.append(d[&#34;id&#34;])
        return result

    def process_multiple_fields(self, data):
        if data is None:
            return data
        if (
            &#34;createdByRef&#34; in data
            and data[&#34;createdByRef&#34;] is not None
            and &#34;node&#34; in data[&#34;createdByRef&#34;]
        ):
            row = data[&#34;createdByRef&#34;][&#34;node&#34;]
            # Handle remote relation ID
            if &#34;relation&#34; in data[&#34;createdByRef&#34;]:
                row[&#34;remote_relation_id&#34;] = data[&#34;createdByRef&#34;][&#34;relation&#34;][&#34;id&#34;]
            data[&#34;createdByRef&#34;] = row
        else:
            data[&#34;createdByRef&#34;] = None
        if &#34;markingDefinitions&#34; in data:
            data[&#34;markingDefinitions&#34;] = self.process_multiple(
                data[&#34;markingDefinitions&#34;]
            )
            data[&#34;markingDefinitionsIds&#34;] = self.process_multiple_ids(
                data[&#34;markingDefinitions&#34;]
            )
        if &#34;tags&#34; in data:
            data[&#34;tags&#34;] = self.process_multiple(data[&#34;tags&#34;])
            data[&#34;tagsIds&#34;] = self.process_multiple_ids(data[&#34;tags&#34;])
        if &#34;reports&#34; in data:
            data[&#34;reports&#34;] = self.process_multiple(data[&#34;reports&#34;])
            data[&#34;reportsIds&#34;] = self.process_multiple_ids(data[&#34;reports&#34;])
        if &#34;killChainPhases&#34; in data:
            data[&#34;killChainPhases&#34;] = self.process_multiple(data[&#34;killChainPhases&#34;])
            data[&#34;killChainPhasesIds&#34;] = self.process_multiple_ids(
                data[&#34;killChainPhases&#34;]
            )
        if &#34;externalReferences&#34; in data:
            data[&#34;externalReferences&#34;] = self.process_multiple(
                data[&#34;externalReferences&#34;]
            )
            data[&#34;externalReferencesIds&#34;] = self.process_multiple_ids(
                data[&#34;externalReferences&#34;]
            )
        if &#34;objectRefs&#34; in data:
            data[&#34;objectRefs&#34;] = self.process_multiple(data[&#34;objectRefs&#34;])
            data[&#34;objectRefsIds&#34;] = self.process_multiple_ids(data[&#34;objectRefs&#34;])
        if &#34;observableRefs&#34; in data:
            data[&#34;observableRefs&#34;] = self.process_multiple(data[&#34;observableRefs&#34;])
            data[&#34;observableRefsIds&#34;] = self.process_multiple_ids(
                data[&#34;observableRefs&#34;]
            )
        if &#34;relationRefs&#34; in data:
            data[&#34;relationRefs&#34;] = self.process_multiple(data[&#34;relationRefs&#34;])
            data[&#34;relationRefsIds&#34;] = self.process_multiple_ids(data[&#34;relationRefs&#34;])
        if &#34;stixRelations&#34; in data:
            data[&#34;stixRelations&#34;] = self.process_multiple(data[&#34;stixRelations&#34;])
            data[&#34;stixRelationsIds&#34;] = self.process_multiple_ids(data[&#34;stixRelations&#34;])
        if &#34;indicators&#34; in data:
            data[&#34;indicators&#34;] = self.process_multiple(data[&#34;indicators&#34;])
            data[&#34;indicatorsIds&#34;] = self.process_multiple_ids(data[&#34;indicators&#34;])
        if &#34;importFiles&#34; in data:
            data[&#34;importFiles&#34;] = self.process_multiple(data[&#34;importFiles&#34;])
            data[&#34;importFilesIds&#34;] = self.process_multiple_ids(data[&#34;importFiles&#34;])
        return data

    def upload_file(self, **kwargs):
        file_name = kwargs.get(&#34;file_name&#34;, None)
        data = kwargs.get(&#34;data&#34;, None)
        mime_type = kwargs.get(&#34;mime_type&#34;, &#34;text/plain&#34;)
        if file_name is not None:
            self.log(&#34;info&#34;, &#34;Uploading a file.&#34;)
            query = &#34;&#34;&#34;
                mutation UploadImport($file: Upload!) {
                    uploadImport(file: $file) {
                        id
                        name
                    }
                }
             &#34;&#34;&#34;
            if data is None:
                data = open(file_name, &#34;rb&#34;)
                mime_type = magic.from_file(file_name, mime=True)

            return self.query(query, {&#34;file&#34;: (File(file_name, data, mime_type))})
        else:
            self.log(
                &#34;error&#34;, &#34;[upload] Missing parameters: file_name or data&#34;,
            )
            return None

    # TODO Move to StixObservable
    def update_stix_observable_field(self, id, key, value):
        logging.info(&#34;Updating field &#34; + key + &#34; of &#34; + id + &#34;...&#34;)
        query = &#34;&#34;&#34;
            mutation StixObservableEdit($id: ID!, $input: EditInput!) {
                stixObservableEdit(id: $id) {
                    fieldPatch(input: $input) {
                        id
                        observable_value
                        entity_type
                    }
                }
            }
        &#34;&#34;&#34;
        self.query(query, {&#34;id&#34;: id, &#34;input&#34;: {&#34;key&#34;: key, &#34;value&#34;: value}})

    # TODO Move to ExternalReference
    def delete_external_reference(self, id):
        logging.info(&#34;Deleting + &#34; + id + &#34;...&#34;)
        query = &#34;&#34;&#34;
             mutation ExternalReferenceEdit($id: ID!) {
                 externalReferenceEdit(id: $id) {
                     delete
                 }
             }
         &#34;&#34;&#34;
        self.query(query, {&#34;id&#34;: id})

    # TODO Move to Vulnerability
    def create_vulnerability_if_not_exists(
        self,
        name,
        description,
        alias=None,
        id=None,
        stix_id_key=None,
        created=None,
        modified=None,
        update=False,
    ):
        return self.vulnerability.create(
            name=name,
            description=description,
            alias=alias,
            id=id,
            stix_id_key=stix_id_key,
            created=created,
            modified=modified,
            update=update,
        )

    def resolve_role(self, relation_type, from_type, to_type):
        if from_type == &#34;stix-relation&#34;:
            from_type = &#34;stix_relation&#34;
        if to_type == &#34;stix-relation&#34;:
            to_type = &#34;stix_relation&#34;
        if relation_type == &#34;related-to&#34;:
            return {&#34;from_role&#34;: &#34;relate_from&#34;, &#34;to_role&#34;: &#34;relate_to&#34;}

        relation_type = relation_type.lower()
        from_type = from_type.lower()
        from_type = (
            &#34;observable&#34;
            if (
                (
                    ObservableTypes.has_value(from_type)
                    and (
                        relation_type == &#34;localization&#34; or relation_type == &#34;gathering&#34;
                    )
                )
                or from_type == &#34;stix-observable&#34;
            )
            else from_type
        )
        to_type = to_type.lower()
        mapping = {
            &#34;uses&#34;: {
                &#34;threat-actor&#34;: {
                    &#34;malware&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                    &#34;tool&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                    &#34;attack-pattern&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                },
                &#34;intrusion-set&#34;: {
                    &#34;malware&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                    &#34;tool&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                    &#34;attack-pattern&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                },
                &#34;campaign&#34;: {
                    &#34;malware&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                    &#34;tool&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                    &#34;attack-pattern&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                },
                &#34;incident&#34;: {
                    &#34;malware&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                    &#34;tool&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                    &#34;attack-pattern&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                },
                &#34;malware&#34;: {
                    &#34;tool&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                    &#34;attack-pattern&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                },
                &#34;tool&#34;: {&#34;attack-pattern&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;}},
            },
            &#34;variant-of&#34;: {
                &#34;malware&#34;: {
                    &#34;malware&#34;: {&#34;from_role&#34;: &#34;original&#34;, &#34;to_role&#34;: &#34;variation&#34;},
                },
                &#34;tool&#34;: {&#34;tool&#34;: {&#34;from_role&#34;: &#34;original&#34;, &#34;to_role&#34;: &#34;variation&#34;},},
            },
            &#34;targets&#34;: {
                &#34;threat-actor&#34;: {
                    &#34;identity&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;sector&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;region&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;country&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;city&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;organization&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;user&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;vulnerability&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                },
                &#34;intrusion-set&#34;: {
                    &#34;identity&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;sector&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;region&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;country&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;city&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;organization&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;user&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;vulnerability&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                },
                &#34;campaign&#34;: {
                    &#34;identity&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;sector&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;region&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;country&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;city&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;organization&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;user&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;vulnerability&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                },
                &#34;incident&#34;: {
                    &#34;identity&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;sector&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;region&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;country&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;city&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;organization&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;user&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;vulnerability&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                },
                &#34;malware&#34;: {
                    &#34;identity&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;sector&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;region&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;country&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;city&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;organization&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;user&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                    &#34;vulnerability&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                },
                &#34;attack-pattern&#34;: {
                    &#34;vulnerability&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                },
            },
            &#34;attributed-to&#34;: {
                &#34;threat-actor&#34;: {
                    &#34;identity&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                    &#34;organization&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                    &#34;user&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                },
                &#34;intrusion-set&#34;: {
                    &#34;identity&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                    &#34;threat-actor&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                },
                &#34;campaign&#34;: {
                    &#34;identity&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                    &#34;threat-actor&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                    &#34;intrusion-set&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                },
                &#34;incident&#34;: {
                    &#34;identity&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                    &#34;threat-actor&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                    &#34;intrusion-set&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                    &#34;campaign&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                },
                &#34;malware&#34;: {
                    &#34;identity&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                    &#34;threat-actor&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                },
            },
            &#34;mitigates&#34;: {
                &#34;course-of-action&#34;: {
                    &#34;attack-pattern&#34;: {&#34;from_role&#34;: &#34;mitigation&#34;, &#34;to_role&#34;: &#34;problem&#34;}
                }
            },
            &#34;localization&#34;: {
                &#34;threat-actor&#34;: {
                    &#34;region&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
                    &#34;country&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
                    &#34;city&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
                },
                &#34;observable&#34;: {
                    &#34;region&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
                    &#34;country&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
                    &#34;city&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
                },
                &#34;stix_relation&#34;: {
                    &#34;region&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
                    &#34;country&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
                    &#34;city&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
                },
                &#34;region&#34;: {&#34;region&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;}},
                &#34;country&#34;: {
                    &#34;region&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;}
                },
                &#34;city&#34;: {&#34;country&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;}},
                &#34;organization&#34;: {
                    &#34;region&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
                    &#34;country&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
                    &#34;city&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
                },
            },
            &#34;indicates&#34;: {
                &#34;indicator&#34;: {
                    &#34;threat-actor&#34;: {
                        &#34;from_role&#34;: &#34;indicator&#34;,
                        &#34;to_role&#34;: &#34;characterize&#34;,
                    },
                    &#34;intrusion-set&#34;: {
                        &#34;from_role&#34;: &#34;indicator&#34;,
                        &#34;to_role&#34;: &#34;characterize&#34;,
                    },
                    &#34;campaign&#34;: {&#34;from_role&#34;: &#34;indicator&#34;, &#34;to_role&#34;: &#34;characterize&#34;},
                    &#34;malware&#34;: {&#34;from_role&#34;: &#34;indicator&#34;, &#34;to_role&#34;: &#34;characterize&#34;},
                    &#34;tool&#34;: {&#34;from_role&#34;: &#34;indicator&#34;, &#34;to_role&#34;: &#34;characterize&#34;},
                    &#34;stix_relation&#34;: {
                        &#34;from_role&#34;: &#34;indicator&#34;,
                        &#34;to_role&#34;: &#34;characterize&#34;,
                    },
                }
            },
            &#34;gathering&#34;: {
                &#34;threat-actor&#34;: {
                    &#34;organization&#34;: {&#34;from_role&#34;: &#34;part_of&#34;, &#34;to_role&#34;: &#34;gather&#34;},
                },
                &#34;sector&#34;: {
                    &#34;sector&#34;: {&#34;from_role&#34;: &#34;part_of&#34;, &#34;to_role&#34;: &#34;gather&#34;},
                    &#34;organization&#34;: {&#34;from_role&#34;: &#34;part_of&#34;, &#34;to_role&#34;: &#34;gather&#34;},
                },
                &#34;organization&#34;: {
                    &#34;sector&#34;: {&#34;from_role&#34;: &#34;part_of&#34;, &#34;to_role&#34;: &#34;gather&#34;},
                    &#34;organization&#34;: {&#34;from_role&#34;: &#34;part_of&#34;, &#34;to_role&#34;: &#34;gather&#34;},
                },
                &#34;user&#34;: {
                    &#34;organization&#34;: {&#34;from_role&#34;: &#34;part_of&#34;, &#34;to_role&#34;: &#34;gather&#34;},
                },
                &#34;observable&#34;: {
                    &#34;organization&#34;: {&#34;from_role&#34;: &#34;part_of&#34;, &#34;to_role&#34;: &#34;gather&#34;},
                    &#34;user&#34;: {&#34;from_role&#34;: &#34;part_of&#34;, &#34;to_role&#34;: &#34;gather&#34;},
                },
            },
            &#34;drops&#34;: {
                &#34;malware&#34;: {
                    &#34;malware&#34;: {&#34;from_role&#34;: &#34;dropping&#34;, &#34;to_role&#34;: &#34;dropped&#34;},
                    &#34;tool&#34;: {&#34;from_role&#34;: &#34;dropping&#34;, &#34;to_role&#34;: &#34;dropped&#34;},
                },
                &#34;tool&#34;: {
                    &#34;malware&#34;: {&#34;from_role&#34;: &#34;dropping&#34;, &#34;to_role&#34;: &#34;dropped&#34;},
                    &#34;tool&#34;: {&#34;from_role&#34;: &#34;dropping&#34;, &#34;to_role&#34;: &#34;dropped&#34;},
                },
            },
            &#34;belongs&#34;: {
                &#34;ipv4-addr&#34;: {
                    &#34;autonomous-system&#34;: {
                        &#34;from_role&#34;: &#34;belonging_to&#34;,
                        &#34;to_role&#34;: &#34;belonged_to&#34;,
                    }
                },
                &#34;ipv6-addr&#34;: {
                    &#34;autonomous-system&#34;: {
                        &#34;from_role&#34;: &#34;belonging_to&#34;,
                        &#34;to_role&#34;: &#34;belonged_to&#34;,
                    }
                },
            },
            &#34;resolves&#34;: {
                &#34;ipv4-addr&#34;: {
                    &#34;domain&#34;: {&#34;from_role&#34;: &#34;resolving&#34;, &#34;to_role&#34;: &#34;resolved&#34;,}
                },
                &#34;ipv6-addr&#34;: {
                    &#34;domain&#34;: {&#34;from_role&#34;: &#34;resolving&#34;, &#34;to_role&#34;: &#34;resolved&#34;,}
                },
            },
            &#34;corresponds&#34;: {
                &#34;file-name&#34;: {
                    &#34;file-md5&#34;: {
                        &#34;from_role&#34;: &#34;correspond_from&#34;,
                        &#34;to_role&#34;: &#34;correspond_to&#34;,
                    },
                    &#34;file-sha1&#34;: {
                        &#34;from_role&#34;: &#34;correspond_from&#34;,
                        &#34;to_role&#34;: &#34;correspond_to&#34;,
                    },
                    &#34;file-sha256&#34;: {
                        &#34;from_role&#34;: &#34;correspond_from&#34;,
                        &#34;to_role&#34;: &#34;correspond_to&#34;,
                    },
                },
                &#34;file-md5&#34;: {
                    &#34;file-name&#34;: {
                        &#34;from_role&#34;: &#34;correspond_from&#34;,
                        &#34;to_role&#34;: &#34;correspond_to&#34;,
                    },
                    &#34;file-sha1&#34;: {
                        &#34;from_role&#34;: &#34;correspond_from&#34;,
                        &#34;to_role&#34;: &#34;correspond_to&#34;,
                    },
                    &#34;file-sha256&#34;: {
                        &#34;from_role&#34;: &#34;correspond_from&#34;,
                        &#34;to_role&#34;: &#34;correspond_to&#34;,
                    },
                },
                &#34;file-sha1&#34;: {
                    &#34;file-name&#34;: {
                        &#34;from_role&#34;: &#34;correspond_from&#34;,
                        &#34;to_role&#34;: &#34;correspond_to&#34;,
                    },
                    &#34;file-md5&#34;: {
                        &#34;from_role&#34;: &#34;correspond_from&#34;,
                        &#34;to_role&#34;: &#34;correspond_to&#34;,
                    },
                    &#34;file-sha256&#34;: {
                        &#34;from_role&#34;: &#34;correspond_from&#34;,
                        &#34;to_role&#34;: &#34;correspond_to&#34;,
                    },
                },
                &#34;file-sha256&#34;: {
                    &#34;file-name&#34;: {
                        &#34;from_role&#34;: &#34;correspond_from&#34;,
                        &#34;to_role&#34;: &#34;correspond_to&#34;,
                    },
                    &#34;file-md5&#34;: {
                        &#34;from_role&#34;: &#34;correspond_from&#34;,
                        &#34;to_role&#34;: &#34;correspond_to&#34;,
                    },
                    &#34;file-sha1&#34;: {
                        &#34;from_role&#34;: &#34;correspond_from&#34;,
                        &#34;to_role&#34;: &#34;correspond_to&#34;,
                    },
                },
            },
        }
        if (
            relation_type in mapping
            and from_type in mapping[relation_type]
            and to_type in mapping[relation_type][from_type]
        ):
            return mapping[relation_type][from_type][to_type]
        else:
            return None</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pycti.OpenCTIApiClient.create_vulnerability_if_not_exists"><code class="name flex">
<span>def <span class="ident">create_vulnerability_if_not_exists</span></span>(<span>self, name, description, alias=None, id=None, stix_id_key=None, created=None, modified=None, update=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_vulnerability_if_not_exists(
    self,
    name,
    description,
    alias=None,
    id=None,
    stix_id_key=None,
    created=None,
    modified=None,
    update=False,
):
    return self.vulnerability.create(
        name=name,
        description=description,
        alias=alias,
        id=id,
        stix_id_key=stix_id_key,
        created=created,
        modified=modified,
        update=update,
    )</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIApiClient.delete_external_reference"><code class="name flex">
<span>def <span class="ident">delete_external_reference</span></span>(<span>self, id)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_external_reference(self, id):
    logging.info(&#34;Deleting + &#34; + id + &#34;...&#34;)
    query = &#34;&#34;&#34;
         mutation ExternalReferenceEdit($id: ID!) {
             externalReferenceEdit(id: $id) {
                 delete
             }
         }
     &#34;&#34;&#34;
    self.query(query, {&#34;id&#34;: id})</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIApiClient.fetch_opencti_file"><code class="name flex">
<span>def <span class="ident">fetch_opencti_file</span></span>(<span>self, fetch_uri, binary=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fetch_opencti_file(self, fetch_uri, binary=False):
    r = requests.get(fetch_uri, headers=self.request_headers)
    if binary:
        return r.content
    return r.text</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIApiClient.health_check"><code class="name flex">
<span>def <span class="ident">health_check</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def health_check(self):
    try:
        test = self.threat_actor.list(first=1)
        if test is not None:
            return True
    except:
        return False
    return False</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIApiClient.log"><code class="name flex">
<span>def <span class="ident">log</span></span>(<span>self, level, message)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log(self, level, message):
    if level == &#34;debug&#34;:
        logging.debug(message)
    elif level == &#34;info&#34;:
        logging.info(message)
    elif level == &#34;warning&#34;:
        logging.warn(message)
    elif level == &#34;error&#34;:
        logging.error(message)</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIApiClient.not_empty"><code class="name flex">
<span>def <span class="ident">not_empty</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def not_empty(self, value):
    if value is not None:
        if isinstance(value, str):
            if len(value) &gt; 0:
                return True
            else:
                return False
        if isinstance(value, list):
            is_not_empty = False
            for v in value:
                if len(v) &gt; 0:
                    is_not_empty = True
            return is_not_empty
        if isinstance(value, int):
            return True
        else:
            return False
    else:
        return False</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIApiClient.process_multiple"><code class="name flex">
<span>def <span class="ident">process_multiple</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_multiple(self, data):
    result = []
    if data is None:
        return result
    for edge in (
        data[&#34;edges&#34;] if &#34;edges&#34; in data and data[&#34;edges&#34;] is not None else []
    ):
        row = edge[&#34;node&#34;]
        # Handle remote relation ID
        if (
            &#34;relation&#34; in edge
            and edge[&#34;relation&#34;] is not None
            and &#34;id&#34; in edge[&#34;relation&#34;]
        ):
            row[&#34;remote_relation_id&#34;] = edge[&#34;relation&#34;][&#34;id&#34;]
        result.append(self.process_multiple_fields(row))
    return result</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIApiClient.process_multiple_fields"><code class="name flex">
<span>def <span class="ident">process_multiple_fields</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_multiple_fields(self, data):
    if data is None:
        return data
    if (
        &#34;createdByRef&#34; in data
        and data[&#34;createdByRef&#34;] is not None
        and &#34;node&#34; in data[&#34;createdByRef&#34;]
    ):
        row = data[&#34;createdByRef&#34;][&#34;node&#34;]
        # Handle remote relation ID
        if &#34;relation&#34; in data[&#34;createdByRef&#34;]:
            row[&#34;remote_relation_id&#34;] = data[&#34;createdByRef&#34;][&#34;relation&#34;][&#34;id&#34;]
        data[&#34;createdByRef&#34;] = row
    else:
        data[&#34;createdByRef&#34;] = None
    if &#34;markingDefinitions&#34; in data:
        data[&#34;markingDefinitions&#34;] = self.process_multiple(
            data[&#34;markingDefinitions&#34;]
        )
        data[&#34;markingDefinitionsIds&#34;] = self.process_multiple_ids(
            data[&#34;markingDefinitions&#34;]
        )
    if &#34;tags&#34; in data:
        data[&#34;tags&#34;] = self.process_multiple(data[&#34;tags&#34;])
        data[&#34;tagsIds&#34;] = self.process_multiple_ids(data[&#34;tags&#34;])
    if &#34;reports&#34; in data:
        data[&#34;reports&#34;] = self.process_multiple(data[&#34;reports&#34;])
        data[&#34;reportsIds&#34;] = self.process_multiple_ids(data[&#34;reports&#34;])
    if &#34;killChainPhases&#34; in data:
        data[&#34;killChainPhases&#34;] = self.process_multiple(data[&#34;killChainPhases&#34;])
        data[&#34;killChainPhasesIds&#34;] = self.process_multiple_ids(
            data[&#34;killChainPhases&#34;]
        )
    if &#34;externalReferences&#34; in data:
        data[&#34;externalReferences&#34;] = self.process_multiple(
            data[&#34;externalReferences&#34;]
        )
        data[&#34;externalReferencesIds&#34;] = self.process_multiple_ids(
            data[&#34;externalReferences&#34;]
        )
    if &#34;objectRefs&#34; in data:
        data[&#34;objectRefs&#34;] = self.process_multiple(data[&#34;objectRefs&#34;])
        data[&#34;objectRefsIds&#34;] = self.process_multiple_ids(data[&#34;objectRefs&#34;])
    if &#34;observableRefs&#34; in data:
        data[&#34;observableRefs&#34;] = self.process_multiple(data[&#34;observableRefs&#34;])
        data[&#34;observableRefsIds&#34;] = self.process_multiple_ids(
            data[&#34;observableRefs&#34;]
        )
    if &#34;relationRefs&#34; in data:
        data[&#34;relationRefs&#34;] = self.process_multiple(data[&#34;relationRefs&#34;])
        data[&#34;relationRefsIds&#34;] = self.process_multiple_ids(data[&#34;relationRefs&#34;])
    if &#34;stixRelations&#34; in data:
        data[&#34;stixRelations&#34;] = self.process_multiple(data[&#34;stixRelations&#34;])
        data[&#34;stixRelationsIds&#34;] = self.process_multiple_ids(data[&#34;stixRelations&#34;])
    if &#34;indicators&#34; in data:
        data[&#34;indicators&#34;] = self.process_multiple(data[&#34;indicators&#34;])
        data[&#34;indicatorsIds&#34;] = self.process_multiple_ids(data[&#34;indicators&#34;])
    if &#34;importFiles&#34; in data:
        data[&#34;importFiles&#34;] = self.process_multiple(data[&#34;importFiles&#34;])
        data[&#34;importFilesIds&#34;] = self.process_multiple_ids(data[&#34;importFiles&#34;])
    return data</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIApiClient.process_multiple_ids"><code class="name flex">
<span>def <span class="ident">process_multiple_ids</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_multiple_ids(self, data):
    result = []
    if data is None:
        return result
    if isinstance(data, list):
        for d in data:
            if isinstance(d, dict) and &#34;id&#34; in d:
                result.append(d[&#34;id&#34;])
    return result</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIApiClient.query"><code class="name flex">
<span>def <span class="ident">query</span></span>(<span>self, query, variables={})</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def query(self, query, variables={}):
    query_var = {}
    files_vars = []
    # Implementation of spec https://github.com/jaydenseric/graphql-multipart-request-spec
    # Support for single or multiple upload
    # Batching or mixed upload or not supported
    var_keys = variables.keys()
    for key in var_keys:
        val = variables[key]
        is_file = type(val) is File
        is_files = (
            isinstance(val, list)
            and len(val) &gt; 0
            and all(map(lambda x: isinstance(x, File), val))
        )
        if is_file or is_files:
            files_vars.append({&#34;key&#34;: key, &#34;file&#34;: val, &#34;multiple&#34;: is_files})
            query_var[key] = None if is_file else [None] * len(val)
        else:
            query_var[key] = val

    # If yes, transform variable (file to null) and create multipart query
    if len(files_vars) &gt; 0:
        multipart_data = {
            &#34;operations&#34;: json.dumps({&#34;query&#34;: query, &#34;variables&#34;: query_var})
        }
        # Build the multipart map
        map_index = 0
        file_vars = {}
        for file_var_item in files_vars:
            is_multiple_files = file_var_item[&#34;multiple&#34;]
            var_name = &#34;variables.&#34; + file_var_item[&#34;key&#34;]
            if is_multiple_files:
                # [(var_name + &#34;.&#34; + i)] if is_multiple_files else
                for _ in file_var_item[&#34;file&#34;]:
                    file_vars[str(map_index)] = [(var_name + &#34;.&#34; + str(map_index))]
                    map_index += 1
            else:
                file_vars[str(map_index)] = [var_name]
                map_index += 1
        multipart_data[&#34;map&#34;] = json.dumps(file_vars)
        # Add the files
        file_index = 0
        multipart_files = []
        for file_var_item in files_vars:
            files = file_var_item[&#34;file&#34;]
            is_multiple_files = file_var_item[&#34;multiple&#34;]
            if is_multiple_files:
                for file in files:
                    if isinstance(file.data, str):
                        file_multi = (
                            str(file_index),
                            (file.name, io.BytesIO(file.data.encode()), file.mime,),
                        )
                    else:
                        file_multi = (
                            str(file_index),
                            (file.name, file.data, file.mime),
                        )
                    multipart_files.append(file_multi)
                    file_index += 1
            else:
                if isinstance(files.data, str):
                    file_multi = (
                        str(file_index),
                        (files.name, io.BytesIO(files.data.encode()), files.mime),
                    )
                else:
                    file_multi = (
                        str(file_index),
                        (files.name, files.data, files.mime),
                    )
                multipart_files.append(file_multi)
                file_index += 1
        # Send the multipart request
        r = requests.post(
            self.api_url,
            data=multipart_data,
            files=multipart_files,
            headers=self.request_headers,
            verify=self.ssl_verify,
        )
    # If no
    else:
        r = requests.post(
            self.api_url,
            json={&#34;query&#34;: query, &#34;variables&#34;: variables},
            headers=self.request_headers,
            verify=self.ssl_verify,
        )
    # Build response
    if r.status_code == requests.codes.ok:
        result = r.json()
        if &#34;errors&#34; in result:
            logging.error(result[&#34;errors&#34;][0][&#34;message&#34;])
        else:
            return result
    else:
        logging.info(r.text)</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIApiClient.resolve_role"><code class="name flex">
<span>def <span class="ident">resolve_role</span></span>(<span>self, relation_type, from_type, to_type)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resolve_role(self, relation_type, from_type, to_type):
    if from_type == &#34;stix-relation&#34;:
        from_type = &#34;stix_relation&#34;
    if to_type == &#34;stix-relation&#34;:
        to_type = &#34;stix_relation&#34;
    if relation_type == &#34;related-to&#34;:
        return {&#34;from_role&#34;: &#34;relate_from&#34;, &#34;to_role&#34;: &#34;relate_to&#34;}

    relation_type = relation_type.lower()
    from_type = from_type.lower()
    from_type = (
        &#34;observable&#34;
        if (
            (
                ObservableTypes.has_value(from_type)
                and (
                    relation_type == &#34;localization&#34; or relation_type == &#34;gathering&#34;
                )
            )
            or from_type == &#34;stix-observable&#34;
        )
        else from_type
    )
    to_type = to_type.lower()
    mapping = {
        &#34;uses&#34;: {
            &#34;threat-actor&#34;: {
                &#34;malware&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                &#34;tool&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                &#34;attack-pattern&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
            },
            &#34;intrusion-set&#34;: {
                &#34;malware&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                &#34;tool&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                &#34;attack-pattern&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
            },
            &#34;campaign&#34;: {
                &#34;malware&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                &#34;tool&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                &#34;attack-pattern&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
            },
            &#34;incident&#34;: {
                &#34;malware&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                &#34;tool&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                &#34;attack-pattern&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
            },
            &#34;malware&#34;: {
                &#34;tool&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
                &#34;attack-pattern&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;},
            },
            &#34;tool&#34;: {&#34;attack-pattern&#34;: {&#34;from_role&#34;: &#34;user&#34;, &#34;to_role&#34;: &#34;usage&#34;}},
        },
        &#34;variant-of&#34;: {
            &#34;malware&#34;: {
                &#34;malware&#34;: {&#34;from_role&#34;: &#34;original&#34;, &#34;to_role&#34;: &#34;variation&#34;},
            },
            &#34;tool&#34;: {&#34;tool&#34;: {&#34;from_role&#34;: &#34;original&#34;, &#34;to_role&#34;: &#34;variation&#34;},},
        },
        &#34;targets&#34;: {
            &#34;threat-actor&#34;: {
                &#34;identity&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;sector&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;region&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;country&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;city&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;organization&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;user&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;vulnerability&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
            },
            &#34;intrusion-set&#34;: {
                &#34;identity&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;sector&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;region&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;country&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;city&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;organization&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;user&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;vulnerability&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
            },
            &#34;campaign&#34;: {
                &#34;identity&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;sector&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;region&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;country&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;city&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;organization&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;user&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;vulnerability&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
            },
            &#34;incident&#34;: {
                &#34;identity&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;sector&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;region&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;country&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;city&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;organization&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;user&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;vulnerability&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
            },
            &#34;malware&#34;: {
                &#34;identity&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;sector&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;region&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;country&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;city&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;organization&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;user&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
                &#34;vulnerability&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
            },
            &#34;attack-pattern&#34;: {
                &#34;vulnerability&#34;: {&#34;from_role&#34;: &#34;source&#34;, &#34;to_role&#34;: &#34;target&#34;},
            },
        },
        &#34;attributed-to&#34;: {
            &#34;threat-actor&#34;: {
                &#34;identity&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                &#34;organization&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                &#34;user&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
            },
            &#34;intrusion-set&#34;: {
                &#34;identity&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                &#34;threat-actor&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
            },
            &#34;campaign&#34;: {
                &#34;identity&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                &#34;threat-actor&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                &#34;intrusion-set&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
            },
            &#34;incident&#34;: {
                &#34;identity&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                &#34;threat-actor&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                &#34;intrusion-set&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                &#34;campaign&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
            },
            &#34;malware&#34;: {
                &#34;identity&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
                &#34;threat-actor&#34;: {&#34;from_role&#34;: &#34;attribution&#34;, &#34;to_role&#34;: &#34;origin&#34;},
            },
        },
        &#34;mitigates&#34;: {
            &#34;course-of-action&#34;: {
                &#34;attack-pattern&#34;: {&#34;from_role&#34;: &#34;mitigation&#34;, &#34;to_role&#34;: &#34;problem&#34;}
            }
        },
        &#34;localization&#34;: {
            &#34;threat-actor&#34;: {
                &#34;region&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
                &#34;country&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
                &#34;city&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
            },
            &#34;observable&#34;: {
                &#34;region&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
                &#34;country&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
                &#34;city&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
            },
            &#34;stix_relation&#34;: {
                &#34;region&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
                &#34;country&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
                &#34;city&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
            },
            &#34;region&#34;: {&#34;region&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;}},
            &#34;country&#34;: {
                &#34;region&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;}
            },
            &#34;city&#34;: {&#34;country&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;}},
            &#34;organization&#34;: {
                &#34;region&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
                &#34;country&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
                &#34;city&#34;: {&#34;from_role&#34;: &#34;localized&#34;, &#34;to_role&#34;: &#34;location&#34;},
            },
        },
        &#34;indicates&#34;: {
            &#34;indicator&#34;: {
                &#34;threat-actor&#34;: {
                    &#34;from_role&#34;: &#34;indicator&#34;,
                    &#34;to_role&#34;: &#34;characterize&#34;,
                },
                &#34;intrusion-set&#34;: {
                    &#34;from_role&#34;: &#34;indicator&#34;,
                    &#34;to_role&#34;: &#34;characterize&#34;,
                },
                &#34;campaign&#34;: {&#34;from_role&#34;: &#34;indicator&#34;, &#34;to_role&#34;: &#34;characterize&#34;},
                &#34;malware&#34;: {&#34;from_role&#34;: &#34;indicator&#34;, &#34;to_role&#34;: &#34;characterize&#34;},
                &#34;tool&#34;: {&#34;from_role&#34;: &#34;indicator&#34;, &#34;to_role&#34;: &#34;characterize&#34;},
                &#34;stix_relation&#34;: {
                    &#34;from_role&#34;: &#34;indicator&#34;,
                    &#34;to_role&#34;: &#34;characterize&#34;,
                },
            }
        },
        &#34;gathering&#34;: {
            &#34;threat-actor&#34;: {
                &#34;organization&#34;: {&#34;from_role&#34;: &#34;part_of&#34;, &#34;to_role&#34;: &#34;gather&#34;},
            },
            &#34;sector&#34;: {
                &#34;sector&#34;: {&#34;from_role&#34;: &#34;part_of&#34;, &#34;to_role&#34;: &#34;gather&#34;},
                &#34;organization&#34;: {&#34;from_role&#34;: &#34;part_of&#34;, &#34;to_role&#34;: &#34;gather&#34;},
            },
            &#34;organization&#34;: {
                &#34;sector&#34;: {&#34;from_role&#34;: &#34;part_of&#34;, &#34;to_role&#34;: &#34;gather&#34;},
                &#34;organization&#34;: {&#34;from_role&#34;: &#34;part_of&#34;, &#34;to_role&#34;: &#34;gather&#34;},
            },
            &#34;user&#34;: {
                &#34;organization&#34;: {&#34;from_role&#34;: &#34;part_of&#34;, &#34;to_role&#34;: &#34;gather&#34;},
            },
            &#34;observable&#34;: {
                &#34;organization&#34;: {&#34;from_role&#34;: &#34;part_of&#34;, &#34;to_role&#34;: &#34;gather&#34;},
                &#34;user&#34;: {&#34;from_role&#34;: &#34;part_of&#34;, &#34;to_role&#34;: &#34;gather&#34;},
            },
        },
        &#34;drops&#34;: {
            &#34;malware&#34;: {
                &#34;malware&#34;: {&#34;from_role&#34;: &#34;dropping&#34;, &#34;to_role&#34;: &#34;dropped&#34;},
                &#34;tool&#34;: {&#34;from_role&#34;: &#34;dropping&#34;, &#34;to_role&#34;: &#34;dropped&#34;},
            },
            &#34;tool&#34;: {
                &#34;malware&#34;: {&#34;from_role&#34;: &#34;dropping&#34;, &#34;to_role&#34;: &#34;dropped&#34;},
                &#34;tool&#34;: {&#34;from_role&#34;: &#34;dropping&#34;, &#34;to_role&#34;: &#34;dropped&#34;},
            },
        },
        &#34;belongs&#34;: {
            &#34;ipv4-addr&#34;: {
                &#34;autonomous-system&#34;: {
                    &#34;from_role&#34;: &#34;belonging_to&#34;,
                    &#34;to_role&#34;: &#34;belonged_to&#34;,
                }
            },
            &#34;ipv6-addr&#34;: {
                &#34;autonomous-system&#34;: {
                    &#34;from_role&#34;: &#34;belonging_to&#34;,
                    &#34;to_role&#34;: &#34;belonged_to&#34;,
                }
            },
        },
        &#34;resolves&#34;: {
            &#34;ipv4-addr&#34;: {
                &#34;domain&#34;: {&#34;from_role&#34;: &#34;resolving&#34;, &#34;to_role&#34;: &#34;resolved&#34;,}
            },
            &#34;ipv6-addr&#34;: {
                &#34;domain&#34;: {&#34;from_role&#34;: &#34;resolving&#34;, &#34;to_role&#34;: &#34;resolved&#34;,}
            },
        },
        &#34;corresponds&#34;: {
            &#34;file-name&#34;: {
                &#34;file-md5&#34;: {
                    &#34;from_role&#34;: &#34;correspond_from&#34;,
                    &#34;to_role&#34;: &#34;correspond_to&#34;,
                },
                &#34;file-sha1&#34;: {
                    &#34;from_role&#34;: &#34;correspond_from&#34;,
                    &#34;to_role&#34;: &#34;correspond_to&#34;,
                },
                &#34;file-sha256&#34;: {
                    &#34;from_role&#34;: &#34;correspond_from&#34;,
                    &#34;to_role&#34;: &#34;correspond_to&#34;,
                },
            },
            &#34;file-md5&#34;: {
                &#34;file-name&#34;: {
                    &#34;from_role&#34;: &#34;correspond_from&#34;,
                    &#34;to_role&#34;: &#34;correspond_to&#34;,
                },
                &#34;file-sha1&#34;: {
                    &#34;from_role&#34;: &#34;correspond_from&#34;,
                    &#34;to_role&#34;: &#34;correspond_to&#34;,
                },
                &#34;file-sha256&#34;: {
                    &#34;from_role&#34;: &#34;correspond_from&#34;,
                    &#34;to_role&#34;: &#34;correspond_to&#34;,
                },
            },
            &#34;file-sha1&#34;: {
                &#34;file-name&#34;: {
                    &#34;from_role&#34;: &#34;correspond_from&#34;,
                    &#34;to_role&#34;: &#34;correspond_to&#34;,
                },
                &#34;file-md5&#34;: {
                    &#34;from_role&#34;: &#34;correspond_from&#34;,
                    &#34;to_role&#34;: &#34;correspond_to&#34;,
                },
                &#34;file-sha256&#34;: {
                    &#34;from_role&#34;: &#34;correspond_from&#34;,
                    &#34;to_role&#34;: &#34;correspond_to&#34;,
                },
            },
            &#34;file-sha256&#34;: {
                &#34;file-name&#34;: {
                    &#34;from_role&#34;: &#34;correspond_from&#34;,
                    &#34;to_role&#34;: &#34;correspond_to&#34;,
                },
                &#34;file-md5&#34;: {
                    &#34;from_role&#34;: &#34;correspond_from&#34;,
                    &#34;to_role&#34;: &#34;correspond_to&#34;,
                },
                &#34;file-sha1&#34;: {
                    &#34;from_role&#34;: &#34;correspond_from&#34;,
                    &#34;to_role&#34;: &#34;correspond_to&#34;,
                },
            },
        },
    }
    if (
        relation_type in mapping
        and from_type in mapping[relation_type]
        and to_type in mapping[relation_type][from_type]
    ):
        return mapping[relation_type][from_type][to_type]
    else:
        return None</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIApiClient.update_stix_observable_field"><code class="name flex">
<span>def <span class="ident">update_stix_observable_field</span></span>(<span>self, id, key, value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_stix_observable_field(self, id, key, value):
    logging.info(&#34;Updating field &#34; + key + &#34; of &#34; + id + &#34;...&#34;)
    query = &#34;&#34;&#34;
        mutation StixObservableEdit($id: ID!, $input: EditInput!) {
            stixObservableEdit(id: $id) {
                fieldPatch(input: $input) {
                    id
                    observable_value
                    entity_type
                }
            }
        }
    &#34;&#34;&#34;
    self.query(query, {&#34;id&#34;: id, &#34;input&#34;: {&#34;key&#34;: key, &#34;value&#34;: value}})</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIApiClient.upload_file"><code class="name flex">
<span>def <span class="ident">upload_file</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def upload_file(self, **kwargs):
    file_name = kwargs.get(&#34;file_name&#34;, None)
    data = kwargs.get(&#34;data&#34;, None)
    mime_type = kwargs.get(&#34;mime_type&#34;, &#34;text/plain&#34;)
    if file_name is not None:
        self.log(&#34;info&#34;, &#34;Uploading a file.&#34;)
        query = &#34;&#34;&#34;
            mutation UploadImport($file: Upload!) {
                uploadImport(file: $file) {
                    id
                    name
                }
            }
         &#34;&#34;&#34;
        if data is None:
            data = open(file_name, &#34;rb&#34;)
            mime_type = magic.from_file(file_name, mime=True)

        return self.query(query, {&#34;file&#34;: (File(file_name, data, mime_type))})
    else:
        self.log(
            &#34;error&#34;, &#34;[upload] Missing parameters: file_name or data&#34;,
        )
        return None</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pycti.OpenCTIApiConnector"><code class="flex name class">
<span>class <span class="ident">OpenCTIApiConnector</span></span>
<span>(</span><span>api)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OpenCTIApiConnector:
    def __init__(self, api):
        self.api = api

    def list(self):
        logging.info(&#34;Getting connectors ...&#34;)
        query = &#34;&#34;&#34;
            query GetConnectors {
                connectors {
                    id
                    name
                    config {
                        uri
                        listen
                        push
                    }
                }
            }
        &#34;&#34;&#34;
        result = self.api.query(query)
        return result[&#34;data&#34;][&#34;connectors&#34;]

    def ping(self, connector_id: str, connector_state) -&gt; None:
        query = &#34;&#34;&#34;
            mutation PingConnector($id: ID!, $state: String) {
                pingConnector(id: $id, state: $state) {
                    id
                    connector_state
                }
            }
           &#34;&#34;&#34;
        result = self.api.query(
            query, {&#34;id&#34;: connector_id, &#34;state&#34;: json.dumps(connector_state)}
        )
        return result[&#34;data&#34;][&#34;pingConnector&#34;]

    def register(self, connector: OpenCTIConnector):
        query = &#34;&#34;&#34;
            mutation RegisterConnector($input: RegisterConnectorInput) {
                registerConnector(input: $input) {
                    id
                    connector_state
                    config {
                        uri
                        listen
                        listen_exchange
                        push
                        push_exchange
                    }
                }
            }
           &#34;&#34;&#34;
        result = self.api.query(query, connector.to_input())
        return result[&#34;data&#34;][&#34;registerConnector&#34;]</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pycti.OpenCTIApiConnector.list"><code class="name flex">
<span>def <span class="ident">list</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list(self):
    logging.info(&#34;Getting connectors ...&#34;)
    query = &#34;&#34;&#34;
        query GetConnectors {
            connectors {
                id
                name
                config {
                    uri
                    listen
                    push
                }
            }
        }
    &#34;&#34;&#34;
    result = self.api.query(query)
    return result[&#34;data&#34;][&#34;connectors&#34;]</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIApiConnector.ping"><code class="name flex">
<span>def <span class="ident">ping</span></span>(<span>self, connector_id:str, connector_state) ->NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ping(self, connector_id: str, connector_state) -&gt; None:
    query = &#34;&#34;&#34;
        mutation PingConnector($id: ID!, $state: String) {
            pingConnector(id: $id, state: $state) {
                id
                connector_state
            }
        }
       &#34;&#34;&#34;
    result = self.api.query(
        query, {&#34;id&#34;: connector_id, &#34;state&#34;: json.dumps(connector_state)}
    )
    return result[&#34;data&#34;][&#34;pingConnector&#34;]</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIApiConnector.register"><code class="name flex">
<span>def <span class="ident">register</span></span>(<span>self, connector:<a title="pycti.connector.opencti_connector.OpenCTIConnector" href="connector/opencti_connector.html#pycti.connector.opencti_connector.OpenCTIConnector">OpenCTIConnector</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register(self, connector: OpenCTIConnector):
    query = &#34;&#34;&#34;
        mutation RegisterConnector($input: RegisterConnectorInput) {
            registerConnector(input: $input) {
                id
                connector_state
                config {
                    uri
                    listen
                    listen_exchange
                    push
                    push_exchange
                }
            }
        }
       &#34;&#34;&#34;
    result = self.api.query(query, connector.to_input())
    return result[&#34;data&#34;][&#34;registerConnector&#34;]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pycti.OpenCTIApiJob"><code class="flex name class">
<span>class <span class="ident">OpenCTIApiJob</span></span>
<span>(</span><span>api)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OpenCTIApiJob:
    def __init__(self, api):
        self.api = api

    def update_job(self, job_id: str, status: str, messages: [str]):
        logging.info(&#34;Reporting job &#34; + job_id + &#34; with status &#34; + status + &#34;...&#34;)
        query = &#34;&#34;&#34;
            mutation UpdateJob($id: ID!, $status: Status!, $messages: [String]) {
                updateJob(jobId: $id, status: $status, messages: $messages) {
                    internal_id_key
                }
            }
           &#34;&#34;&#34;
        result = self.api.query(
            query, {&#34;id&#34;: job_id, &#34;status&#34;: status, &#34;messages&#34;: messages}
        )
        return result[&#34;data&#34;][&#34;updateJob&#34;][&#34;internal_id_key&#34;]

    def initiate_job(self, work_id: str):
        logging.info(&#34;Creating new job on work &#34; + work_id)
        query = &#34;&#34;&#34;
            mutation InitiateJob($id: ID!) {
                initiateJob(workId: $id) {
                    internal_id_key
                }
            }
           &#34;&#34;&#34;
        result = self.api.query(query, {&#34;id&#34;: work_id})
        return result[&#34;data&#34;][&#34;initiateJob&#34;][&#34;internal_id_key&#34;]</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pycti.OpenCTIApiJob.initiate_job"><code class="name flex">
<span>def <span class="ident">initiate_job</span></span>(<span>self, work_id:str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initiate_job(self, work_id: str):
    logging.info(&#34;Creating new job on work &#34; + work_id)
    query = &#34;&#34;&#34;
        mutation InitiateJob($id: ID!) {
            initiateJob(workId: $id) {
                internal_id_key
            }
        }
       &#34;&#34;&#34;
    result = self.api.query(query, {&#34;id&#34;: work_id})
    return result[&#34;data&#34;][&#34;initiateJob&#34;][&#34;internal_id_key&#34;]</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIApiJob.update_job"><code class="name flex">
<span>def <span class="ident">update_job</span></span>(<span>self, job_id:str, status:str, messages:[<class'str'>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_job(self, job_id: str, status: str, messages: [str]):
    logging.info(&#34;Reporting job &#34; + job_id + &#34; with status &#34; + status + &#34;...&#34;)
    query = &#34;&#34;&#34;
        mutation UpdateJob($id: ID!, $status: Status!, $messages: [String]) {
            updateJob(jobId: $id, status: $status, messages: $messages) {
                internal_id_key
            }
        }
       &#34;&#34;&#34;
    result = self.api.query(
        query, {&#34;id&#34;: job_id, &#34;status&#34;: status, &#34;messages&#34;: messages}
    )
    return result[&#34;data&#34;][&#34;updateJob&#34;][&#34;internal_id_key&#34;]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pycti.OpenCTIConnector"><code class="flex name class">
<span>class <span class="ident">OpenCTIConnector</span></span>
<span>(</span><span>connector_id:str, connector_name:str, connector_type:str, scope:str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OpenCTIConnector:
    def __init__(
        self, connector_id: str, connector_name: str, connector_type: str, scope: str
    ):
        self.id = connector_id
        self.name = connector_name
        self.type = ConnectorType(connector_type)
        if self.type is None:
            raise ValueError(&#34;Invalid connector type: &#34; + connector_type)
        self.scope = scope.split(&#34;,&#34;)

    def to_input(self):
        return {
            &#34;input&#34;: {
                &#34;id&#34;: self.id,
                &#34;name&#34;: self.name,
                &#34;type&#34;: self.type.name,
                &#34;scope&#34;: self.scope,
            }
        }</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pycti.OpenCTIConnector.to_input"><code class="name flex">
<span>def <span class="ident">to_input</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_input(self):
    return {
        &#34;input&#34;: {
            &#34;id&#34;: self.id,
            &#34;name&#34;: self.name,
            &#34;type&#34;: self.type.name,
            &#34;scope&#34;: self.scope,
        }
    }</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pycti.OpenCTIConnectorHelper"><code class="flex name class">
<span>class <span class="ident">OpenCTIConnectorHelper</span></span>
<span>(</span><span>config:dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Python API for OpenCTI connector
:param config: Dict standard config</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OpenCTIConnectorHelper:
    &#34;&#34;&#34;
        Python API for OpenCTI connector
        :param config: Dict standard config
    &#34;&#34;&#34;

    def __init__(self, config: dict):
        # Load API config
        self.opencti_url = get_config_variable(
            &#34;OPENCTI_URL&#34;, [&#34;opencti&#34;, &#34;url&#34;], config
        )
        self.opencti_token = get_config_variable(
            &#34;OPENCTI_TOKEN&#34;, [&#34;opencti&#34;, &#34;token&#34;], config
        )
        # Load connector config
        self.connect_id = get_config_variable(
            &#34;CONNECTOR_ID&#34;, [&#34;connector&#34;, &#34;id&#34;], config
        )
        self.connect_type = get_config_variable(
            &#34;CONNECTOR_TYPE&#34;, [&#34;connector&#34;, &#34;type&#34;], config
        )
        self.connect_name = get_config_variable(
            &#34;CONNECTOR_NAME&#34;, [&#34;connector&#34;, &#34;name&#34;], config
        )
        self.connect_confidence_level = get_config_variable(
            &#34;CONNECTOR_CONFIDENCE_LEVEL&#34;,
            [&#34;connector&#34;, &#34;confidence_level&#34;],
            config,
            True,
        )
        self.connect_scope = get_config_variable(
            &#34;CONNECTOR_SCOPE&#34;, [&#34;connector&#34;, &#34;scope&#34;], config
        )
        self.log_level = get_config_variable(
            &#34;CONNECTOR_LOG_LEVEL&#34;, [&#34;connector&#34;, &#34;log_level&#34;], config
        )

        # Configure logger
        numeric_level = getattr(logging, self.log_level.upper(), None)
        if not isinstance(numeric_level, int):
            raise ValueError(&#34;Invalid log level: &#34; + self.log_level)
        logging.basicConfig(level=numeric_level)

        # Initialize configuration
        self.api = OpenCTIApiClient(
            self.opencti_url, self.opencti_token, self.log_level
        )
        self.current_work_id = None

        # Register the connector in OpenCTI
        self.connector = OpenCTIConnector(
            self.connect_id, self.connect_name, self.connect_type, self.connect_scope
        )
        connector_configuration = self.api.connector.register(self.connector)
        self.connector_id = connector_configuration[&#34;id&#34;]
        self.connector_state = connector_configuration[&#34;connector_state&#34;]
        self.config = connector_configuration[&#34;config&#34;]

        # Start ping thread
        self.ping = PingAlive(
            self.connector.id, self.api, self.get_state, self.set_state
        )
        self.ping.start()

        # Initialize caching
        self.cache_index = {}
        self.cache_added = []

    def set_state(self, state) -&gt; None:
        self.connector_state = json.dumps(state)

    def get_state(self):
        try:
            return (
                None
                if self.connector_state is None
                else json.loads(self.connector_state)
            )
        except:
            return None

    def listen(self, message_callback: Callable[[Dict], List[str]]) -&gt; None:
        listen_queue = ListenQueue(self, self.config, message_callback)
        listen_queue.start()

    def get_connector(self):
        return self.connector

    def log_error(self, msg):
        logging.error(msg)

    def log_info(self, msg):
        logging.info(msg)

    def date_now(self):
        return (
            datetime.datetime.utcnow()
            .replace(microsecond=0, tzinfo=datetime.timezone.utc)
            .isoformat()
        )

    # Push Stix2 helper
    def send_stix2_bundle(self, bundle, entities_types=None, update=False, split=True):
        if entities_types is None:
            entities_types = []
        if split:
            bundles = self.split_stix2_bundle(bundle)
            if len(bundles) == 0:
                raise ValueError(&#34;Nothing to import&#34;)
            pika_connection = pika.BlockingConnection(
                pika.URLParameters(self.config[&#34;uri&#34;])
            )
            channel = pika_connection.channel()
            for bundle in bundles:
                self._send_bundle(channel, bundle, entities_types, update)
            channel.close()
            return bundles
        else:
            pika_connection = pika.BlockingConnection(
                pika.URLParameters(self.config[&#34;uri&#34;])
            )
            channel = pika_connection.channel()
            self._send_bundle(channel, bundle, entities_types, update)
            channel.close()
            return [bundle]

    def _send_bundle(self, channel, bundle, entities_types=None, update=False):
        &#34;&#34;&#34;
            This method send a STIX2 bundle to RabbitMQ to be consumed by workers
            :param bundle: A valid STIX2 bundle
            :param entities_types: Entities types to ingest
        &#34;&#34;&#34;
        if entities_types is None:
            entities_types = []

        # Create a job log expectation
        if self.current_work_id is not None:
            job_id = self.api.job.initiate_job(self.current_work_id)
        else:
            job_id = None

        # Validate the STIX 2 bundle
        # validation = validate_string(bundle)
        # if not validation.is_valid:
        # raise ValueError(&#39;The bundle is not a valid STIX2 JSON&#39;)

        # Prepare the message
        # if self.current_work_id is None:
        #    raise ValueError(&#39;The job id must be specified&#39;)
        message = {
            &#34;job_id&#34;: job_id,
            &#34;entities_types&#34;: entities_types,
            &#34;update&#34;: update,
            &#34;content&#34;: base64.b64encode(bundle.encode(&#34;utf-8&#34;)).decode(&#34;utf-8&#34;),
        }

        # Send the message
        try:
            routing_key = &#34;push_routing_&#34; + self.connector_id
            channel.basic_publish(
                self.config[&#34;push_exchange&#34;], routing_key, json.dumps(message)
            )
            logging.info(&#34;Bundle has been sent&#34;)
        except (UnroutableError, NackError) as e:
            logging.error(&#34;Unable to send bundle, retry...&#34;, e)
            self._send_bundle(bundle, entities_types)

    def split_stix2_bundle(self, bundle):
        self.cache_index = {}
        self.cache_added = []
        try:
            bundle_data = json.loads(bundle)
        except:
            raise Exception(&#34;File data is not a valid JSON&#34;)

        # validation = validate_parsed_json(bundle_data)
        # if not validation.is_valid:
        #     raise ValueError(&#39;The bundle is not a valid STIX2 JSON:&#39; + bundle)

        # Index all objects by id
        for item in bundle_data[&#34;objects&#34;]:
            self.cache_index[item[&#34;id&#34;]] = item

        bundles = []
        # Reports must be handled because of object_refs
        for item in bundle_data[&#34;objects&#34;]:
            if item[&#34;type&#34;] == &#34;report&#34;:
                items_to_send = self.stix2_deduplicate_objects(
                    self.stix2_get_report_objects(item)
                )
                for item_to_send in items_to_send:
                    self.cache_added.append(item_to_send[&#34;id&#34;])
                bundles.append(self.stix2_create_bundle(items_to_send))

        # Relationships not added in previous reports
        for item in bundle_data[&#34;objects&#34;]:
            if item[&#34;type&#34;] == &#34;relationship&#34; and item[&#34;id&#34;] not in self.cache_added:
                items_to_send = self.stix2_deduplicate_objects(
                    self.stix2_get_relationship_objects(item)
                )
                for item_to_send in items_to_send:
                    self.cache_added.append(item_to_send[&#34;id&#34;])
                bundles.append(self.stix2_create_bundle(items_to_send))

        # Entities not added in previous reports and relationships
        for item in bundle_data[&#34;objects&#34;]:
            if item[&#34;type&#34;] != &#34;relationship&#34; and item[&#34;id&#34;] not in self.cache_added:
                items_to_send = self.stix2_deduplicate_objects(
                    self.stix2_get_entity_objects(item)
                )
                for item_to_send in items_to_send:
                    self.cache_added.append(item_to_send[&#34;id&#34;])
                bundles.append(self.stix2_create_bundle(items_to_send))

        return bundles

    def stix2_get_embedded_objects(self, item):
        # Marking definitions
        object_marking_refs = []
        if &#34;object_marking_refs&#34; in item:
            for object_marking_ref in item[&#34;object_marking_refs&#34;]:
                if object_marking_ref in self.cache_index:
                    object_marking_refs.append(self.cache_index[object_marking_ref])
        # Created by ref
        created_by_ref = None
        if &#34;created_by_ref&#34; in item and item[&#34;created_by_ref&#34;] in self.cache_index:
            created_by_ref = self.cache_index[item[&#34;created_by_ref&#34;]]

        return {
            &#34;object_marking_refs&#34;: object_marking_refs,
            &#34;created_by_ref&#34;: created_by_ref,
        }

    def stix2_get_entity_objects(self, entity):
        items = [entity]
        # Get embedded objects
        embedded_objects = self.stix2_get_embedded_objects(entity)
        # Add created by ref
        if embedded_objects[&#34;created_by_ref&#34;] is not None:
            items.append(embedded_objects[&#34;created_by_ref&#34;])
        # Add marking definitions
        if len(embedded_objects[&#34;object_marking_refs&#34;]) &gt; 0:
            items = items + embedded_objects[&#34;object_marking_refs&#34;]

        return items

    def stix2_get_relationship_objects(self, relationship):
        items = [relationship]
        # Get source ref
        if relationship[&#34;source_ref&#34;] in self.cache_index:
            items.append(self.cache_index[relationship[&#34;source_ref&#34;]])

        # Get target ref
        if relationship[&#34;target_ref&#34;] in self.cache_index:
            items.append(self.cache_index[relationship[&#34;target_ref&#34;]])

        # Get embedded objects
        embedded_objects = self.stix2_get_embedded_objects(relationship)
        # Add created by ref
        if embedded_objects[&#34;created_by_ref&#34;] is not None:
            items.append(embedded_objects[&#34;created_by_ref&#34;])
        # Add marking definitions
        if len(embedded_objects[&#34;object_marking_refs&#34;]) &gt; 0:
            items = items + embedded_objects[&#34;object_marking_refs&#34;]

        return items

    def stix2_get_report_objects(self, report):
        items = [report]
        # Add all object refs
        for object_ref in report[&#34;object_refs&#34;]:
            items.append(self.cache_index[object_ref])
        for item in items:
            if item[&#34;type&#34;] == &#34;relationship&#34;:
                items = items + self.stix2_get_relationship_objects(item)
            else:
                items = items + self.stix2_get_entity_objects(item)
        return items

    @staticmethod
    def stix2_deduplicate_objects(items):
        ids = []
        final_items = []
        for item in items:
            if item[&#34;id&#34;] not in ids:
                final_items.append(item)
                ids.append(item[&#34;id&#34;])
        return final_items

    @staticmethod
    def stix2_create_bundle(items):
        bundle = {
            &#34;type&#34;: &#34;bundle&#34;,
            &#34;id&#34;: &#34;bundle--&#34; + str(uuid.uuid4()),
            &#34;spec_version&#34;: &#34;2.0&#34;,
            &#34;objects&#34;: items,
        }
        return json.dumps(bundle)

    @staticmethod
    def check_max_tlp(tlp, max_tlp):
        allowed_tlps = [&#34;TLP:WHITE&#34;]
        if max_tlp == &#34;TLP:RED&#34;:
            allowed_tlps = [&#34;TLP:WHITE&#34;, &#34;TLP:GREEN&#34;, &#34;TLP:AMBER&#34;, &#34;TLP:RED&#34;]
        elif max_tlp == &#34;TLP:AMBER&#34;:
            allowed_tlps = [&#34;TLP:WHITE&#34;, &#34;TLP:GREEN&#34;, &#34;TLP:AMBER&#34;]
        elif max_tlp == &#34;TLP:GREEN&#34;:
            allowed_tlps = [&#34;TLP:WHITE&#34;, &#34;TLP:GREEN&#34;]

        return tlp in allowed_tlps</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="pycti.OpenCTIConnectorHelper.check_max_tlp"><code class="name flex">
<span>def <span class="ident">check_max_tlp</span></span>(<span>tlp, max_tlp)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def check_max_tlp(tlp, max_tlp):
    allowed_tlps = [&#34;TLP:WHITE&#34;]
    if max_tlp == &#34;TLP:RED&#34;:
        allowed_tlps = [&#34;TLP:WHITE&#34;, &#34;TLP:GREEN&#34;, &#34;TLP:AMBER&#34;, &#34;TLP:RED&#34;]
    elif max_tlp == &#34;TLP:AMBER&#34;:
        allowed_tlps = [&#34;TLP:WHITE&#34;, &#34;TLP:GREEN&#34;, &#34;TLP:AMBER&#34;]
    elif max_tlp == &#34;TLP:GREEN&#34;:
        allowed_tlps = [&#34;TLP:WHITE&#34;, &#34;TLP:GREEN&#34;]

    return tlp in allowed_tlps</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIConnectorHelper.stix2_create_bundle"><code class="name flex">
<span>def <span class="ident">stix2_create_bundle</span></span>(<span>items)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def stix2_create_bundle(items):
    bundle = {
        &#34;type&#34;: &#34;bundle&#34;,
        &#34;id&#34;: &#34;bundle--&#34; + str(uuid.uuid4()),
        &#34;spec_version&#34;: &#34;2.0&#34;,
        &#34;objects&#34;: items,
    }
    return json.dumps(bundle)</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIConnectorHelper.stix2_deduplicate_objects"><code class="name flex">
<span>def <span class="ident">stix2_deduplicate_objects</span></span>(<span>items)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def stix2_deduplicate_objects(items):
    ids = []
    final_items = []
    for item in items:
        if item[&#34;id&#34;] not in ids:
            final_items.append(item)
            ids.append(item[&#34;id&#34;])
    return final_items</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pycti.OpenCTIConnectorHelper.date_now"><code class="name flex">
<span>def <span class="ident">date_now</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def date_now(self):
    return (
        datetime.datetime.utcnow()
        .replace(microsecond=0, tzinfo=datetime.timezone.utc)
        .isoformat()
    )</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIConnectorHelper.get_connector"><code class="name flex">
<span>def <span class="ident">get_connector</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_connector(self):
    return self.connector</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIConnectorHelper.get_state"><code class="name flex">
<span>def <span class="ident">get_state</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_state(self):
    try:
        return (
            None
            if self.connector_state is None
            else json.loads(self.connector_state)
        )
    except:
        return None</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIConnectorHelper.listen"><code class="name flex">
<span>def <span class="ident">listen</span></span>(<span>self, message_callback:Callable[[Dict],List[str]]) ->NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def listen(self, message_callback: Callable[[Dict], List[str]]) -&gt; None:
    listen_queue = ListenQueue(self, self.config, message_callback)
    listen_queue.start()</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIConnectorHelper.log_error"><code class="name flex">
<span>def <span class="ident">log_error</span></span>(<span>self, msg)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log_error(self, msg):
    logging.error(msg)</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIConnectorHelper.log_info"><code class="name flex">
<span>def <span class="ident">log_info</span></span>(<span>self, msg)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log_info(self, msg):
    logging.info(msg)</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIConnectorHelper.send_stix2_bundle"><code class="name flex">
<span>def <span class="ident">send_stix2_bundle</span></span>(<span>self, bundle, entities_types=None, update=False, split=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_stix2_bundle(self, bundle, entities_types=None, update=False, split=True):
    if entities_types is None:
        entities_types = []
    if split:
        bundles = self.split_stix2_bundle(bundle)
        if len(bundles) == 0:
            raise ValueError(&#34;Nothing to import&#34;)
        pika_connection = pika.BlockingConnection(
            pika.URLParameters(self.config[&#34;uri&#34;])
        )
        channel = pika_connection.channel()
        for bundle in bundles:
            self._send_bundle(channel, bundle, entities_types, update)
        channel.close()
        return bundles
    else:
        pika_connection = pika.BlockingConnection(
            pika.URLParameters(self.config[&#34;uri&#34;])
        )
        channel = pika_connection.channel()
        self._send_bundle(channel, bundle, entities_types, update)
        channel.close()
        return [bundle]</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIConnectorHelper.set_state"><code class="name flex">
<span>def <span class="ident">set_state</span></span>(<span>self, state) ->NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_state(self, state) -&gt; None:
    self.connector_state = json.dumps(state)</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIConnectorHelper.split_stix2_bundle"><code class="name flex">
<span>def <span class="ident">split_stix2_bundle</span></span>(<span>self, bundle)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split_stix2_bundle(self, bundle):
    self.cache_index = {}
    self.cache_added = []
    try:
        bundle_data = json.loads(bundle)
    except:
        raise Exception(&#34;File data is not a valid JSON&#34;)

    # validation = validate_parsed_json(bundle_data)
    # if not validation.is_valid:
    #     raise ValueError(&#39;The bundle is not a valid STIX2 JSON:&#39; + bundle)

    # Index all objects by id
    for item in bundle_data[&#34;objects&#34;]:
        self.cache_index[item[&#34;id&#34;]] = item

    bundles = []
    # Reports must be handled because of object_refs
    for item in bundle_data[&#34;objects&#34;]:
        if item[&#34;type&#34;] == &#34;report&#34;:
            items_to_send = self.stix2_deduplicate_objects(
                self.stix2_get_report_objects(item)
            )
            for item_to_send in items_to_send:
                self.cache_added.append(item_to_send[&#34;id&#34;])
            bundles.append(self.stix2_create_bundle(items_to_send))

    # Relationships not added in previous reports
    for item in bundle_data[&#34;objects&#34;]:
        if item[&#34;type&#34;] == &#34;relationship&#34; and item[&#34;id&#34;] not in self.cache_added:
            items_to_send = self.stix2_deduplicate_objects(
                self.stix2_get_relationship_objects(item)
            )
            for item_to_send in items_to_send:
                self.cache_added.append(item_to_send[&#34;id&#34;])
            bundles.append(self.stix2_create_bundle(items_to_send))

    # Entities not added in previous reports and relationships
    for item in bundle_data[&#34;objects&#34;]:
        if item[&#34;type&#34;] != &#34;relationship&#34; and item[&#34;id&#34;] not in self.cache_added:
            items_to_send = self.stix2_deduplicate_objects(
                self.stix2_get_entity_objects(item)
            )
            for item_to_send in items_to_send:
                self.cache_added.append(item_to_send[&#34;id&#34;])
            bundles.append(self.stix2_create_bundle(items_to_send))

    return bundles</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIConnectorHelper.stix2_get_embedded_objects"><code class="name flex">
<span>def <span class="ident">stix2_get_embedded_objects</span></span>(<span>self, item)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stix2_get_embedded_objects(self, item):
    # Marking definitions
    object_marking_refs = []
    if &#34;object_marking_refs&#34; in item:
        for object_marking_ref in item[&#34;object_marking_refs&#34;]:
            if object_marking_ref in self.cache_index:
                object_marking_refs.append(self.cache_index[object_marking_ref])
    # Created by ref
    created_by_ref = None
    if &#34;created_by_ref&#34; in item and item[&#34;created_by_ref&#34;] in self.cache_index:
        created_by_ref = self.cache_index[item[&#34;created_by_ref&#34;]]

    return {
        &#34;object_marking_refs&#34;: object_marking_refs,
        &#34;created_by_ref&#34;: created_by_ref,
    }</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIConnectorHelper.stix2_get_entity_objects"><code class="name flex">
<span>def <span class="ident">stix2_get_entity_objects</span></span>(<span>self, entity)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stix2_get_entity_objects(self, entity):
    items = [entity]
    # Get embedded objects
    embedded_objects = self.stix2_get_embedded_objects(entity)
    # Add created by ref
    if embedded_objects[&#34;created_by_ref&#34;] is not None:
        items.append(embedded_objects[&#34;created_by_ref&#34;])
    # Add marking definitions
    if len(embedded_objects[&#34;object_marking_refs&#34;]) &gt; 0:
        items = items + embedded_objects[&#34;object_marking_refs&#34;]

    return items</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIConnectorHelper.stix2_get_relationship_objects"><code class="name flex">
<span>def <span class="ident">stix2_get_relationship_objects</span></span>(<span>self, relationship)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stix2_get_relationship_objects(self, relationship):
    items = [relationship]
    # Get source ref
    if relationship[&#34;source_ref&#34;] in self.cache_index:
        items.append(self.cache_index[relationship[&#34;source_ref&#34;]])

    # Get target ref
    if relationship[&#34;target_ref&#34;] in self.cache_index:
        items.append(self.cache_index[relationship[&#34;target_ref&#34;]])

    # Get embedded objects
    embedded_objects = self.stix2_get_embedded_objects(relationship)
    # Add created by ref
    if embedded_objects[&#34;created_by_ref&#34;] is not None:
        items.append(embedded_objects[&#34;created_by_ref&#34;])
    # Add marking definitions
    if len(embedded_objects[&#34;object_marking_refs&#34;]) &gt; 0:
        items = items + embedded_objects[&#34;object_marking_refs&#34;]

    return items</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIConnectorHelper.stix2_get_report_objects"><code class="name flex">
<span>def <span class="ident">stix2_get_report_objects</span></span>(<span>self, report)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stix2_get_report_objects(self, report):
    items = [report]
    # Add all object refs
    for object_ref in report[&#34;object_refs&#34;]:
        items.append(self.cache_index[object_ref])
    for item in items:
        if item[&#34;type&#34;] == &#34;relationship&#34;:
            items = items + self.stix2_get_relationship_objects(item)
        else:
            items = items + self.stix2_get_entity_objects(item)
    return items</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pycti.OpenCTIStix2"><code class="flex name class">
<span>class <span class="ident">OpenCTIStix2</span></span>
<span>(</span><span>opencti)</span>
</code></dt>
<dd>
<div class="desc"><p>Python API for Stix2 in OpenCTI
:param opencti: OpenCTI instance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OpenCTIStix2:
    &#34;&#34;&#34;
        Python API for Stix2 in OpenCTI
        :param opencti: OpenCTI instance
    &#34;&#34;&#34;

    def __init__(self, opencti):
        self.opencti = opencti
        self.mapping_cache = {}

    def unknown_type(self, stix_object):
        self.opencti.log(
            &#34;error&#34;,
            &#39;Unknown object type &#34;&#39; + stix_object[&#34;type&#34;] + &#39;&#34;, doing nothing...&#39;,
        )

    def convert_markdown(self, text):
        return text.replace(&#34;&lt;code&gt;&#34;, &#34;`&#34;).replace(&#34;&lt;/code&gt;&#34;, &#34;`&#34;)

    def format_date(self, date):
        if isinstance(date, datetime.date):
            return date.isoformat(timespec=&#34;milliseconds&#34;).replace(&#34;+00:00&#34;, &#34;Z&#34;)
        if date is not None:
            return (
                dateutil.parser.parse(date)
                .isoformat(timespec=&#34;milliseconds&#34;)
                .replace(&#34;+00:00&#34;, &#34;Z&#34;)
            )
        else:
            return (
                datetime.datetime.utcnow()
                .isoformat(timespec=&#34;milliseconds&#34;)
                .replace(&#34;+00:00&#34;, &#34;Z&#34;)
            )

    def filter_objects(self, uuids, objects):
        result = []
        if objects is not None:
            for object in objects:
                if &#34;id&#34; in object and object[&#34;id&#34;] not in uuids:
                    result.append(object)
        return result

    def pick_aliases(self, stix_object):
        # Add aliases
        if CustomProperties.ALIASES in stix_object:
            return stix_object[CustomProperties.ALIASES]
        elif &#34;x_mitre_aliases&#34; in stix_object:
            return stix_object[&#34;x_mitre_aliases&#34;]
        elif &#34;x_amitt_aliases&#34; in stix_object:
            return stix_object[&#34;x_amitt_aliases&#34;]
        elif &#34;aliases&#34; in stix_object:
            return stix_object[&#34;aliases&#34;]
        return None

    def check_max_marking_definition(
        self, max_marking_definition_entity, entity_marking_definitions
    ):
        # Max is not set, return True
        if max_marking_definition_entity is None:
            return True
        # Filter entity markings definition to the max_marking_definition type
        typed_entity_marking_definitions = []
        for entity_marking_definition in entity_marking_definitions:
            if (
                entity_marking_definition[&#34;definition_type&#34;]
                == max_marking_definition_entity[&#34;definition_type&#34;]
            ):
                typed_entity_marking_definitions.append(entity_marking_definition)
        # No entity marking defintions of the max_marking_definition type
        if len(typed_entity_marking_definitions) == 0:
            return True

        # Check if level is less or equal to max
        for typed_entity_marking_definition in typed_entity_marking_definitions:
            if (
                typed_entity_marking_definition[&#34;level&#34;]
                &lt;= max_marking_definition_entity[&#34;level&#34;]
            ):
                return True
        return False

    def import_bundle_from_file(self, file_path, update=False, types=None):
        if types is None:
            types = []
        if not os.path.isfile(file_path):
            self.opencti.log(&#34;error&#34;, &#34;The bundle file does not exists&#34;)
            return None

        with open(os.path.join(file_path)) as file:
            data = json.load(file)

        return self.import_bundle(data, update, types)

    def import_bundle_from_json(self, json_data, update=False, types=None) -&gt; List:
        if types is None:
            types = []
        data = json.loads(json_data)
        return self.import_bundle(data, update, types)

    def extract_embedded_relationships(self, stix_object, types=None):
        # Created By Ref
        created_by_ref_id = None
        if &#34;created_by_ref&#34; in stix_object:
            created_by_ref = stix_object[&#34;created_by_ref&#34;]
            if created_by_ref in self.mapping_cache:
                created_by_ref_result = self.mapping_cache[created_by_ref]
            else:
                created_by_ref_result = self.opencti.stix_domain_entity.read(
                    id=created_by_ref
                )
                if created_by_ref_result is not None:
                    self.mapping_cache[created_by_ref] = {
                        &#34;id&#34;: created_by_ref_result[&#34;id&#34;],
                        &#34;type&#34;: created_by_ref_result[&#34;entity_type&#34;],
                    }
            if created_by_ref_result is not None:
                created_by_ref_id = created_by_ref_result[&#34;id&#34;]

        # Object Marking Refs
        marking_definitions_ids = []
        if &#34;object_marking_refs&#34; in stix_object:
            for object_marking_ref in stix_object[&#34;object_marking_refs&#34;]:
                if object_marking_ref in self.mapping_cache:
                    object_marking_ref_result = self.mapping_cache[object_marking_ref]
                else:
                    object_marking_ref_result = self.opencti.marking_definition.read(
                        id=object_marking_ref
                    )
                    if object_marking_ref_result is not None:
                        self.mapping_cache[object_marking_ref] = {
                            &#34;id&#34;: object_marking_ref_result[&#34;id&#34;],
                            &#34;type&#34;: object_marking_ref_result[&#34;entity_type&#34;],
                        }
                if object_marking_ref_result is not None:
                    marking_definitions_ids.append(object_marking_ref_result[&#34;id&#34;])

        # Object Tags
        tags_ids = []
        if CustomProperties.TAG_TYPE in stix_object:
            for tag in stix_object[CustomProperties.TAG_TYPE]:
                tag_result = None
                if &#34;id&#34; in tag:
                    if tag[&#34;id&#34;] in self.mapping_cache:
                        tag_result = self.mapping_cache[tag[&#34;id&#34;]]
                    else:
                        tag_result = self.opencti.tag.read(id=tag[&#34;id&#34;])
                if tag_result is not None:
                    self.mapping_cache[tag[&#34;id&#34;]] = {&#34;id&#34;: tag_result[&#34;id&#34;]}
                else:
                    tag_result = self.opencti.tag.create(
                        tag_type=tag[&#34;tag_type&#34;],
                        value=tag[&#34;value&#34;],
                        color=tag[&#34;color&#34;],
                        id=tag[&#34;id&#34;] if &#34;id&#34; in tag else None,
                    )
                if tag_result is not None:
                    tags_ids.append(tag_result[&#34;id&#34;])

        # Kill Chain Phases
        kill_chain_phases_ids = []
        if &#34;kill_chain_phases&#34; in stix_object:
            for kill_chain_phase in stix_object[&#34;kill_chain_phases&#34;]:
                if kill_chain_phase[&#34;phase_name&#34;] in self.mapping_cache:
                    kill_chain_phase = self.mapping_cache[
                        kill_chain_phase[&#34;phase_name&#34;]
                    ]
                else:
                    kill_chain_phase = self.opencti.kill_chain_phase.create(
                        kill_chain_name=kill_chain_phase[&#34;kill_chain_name&#34;],
                        phase_name=kill_chain_phase[&#34;phase_name&#34;],
                        phase_order=kill_chain_phase[CustomProperties.PHASE_ORDER]
                        if CustomProperties.PHASE_ORDER in kill_chain_phase
                        else 0,
                        id=kill_chain_phase[CustomProperties.ID]
                        if CustomProperties.ID in kill_chain_phase
                        else None,
                        stix_id_key=kill_chain_phase[&#34;id&#34;]
                        if &#34;id&#34; in kill_chain_phase
                        else None,
                        created=kill_chain_phase[CustomProperties.CREATED]
                        if CustomProperties.CREATED in kill_chain_phase
                        else None,
                        modified=kill_chain_phase[CustomProperties.MODIFIED]
                        if CustomProperties.MODIFIED in kill_chain_phase
                        else None,
                    )
                    self.mapping_cache[kill_chain_phase[&#34;phase_name&#34;]] = {
                        &#34;id&#34;: kill_chain_phase[&#34;id&#34;],
                        &#34;type&#34;: kill_chain_phase[&#34;entity_type&#34;],
                    }
                kill_chain_phases_ids.append(kill_chain_phase[&#34;id&#34;])

        # Object refs
        object_refs_ids = []
        if &#34;object_refs&#34; in stix_object:
            for object_ref in stix_object[&#34;object_refs&#34;]:
                object_ref_result = None
                if object_ref in self.mapping_cache:
                    object_ref_result = self.mapping_cache[object_ref]
                elif &#34;relationship&#34; in object_ref:
                    object_ref_result = self.opencti.stix_relation.read(id=object_ref)
                    if object_ref_result is not None:
                        self.mapping_cache[object_ref] = {
                            &#34;id&#34;: object_ref_result[&#34;id&#34;],
                            &#34;type&#34;: object_ref_result[&#34;entity_type&#34;],
                        }
                elif &#34;observed-data&#34; not in object_ref:
                    object_ref_result = self.opencti.stix_entity.read(id=object_ref)
                    if object_ref_result is not None:
                        self.mapping_cache[object_ref] = {
                            &#34;id&#34;: object_ref_result[&#34;id&#34;],
                            &#34;type&#34;: object_ref_result[&#34;entity_type&#34;],
                        }
                if &#34;observed-data&#34; not in object_ref:
                    if object_ref_result is not None:
                        object_refs_ids.append(object_ref_result[&#34;id&#34;])
                else:
                    object_refs_ids.append(object_ref)

        # External References
        reports = {}
        external_references_ids = []
        if &#34;external_references&#34; in stix_object:
            for external_reference in stix_object[&#34;external_references&#34;]:
                if &#34;url&#34; in external_reference and &#34;source_name&#34; in external_reference:
                    url = external_reference[&#34;url&#34;]
                    source_name = external_reference[&#34;source_name&#34;]
                else:
                    continue
                if url in self.mapping_cache:
                    external_reference_id = self.mapping_cache[url][&#34;id&#34;]
                else:
                    external_reference_id = self.opencti.external_reference.create(
                        source_name=source_name,
                        url=url,
                        external_id=external_reference[&#34;external_id&#34;]
                        if &#34;external_id&#34; in external_reference
                        else None,
                        description=external_reference[&#34;description&#34;]
                        if &#34;description&#34; in external_reference
                        else None,
                        id=external_reference[CustomProperties.ID]
                        if CustomProperties.ID in external_reference
                        else None,
                        stix_id_key=external_reference[&#34;id&#34;]
                        if &#34;id&#34; in external_reference
                        else None,
                        created=external_reference[CustomProperties.CREATED]
                        if CustomProperties.CREATED in external_reference
                        else None,
                        modified=external_reference[CustomProperties.MODIFIED]
                        if CustomProperties.MODIFIED in external_reference
                        else None,
                    )[&#34;id&#34;]
                self.mapping_cache[url] = {&#34;id&#34;: external_reference_id}
                external_references_ids.append(external_reference_id)

                if stix_object[&#34;type&#34;] in [
                    &#34;threat-actor&#34;,
                    &#34;intrusion-set&#34;,
                    &#34;campaign&#34;,
                    &#34;incident&#34;,
                    &#34;malware&#34;,
                    &#34;relationship&#34;,
                ] and (types is None or &#34;report&#34; in types):
                    # Add a corresponding report
                    # Extract date
                    try:
                        if &#34;description&#34; in external_reference:
                            matches = datefinder.find_dates(
                                external_reference[&#34;description&#34;]
                            )
                        else:
                            matches = datefinder.find_dates(source_name)
                    except:
                        matches = None
                    published = None
                    today = datetime.datetime.today()
                    if matches is not None:
                        for match in matches:
                            if match &lt; today:
                                published = match.strftime(&#34;%Y-%m-%dT%H:%M:%SZ&#34;)
                    if published is None:
                        published = today.strftime(&#34;%Y-%m-%dT%H:%M:%SZ&#34;)

                    if &#34;mitre&#34; in source_name and &#34;name&#34; in stix_object:
                        title = &#34;[MITRE ATT&amp;CK] &#34; + stix_object[&#34;name&#34;]
                        if &#34;modified&#34; in stix_object:
                            published = stix_object[&#34;modified&#34;]
                    elif &#34;amitt&#34; in source_name and &#34;name&#34; in stix_object:
                        title = &#34;[AM!TT] &#34; + stix_object[&#34;name&#34;]
                        if &#34;modified&#34; in stix_object:
                            published = stix_object[&#34;modified&#34;]
                    else:
                        title = source_name

                    if &#34;external_id&#34; in external_reference:
                        title = title + &#34; (&#34; + external_reference[&#34;external_id&#34;] + &#34;)&#34;

                    author = self.resolve_author(title)
                    report = self.opencti.report.create(
                        name=title,
                        external_reference_id=external_reference_id,
                        description=external_reference[&#34;description&#34;]
                        if &#34;description&#34; in external_reference
                        else &#34;&#34;,
                        published=published,
                        report_class=&#34;Threat Report&#34;,
                        object_status=2,
                        createdByRef=author[&#34;id&#34;] if author is not None else None,
                        update=True,
                    )
                    # Add marking
                    if &#34;marking_tlpwhite&#34; in self.mapping_cache:
                        object_marking_ref_result = self.mapping_cache[
                            &#34;marking_tlpwhite&#34;
                        ]
                    else:
                        object_marking_ref_result = self.opencti.marking_definition.read(
                            filters=[
                                {&#34;key&#34;: &#34;definition_type&#34;, &#34;values&#34;: [&#34;TLP&#34;]},
                                {&#34;key&#34;: &#34;definition&#34;, &#34;values&#34;: [&#34;TLP:WHITE&#34;]},
                            ]
                        )
                    if object_marking_ref_result is not None:
                        self.mapping_cache[&#34;marking_tlpwhite&#34;] = {
                            &#34;id&#34;: object_marking_ref_result[&#34;id&#34;]
                        }
                        self.opencti.stix_entity.add_marking_definition(
                            id=report[&#34;id&#34;],
                            marking_definition_id=object_marking_ref_result[&#34;id&#34;],
                        )

                    # Add external reference to report
                    self.opencti.stix_entity.add_external_reference(
                        id=report[&#34;id&#34;], external_reference_id=external_reference_id,
                    )
                    reports[external_reference_id] = report

        return {
            &#34;created_by_ref&#34;: created_by_ref_id,
            &#34;marking_definitions&#34;: marking_definitions_ids,
            &#34;tags&#34;: tags_ids,
            &#34;kill_chain_phases&#34;: kill_chain_phases_ids,
            &#34;object_refs&#34;: object_refs_ids,
            &#34;external_references&#34;: external_references_ids,
            &#34;reports&#34;: reports,
        }

    def import_object(self, stix_object, update=False, types=None):
        self.opencti.log(
            &#34;info&#34;,
            &#34;Importing a &#34; + stix_object[&#34;type&#34;] + &#34; (id: &#34; + stix_object[&#34;id&#34;] + &#34;)&#34;,
        )

        # Extract
        embedded_relationships = self.extract_embedded_relationships(stix_object, types)
        created_by_ref_id = embedded_relationships[&#34;created_by_ref&#34;]
        marking_definitions_ids = embedded_relationships[&#34;marking_definitions&#34;]
        tags_ids = embedded_relationships[&#34;tags&#34;]
        kill_chain_phases_ids = embedded_relationships[&#34;kill_chain_phases&#34;]
        object_refs_ids = embedded_relationships[&#34;object_refs&#34;]
        external_references_ids = embedded_relationships[&#34;external_references&#34;]
        reports = embedded_relationships[&#34;reports&#34;]

        # Extra
        extras = {
            &#34;created_by_ref_id&#34;: created_by_ref_id,
            &#34;marking_definitions_ids&#34;: marking_definitions_ids,
            &#34;tags_ids&#34;: tags_ids,
            &#34;kill_chain_phases_ids&#34;: kill_chain_phases_ids,
            &#34;object_refs_ids&#34;: object_refs_ids,
            &#34;external_references_ids&#34;: external_references_ids,
            &#34;reports&#34;: reports,
        }

        # Import
        importer = {
            &#34;marking-definition&#34;: self.create_marking_definition,
            &#34;identity&#34;: self.create_identity,
            &#34;threat-actor&#34;: self.create_threat_actor,
            &#34;intrusion-set&#34;: self.create_intrusion_set,
            &#34;campaign&#34;: self.create_campaign,
            &#34;x-opencti-incident&#34;: self.create_incident,
            &#34;malware&#34;: self.create_malware,
            &#34;tool&#34;: self.create_tool,
            &#34;vulnerability&#34;: self.create_vulnerability,
            &#34;attack-pattern&#34;: self.create_attack_pattern,
            &#34;course-of-action&#34;: self.create_course_of_action,
            &#34;report&#34;: self.create_report,
            &#34;note&#34;: self.create_note,
            &#34;opinion&#34;: self.create_opinion,
            &#34;indicator&#34;: self.create_indicator,
        }
        do_import = importer.get(
            stix_object[&#34;type&#34;],
            lambda stix_object, extras, update: self.unknown_type(stix_object),
        )
        stix_object_results = do_import(stix_object, extras, update)

        if stix_object_results is None:
            return stix_object_results

        if not isinstance(stix_object_results, list):
            stix_object_results = [stix_object_results]

        for stix_object_result in stix_object_results:
            # Add embedded relationships
            self.mapping_cache[stix_object[&#34;id&#34;]] = {
                &#34;id&#34;: stix_object_result[&#34;id&#34;],
                &#34;type&#34;: stix_object_result[&#34;entity_type&#34;],
                &#34;observableRefs&#34;: stix_object_result[&#34;observableRefs&#34;]
                if &#34;observableRefs&#34; in stix_object_result
                else [],
            }
            self.mapping_cache[stix_object_result[&#34;id&#34;]] = {
                &#34;id&#34;: stix_object_result[&#34;id&#34;],
                &#34;type&#34;: stix_object_result[&#34;entity_type&#34;],
                &#34;observableRefs&#34;: stix_object_result[&#34;observableRefs&#34;]
                if &#34;observableRefs&#34; in stix_object_result
                else [],
            }

            # Add tags
            for tag_id in tags_ids:
                self.opencti.stix_entity.add_tag(
                    id=stix_object_result[&#34;id&#34;], tag_id=tag_id,
                )
            # Add external references
            for external_reference_id in external_references_ids:
                self.opencti.stix_entity.add_external_reference(
                    id=stix_object_result[&#34;id&#34;],
                    external_reference_id=external_reference_id,
                )
                if external_reference_id in reports:
                    self.opencti.report.add_stix_entity(
                        id=reports[external_reference_id][&#34;id&#34;],
                        entity_id=stix_object_result[&#34;id&#34;],
                    )
            # Add object refs
            for object_refs_id in object_refs_ids:
                if &#34;observed-data&#34; in object_refs_id:
                    if object_refs_id in self.mapping_cache:
                        for observable in self.mapping_cache[object_refs_id]:
                            if stix_object_result[&#34;entity_type&#34;] == &#34;report&#34;:
                                self.opencti.report.add_stix_observable(
                                    id=stix_object_result[&#34;id&#34;],
                                    stix_observable_id=observable[&#34;id&#34;],
                                )
                            elif stix_object_result[&#34;entity_type&#34;] == &#34;note&#34;:
                                self.opencti.note.add_stix_observable(
                                    id=stix_object_result[&#34;id&#34;],
                                    stix_observable_id=observable[&#34;id&#34;],
                                )
                            elif stix_object_result[&#34;entity_type&#34;] == &#34;opinion&#34;:
                                self.opencti.opinion.add_stix_observable(
                                    id=stix_object_result[&#34;id&#34;],
                                    stix_observable_id=observable[&#34;id&#34;],
                                )
                else:
                    if stix_object_result[&#34;entity_type&#34;] == &#34;report&#34;:
                        self.opencti.report.add_stix_entity(
                            id=stix_object_result[&#34;id&#34;], entity_id=object_refs_id,
                        )
                    elif stix_object_result[&#34;entity_type&#34;] == &#34;note&#34;:
                        self.opencti.note.add_stix_entity(
                            id=stix_object_result[&#34;id&#34;], entity_id=object_refs_id,
                        )
                    elif stix_object_result[&#34;entity_type&#34;] == &#34;opinion&#34;:
                        self.opencti.opinion.add_stix_entity(
                            id=stix_object_result[&#34;id&#34;], entity_id=object_refs_id,
                        )
                    if (
                        object_refs_id in self.mapping_cache
                        and &#34;observableRefs&#34; in self.mapping_cache[object_refs_id]
                        and self.mapping_cache[object_refs_id] is not None
                        and self.mapping_cache[object_refs_id][&#34;observableRefs&#34;]
                        is not None
                        and len(self.mapping_cache[object_refs_id][&#34;observableRefs&#34;])
                        &gt; 0
                    ):
                        for observable_ref in self.mapping_cache[object_refs_id][
                            &#34;observableRefs&#34;
                        ]:
                            if stix_object_result[&#34;entity_type&#34;] == &#34;report&#34;:
                                self.opencti.report.add_stix_observable(
                                    id=stix_object_result[&#34;id&#34;],
                                    stix_observable_id=observable_ref[&#34;id&#34;],
                                )
                            elif stix_object_result[&#34;entity_type&#34;] == &#34;note&#34;:
                                self.opencti.note.add_stix_observable(
                                    id=stix_object_result[&#34;id&#34;],
                                    stix_observable_id=observable_ref[&#34;id&#34;],
                                )
                            elif stix_object_result[&#34;entity_type&#34;] == &#34;opinion&#34;:
                                self.opencti.opinion.add_stix_observable(
                                    id=stix_object_result[&#34;id&#34;],
                                    stix_observable_id=observable_ref[&#34;id&#34;],
                                )
            # Add files
            if CustomProperties.FILES in stix_object:
                for file in stix_object[CustomProperties.FILES]:
                    self.opencti.stix_domain_entity.add_file(
                        id=stix_object_result[&#34;id&#34;],
                        file_name=file[&#34;name&#34;],
                        data=base64.b64decode(file[&#34;data&#34;]),
                        mime_type=file[&#34;mime_type&#34;],
                    )

        return stix_object_results

    def import_relationship(self, stix_relation, update=False, types=None):
        # Extract
        embedded_relationships = self.extract_embedded_relationships(
            stix_relation, types
        )
        created_by_ref_id = embedded_relationships[&#34;created_by_ref&#34;]
        marking_definitions_ids = embedded_relationships[&#34;marking_definitions&#34;]
        kill_chain_phases_ids = embedded_relationships[&#34;kill_chain_phases&#34;]
        external_references_ids = embedded_relationships[&#34;external_references&#34;]
        reports = embedded_relationships[&#34;reports&#34;]

        # Extra
        extras = {
            &#34;created_by_ref_id&#34;: created_by_ref_id,
            &#34;marking_definitions_ids&#34;: marking_definitions_ids,
            &#34;kill_chain_phases_ids&#34;: kill_chain_phases_ids,
            &#34;external_references_ids&#34;: external_references_ids,
            &#34;reports&#34;: reports,
        }

        # Create the relation

        ### Get the SOURCE_REF
        if CustomProperties.SOURCE_REF in stix_relation:
            source_ref = stix_relation[CustomProperties.SOURCE_REF]
        else:
            source_ref = stix_relation[&#34;source_ref&#34;]
        if source_ref in self.mapping_cache:
            if (
                StixObservableRelationTypes.has_value(
                    stix_relation[&#34;relationship_type&#34;]
                )
                and &#34;observableRefs&#34; in self.mapping_cache[source_ref]
                and self.mapping_cache[source_ref][&#34;observableRefs&#34;] is not None
                and len(self.mapping_cache[source_ref][&#34;observableRefs&#34;]) &gt; 0
            ):
                source_id = self.mapping_cache[source_ref][&#34;observableRefs&#34;][0][&#34;id&#34;]
                source_type = self.mapping_cache[source_ref][&#34;observableRefs&#34;][0][
                    &#34;entity_type&#34;
                ]
            else:
                source_id = self.mapping_cache[source_ref][&#34;id&#34;]
                source_type = self.mapping_cache[source_ref][&#34;type&#34;]
        else:
            stix_object_result = self.opencti.stix_entity.read(id=source_ref)
            if stix_object_result is not None:
                source_id = stix_object_result[&#34;id&#34;]
                source_type = stix_object_result[&#34;entity_type&#34;]
            else:
                self.opencti.log(
                    &#34;error&#34;,
                    &#34;Source ref of the relationship not found, doing nothing...&#34;,
                )
                return None

        ### Get the TARGET_REF
        if CustomProperties.TARGET_REF in stix_relation:
            target_ref = stix_relation[CustomProperties.TARGET_REF]
        else:
            target_ref = stix_relation[&#34;target_ref&#34;]
        if target_ref in self.mapping_cache:
            if (
                StixObservableRelationTypes.has_value(
                    stix_relation[&#34;relationship_type&#34;]
                )
                and &#34;observableRefs&#34; in self.mapping_cache[target_ref]
                and self.mapping_cache[target_ref][&#34;observableRefs&#34;] is not None
                and len(self.mapping_cache[target_ref][&#34;observableRefs&#34;]) &gt; 0
            ):
                target_id = self.mapping_cache[target_ref][&#34;observableRefs&#34;][0][&#34;id&#34;]
                target_type = self.mapping_cache[target_ref][&#34;observableRefs&#34;][0][
                    &#34;entity_type&#34;
                ]
            else:
                target_id = self.mapping_cache[target_ref][&#34;id&#34;]
                target_type = self.mapping_cache[target_ref][&#34;type&#34;]
        else:
            stix_object_result = self.opencti.stix_entity.read(id=target_ref)
            if stix_object_result is not None:
                target_id = stix_object_result[&#34;id&#34;]
                target_type = stix_object_result[&#34;entity_type&#34;]
            else:
                self.opencti.log(
                    &#34;error&#34;,
                    &#34;Target ref of the relationship not found, doing nothing...&#34;,
                )
                return None

        date = None
        if &#34;external_references&#34; in stix_relation:
            for external_reference in stix_relation[&#34;external_references&#34;]:
                try:
                    if &#34;description&#34; in external_reference:
                        matches = datefinder.find_dates(
                            external_reference[&#34;description&#34;]
                        )
                    else:
                        matches = datefinder.find_dates(
                            external_reference[&#34;source_name&#34;]
                        )
                except:
                    matches = None
                date = None
                today = datetime.datetime.today()
                if matches is not None:
                    for match in matches:
                        if match &lt; today:
                            date = match.strftime(&#34;%Y-%m-%dT%H:%M:%SZ&#34;)
        if date is None:
            date = datetime.datetime.today().strftime(&#34;%Y-%m-%dT%H:%M:%SZ&#34;)

        stix_relation_result = None
        if StixObservableRelationTypes.has_value(stix_relation[&#34;relationship_type&#34;]):
            stix_relation_result = self.opencti.stix_observable_relation.create(
                fromId=source_id,
                fromType=source_type,
                toId=target_id,
                toType=target_type,
                relationship_type=stix_relation[&#34;relationship_type&#34;],
                description=self.convert_markdown(stix_relation[&#34;description&#34;])
                if &#34;description&#34; in stix_relation
                else None,
                first_seen=stix_relation[CustomProperties.FIRST_SEEN]
                if CustomProperties.FIRST_SEEN in stix_relation
                else date,
                last_seen=stix_relation[CustomProperties.LAST_SEEN]
                if CustomProperties.LAST_SEEN in stix_relation
                else date,
                weight=stix_relation[CustomProperties.WEIGHT]
                if CustomProperties.WEIGHT in stix_relation
                else 1,
                role_played=stix_relation[CustomProperties.ROLE_PLAYED]
                if CustomProperties.ROLE_PLAYED in stix_relation
                else None,
                id=stix_relation[CustomProperties.ID]
                if CustomProperties.ID in stix_relation
                else None,
                stix_id_key=stix_relation[&#34;id&#34;] if &#34;id&#34; in stix_relation else None,
                created=stix_relation[&#34;created&#34;]
                if &#34;created&#34; in stix_relation
                else None,
                modified=stix_relation[&#34;modified&#34;]
                if &#34;modified&#34; in stix_relation
                else None,
                createdByRef=extras[&#34;created_by_ref_id&#34;]
                if &#34;created_by_ref_id&#34; in extras
                else None,
                markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
                if &#34;marking_definitions_ids&#34; in extras
                else [],
                killChainPhases=extras[&#34;kill_chain_phases_ids&#34;]
                if &#34;kill_chain_phases_ids&#34; in extras
                else [],
                update=update,
                ignore_dates=stix_relation[CustomProperties.IGNORE_DATES]
                if CustomProperties.IGNORE_DATES in stix_relation
                else None,
            )
        else:
            stix_relation_result = self.opencti.stix_relation.create(
                fromId=source_id,
                fromType=source_type,
                toId=target_id,
                toType=target_type,
                relationship_type=stix_relation[&#34;relationship_type&#34;],
                description=self.convert_markdown(stix_relation[&#34;description&#34;])
                if &#34;description&#34; in stix_relation
                else None,
                first_seen=stix_relation[CustomProperties.FIRST_SEEN]
                if CustomProperties.FIRST_SEEN in stix_relation
                else date,
                last_seen=stix_relation[CustomProperties.LAST_SEEN]
                if CustomProperties.LAST_SEEN in stix_relation
                else date,
                weight=stix_relation[CustomProperties.WEIGHT]
                if CustomProperties.WEIGHT in stix_relation
                else 1,
                role_played=stix_relation[CustomProperties.ROLE_PLAYED]
                if CustomProperties.ROLE_PLAYED in stix_relation
                else None,
                id=stix_relation[CustomProperties.ID]
                if CustomProperties.ID in stix_relation
                else None,
                stix_id_key=stix_relation[&#34;id&#34;] if &#34;id&#34; in stix_relation else None,
                created=stix_relation[&#34;created&#34;]
                if &#34;created&#34; in stix_relation
                else None,
                modified=stix_relation[&#34;modified&#34;]
                if &#34;modified&#34; in stix_relation
                else None,
                createdByRef=extras[&#34;created_by_ref_id&#34;]
                if &#34;created_by_ref_id&#34; in extras
                else None,
                markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
                if &#34;marking_definitions_ids&#34; in extras
                else [],
                killChainPhases=extras[&#34;kill_chain_phases_ids&#34;]
                if &#34;kill_chain_phases_ids&#34; in extras
                else [],
                update=update,
                ignore_dates=stix_relation[CustomProperties.IGNORE_DATES]
                if CustomProperties.IGNORE_DATES in stix_relation
                else None,
            )
        if stix_relation_result is not None:
            self.mapping_cache[stix_relation[&#34;id&#34;]] = {
                &#34;id&#34;: stix_relation_result[&#34;id&#34;],
                &#34;type&#34;: stix_relation_result[&#34;entity_type&#34;],
            }
        else:
            return None

        # Add external references
        for external_reference_id in external_references_ids:
            self.opencti.stix_entity.add_external_reference(
                id=stix_relation_result[&#34;id&#34;],
                external_reference_id=external_reference_id,
            )
            if external_reference_id in reports:
                self.opencti.report.add_stix_entity(
                    id=reports[external_reference_id][&#34;id&#34;],
                    entity_id=stix_relation_result[&#34;id&#34;],
                )
                self.opencti.report.add_stix_entity(
                    id=reports[external_reference_id][&#34;id&#34;], entity_id=source_id,
                )
                self.opencti.report.add_stix_entity(
                    id=reports[external_reference_id][&#34;id&#34;], entity_id=target_id,
                )

    def import_observables(self, stix_object):
        # Extract
        embedded_relationships = self.extract_embedded_relationships(stix_object)
        created_by_ref_id = embedded_relationships[&#34;created_by_ref&#34;]
        marking_definitions_ids = embedded_relationships[&#34;marking_definitions&#34;]

        observables_to_create = {}
        relations_to_create = []
        for key, observable_item in stix_object[&#34;objects&#34;].items():
            # TODO artifact
            if (
                CustomProperties.OBSERVABLE_TYPE in observable_item
                and CustomProperties.OBSERVABLE_VALUE in observable_item
            ):
                observables_to_create[key] = [
                    {
                        &#34;id&#34;: str(uuid.uuid4()),
                        &#34;stix_id&#34;: &#34;observable--&#34; + str(uuid.uuid4()),
                        &#34;type&#34;: observable_item[CustomProperties.OBSERVABLE_TYPE],
                        &#34;value&#34;: observable_item[CustomProperties.OBSERVABLE_VALUE],
                    }
                ]
            elif observable_item[&#34;type&#34;] == &#34;autonomous-system&#34;:
                observables_to_create[key] = [
                    {
                        &#34;id&#34;: str(uuid.uuid4()),
                        &#34;stix_id&#34;: &#34;observable--&#34; + str(uuid.uuid4()),
                        &#34;type&#34;: ObservableTypes.AUTONOMOUS_SYSTEM.value,
                        &#34;value&#34;: &#34;AS&#34; + observable_item[&#34;number&#34;],
                    }
                ]
            elif observable_item[&#34;type&#34;] == &#34;directory&#34;:
                observables_to_create[key] = [
                    {
                        &#34;id&#34;: str(uuid.uuid4()),
                        &#34;stix_id&#34;: &#34;observable--&#34; + str(uuid.uuid4()),
                        &#34;type&#34;: ObservableTypes.DIRECTORY.value,
                        &#34;value&#34;: observable_item[&#34;path&#34;],
                    }
                ]
            elif observable_item[&#34;type&#34;] == &#34;domain-name&#34;:
                observables_to_create[key] = [
                    {
                        &#34;id&#34;: str(uuid.uuid4()),
                        &#34;stix_id&#34;: &#34;observable--&#34; + str(uuid.uuid4()),
                        &#34;type&#34;: ObservableTypes.DOMAIN.value,
                        &#34;value&#34;: observable_item[&#34;value&#34;],
                    }
                ]
            elif observable_item[&#34;type&#34;] == &#34;email-addr&#34;:
                observables_to_create[key] = [
                    {
                        &#34;id&#34;: str(uuid.uuid4()),
                        &#34;stix_id&#34;: &#34;observable--&#34; + str(uuid.uuid4()),
                        &#34;type&#34;: ObservableTypes.EMAIL_ADDR.value,
                        &#34;value&#34;: observable_item[&#34;value&#34;],
                    }
                ]
                # TODO Belongs to ref
            # TODO email-message
            # TODO mime-part-type
            elif observable_item[&#34;type&#34;] == &#34;file&#34;:
                observables_to_create[key] = []
                if &#34;name&#34; in observable_item:
                    observables_to_create[key].append(
                        {
                            &#34;id&#34;: str(uuid.uuid4()),
                            &#34;type&#34;: ObservableTypes.FILE_NAME.value,
                            &#34;value&#34;: observable_item[&#34;name&#34;],
                        }
                    )
                if &#34;hashes&#34; in observable_item:
                    for keyfile, value in observable_item[&#34;hashes&#34;].items():
                        if keyfile == &#34;MD5&#34;:
                            observables_to_create[key].append(
                                {
                                    &#34;id&#34;: str(uuid.uuid4()),
                                    &#34;type&#34;: ObservableTypes.FILE_HASH_MD5.value,
                                    &#34;value&#34;: value,
                                }
                            )
                        if keyfile == &#34;SHA-1&#34;:
                            observables_to_create[key].append(
                                {
                                    &#34;id&#34;: str(uuid.uuid4()),
                                    &#34;type&#34;: ObservableTypes.FILE_HASH_SHA1.value,
                                    &#34;value&#34;: value,
                                }
                            )
                        if keyfile == &#34;SHA-256&#34;:
                            observables_to_create[key].append(
                                {
                                    &#34;id&#34;: str(uuid.uuid4()),
                                    &#34;type&#34;: ObservableTypes.FILE_HASH_SHA256.value,
                                    &#34;value&#34;: value,
                                }
                            )
            elif observable_item[&#34;type&#34;] == &#34;ipv4-addr&#34;:
                observables_to_create[key] = [
                    {
                        &#34;id&#34;: str(uuid.uuid4()),
                        &#34;type&#34;: ObservableTypes.IPV4_ADDR.value,
                        &#34;value&#34;: observable_item[&#34;value&#34;],
                    }
                ]
            elif observable_item[&#34;type&#34;] == &#34;ipv6-addr&#34;:
                observables_to_create[key] = [
                    {
                        &#34;id&#34;: str(uuid.uuid4()),
                        &#34;type&#34;: ObservableTypes.IPV6_ADDR.value,
                        &#34;value&#34;: observable_item[&#34;value&#34;],
                    }
                ]
            elif observable_item[&#34;type&#34;] == &#34;mac-addr&#34;:
                observables_to_create[key] = [
                    {
                        &#34;id&#34;: str(uuid.uuid4()),
                        &#34;type&#34;: ObservableTypes.MAC_ADDR.value,
                        &#34;value&#34;: observable_item[&#34;value&#34;],
                    }
                ]
            elif observable_item[&#34;type&#34;] == &#34;windows-registry-key&#34;:
                observables_to_create[key] = [
                    {
                        &#34;id&#34;: str(uuid.uuid4()),
                        &#34;type&#34;: ObservableTypes.REGISTRY_KEY.value,
                        &#34;value&#34;: observable_item[&#34;key&#34;],
                    }
                ]

        for key, observable_item in stix_object[&#34;objects&#34;].items():
            if observable_item[&#34;type&#34;] == &#34;directory&#34;:
                if &#34;contains_refs&#34; in observable_item:
                    for file in observable_item[&#34;contains_refs&#34;]:
                        for observable_to_create_from in observables_to_create[key]:
                            for observables_to_create_to in observables_to_create[file]:
                                if (
                                    observable_to_create_from[&#34;id&#34;]
                                    != observables_to_create_to[&#34;id&#34;]
                                ):
                                    relations_to_create.append(
                                        {
                                            &#34;id&#34;: str(uuid.uuid4()),
                                            &#34;from&#34;: observable_to_create_from[&#34;id&#34;],
                                            &#34;to&#34;: observables_to_create_to[&#34;id&#34;],
                                            &#34;type&#34;: &#34;contains&#34;,
                                        }
                                    )
            if observable_item[&#34;type&#34;] == &#34;domain-name&#34;:
                if &#34;resolves_to_refs&#34; in observable_item:
                    for resolved in observable_item[&#34;resolves_to_refs&#34;]:
                        for observable_to_create_from in observables_to_create[key]:
                            for observables_to_create_to in observables_to_create[
                                resolved
                            ]:
                                if (
                                    observable_to_create_from[&#34;id&#34;]
                                    != observables_to_create_to[&#34;id&#34;]
                                ):
                                    relations_to_create.append(
                                        {
                                            &#34;id&#34;: str(uuid.uuid4()),
                                            &#34;from&#34;: observable_to_create_from[&#34;id&#34;],
                                            &#34;fromType&#34;: observable_to_create_from[
                                                &#34;type&#34;
                                            ],
                                            &#34;to&#34;: observables_to_create_to[&#34;id&#34;],
                                            &#34;toType&#34;: observables_to_create_to[&#34;type&#34;],
                                            &#34;type&#34;: &#34;resolves&#34;,
                                        }
                                    )
            if observable_item[&#34;type&#34;] == &#34;file&#34;:
                for observable_to_create_from in observables_to_create[key]:
                    for observables_to_create_to in observables_to_create[key]:
                        if (
                            observable_to_create_from[&#34;id&#34;]
                            != observables_to_create_to[&#34;id&#34;]
                        ):
                            relations_to_create.append(
                                {
                                    &#34;id&#34;: str(uuid.uuid4()),
                                    &#34;from&#34;: observable_to_create_from[&#34;id&#34;],
                                    &#34;fromType&#34;: observable_to_create_from[&#34;type&#34;],
                                    &#34;to&#34;: observables_to_create_to[&#34;id&#34;],
                                    &#34;toType&#34;: observables_to_create_to[&#34;type&#34;],
                                    &#34;type&#34;: &#34;corresponds&#34;,
                                }
                            )
            if observable_item[&#34;type&#34;] == &#34;ipv4-addr&#34;:
                if &#34;belongs_to_refs&#34; in observable_item:
                    for belonging in observable_item[&#34;belongs_to_refs&#34;]:
                        for observable_to_create_from in observables_to_create[key]:
                            for observables_to_create_to in observables_to_create[
                                belonging
                            ]:
                                if (
                                    observable_to_create_from[&#34;id&#34;]
                                    != observables_to_create_to[&#34;id&#34;]
                                ):
                                    relations_to_create.append(
                                        {
                                            &#34;id&#34;: str(uuid.uuid4()),
                                            &#34;from&#34;: observable_to_create_from[&#34;id&#34;],
                                            &#34;fromType&#34;: observable_to_create_from[
                                                &#34;type&#34;
                                            ],
                                            &#34;to&#34;: observables_to_create_to[&#34;id&#34;],
                                            &#34;toType&#34;: observables_to_create_to[&#34;type&#34;],
                                            &#34;type&#34;: &#34;belongs&#34;,
                                        }
                                    )

        stix_observables_mapping = {}
        self.mapping_cache[stix_object[&#34;id&#34;]] = []
        for key, observable_to_create in observables_to_create.items():
            for observable in observable_to_create:
                observable_result = self.opencti.stix_observable.create(
                    type=observable[&#34;type&#34;],
                    observable_value=observable[&#34;value&#34;],
                    id=observable[&#34;id&#34;],
                    createdByRef=created_by_ref_id,
                    markingDefinitions=marking_definitions_ids,
                    createIndicator=stix_object[CustomProperties.CREATE_INDICATOR]
                    if CustomProperties.CREATE_INDICATOR in stix_object
                    else False,
                )
                stix_observables_mapping[observable[&#34;id&#34;]] = observable_result[&#34;id&#34;]
                self.mapping_cache[stix_object[&#34;id&#34;]].append(
                    {
                        &#34;id&#34;: observable_result[&#34;id&#34;],
                        &#34;type&#34;: observable_result[&#34;entity_type&#34;],
                    }
                )

        stix_observable_relations_mapping = {}
        for relation_to_create in relations_to_create:
            stix_observable_relation_result = self.opencti.stix_observable_relation.create(
                fromId=stix_observables_mapping[relation_to_create[&#34;from&#34;]],
                fromType=relation_to_create[&#34;fromType&#34;],
                toId=stix_observables_mapping[relation_to_create[&#34;to&#34;]],
                toType=relation_to_create[&#34;toType&#34;],
                relationship_type=relation_to_create[&#34;type&#34;],
                createdByRef=created_by_ref_id,
                markingDefinitions=marking_definitions_ids,
            )
            stix_observable_relations_mapping[
                relation_to_create[&#34;id&#34;]
            ] = stix_observable_relation_result[&#34;id&#34;]

    def export_entity(
        self, entity_type, entity_id, mode=&#34;simple&#34;, max_marking_definition=None
    ):
        max_marking_definition_entity = (
            self.opencti.marking_definition.read(id=max_marking_definition)
            if max_marking_definition is not None
            else None
        )
        bundle = {
            &#34;type&#34;: &#34;bundle&#34;,
            &#34;id&#34;: &#34;bundle--&#34; + str(uuid.uuid4()),
            &#34;objects&#34;: [],
        }
        # Map types
        if IdentityTypes.has_value(entity_type):
            entity_type = &#34;identity&#34;

        # Export
        exporter = {
            &#34;identity&#34;: self.opencti.identity.to_stix2,
            &#34;threat-actor&#34;: self.opencti.threat_actor.to_stix2,
            &#34;intrusion-set&#34;: self.opencti.intrusion_set.to_stix2,
            &#34;campaign&#34;: self.opencti.campaign.to_stix2,
            &#34;incident&#34;: self.opencti.incident.to_stix2,
            &#34;malware&#34;: self.opencti.malware.to_stix2,
            &#34;tool&#34;: self.opencti.tool.to_stix2,
            &#34;vulnerability&#34;: self.opencti.vulnerability.to_stix2,
            &#34;attack-pattern&#34;: self.opencti.attack_pattern.to_stix2,
            &#34;course-of-action&#34;: self.opencti.course_of_action.to_stix2,
            &#34;report&#34;: self.opencti.report.to_stix2,
            &#34;note&#34;: self.opencti.note.to_stix2,
            &#34;opinion&#34;: self.opencti.opinion.to_stix2,
            &#34;indicator&#34;: self.opencti.indicator.to_stix2,
        }
        do_export = exporter.get(
            entity_type, lambda **kwargs: self.unknown_type({&#34;type&#34;: entity_type})
        )
        objects = do_export(
            id=entity_id,
            mode=mode,
            max_marking_definition_entity=max_marking_definition_entity,
        )
        if objects is not None:
            bundle[&#34;objects&#34;].extend(objects)
        return bundle

    def export_list(
        self,
        entity_type,
        search=None,
        filters=None,
        order_by=None,
        order_mode=None,
        max_marking_definition=None,
    ):
        max_marking_definition_entity = (
            self.opencti.marking_definition.read(id=max_marking_definition)
            if max_marking_definition is not None
            else None
        )
        bundle = {
            &#34;type&#34;: &#34;bundle&#34;,
            &#34;id&#34;: &#34;bundle--&#34; + str(uuid.uuid4()),
            &#34;objects&#34;: [],
        }

        if IdentityTypes.has_value(entity_type):
            if filters is not None:
                filters.append({&#34;key&#34;: &#34;entity_type&#34;, &#34;values&#34;: [entity_type]})
            else:
                filters = [{&#34;key&#34;: &#34;entity_type&#34;, &#34;values&#34;: [entity_type]}]
            entity_type = &#34;identity&#34;

        # List
        lister = {
            &#34;identity&#34;: self.opencti.identity.list,
            &#34;threat-actor&#34;: self.opencti.threat_actor.list,
            &#34;intrusion-set&#34;: self.opencti.intrusion_set.list,
            &#34;campaign&#34;: self.opencti.campaign.list,
            &#34;incident&#34;: self.opencti.incident.list,
            &#34;malware&#34;: self.opencti.malware.list,
            &#34;tool&#34;: self.opencti.tool.list,
            &#34;vulnerability&#34;: self.opencti.vulnerability.list,
            &#34;attack-pattern&#34;: self.opencti.attack_pattern.list,
            &#34;course-of-action&#34;: self.opencti.course_of_action.list,
            &#34;report&#34;: self.opencti.report.list,
            &#34;note&#34;: self.opencti.note.list,
            &#34;opinion&#34;: self.opencti.opinion.list,
            &#34;indicator&#34;: self.opencti.indicator.list,
        }
        do_list = lister.get(
            entity_type, lambda **kwargs: self.unknown_type({&#34;type&#34;: entity_type})
        )
        entities_list = do_list(
            search=search,
            filters=filters,
            orderBy=order_by,
            orderMode=order_mode,
            getAll=True,
        )

        if entities_list is not None:
            # Export
            exporter = {
                &#34;identity&#34;: self.opencti.identity.to_stix2,
                &#34;threat-actor&#34;: self.opencti.threat_actor.to_stix2,
                &#34;intrusion-set&#34;: self.opencti.intrusion_set.to_stix2,
                &#34;campaign&#34;: self.opencti.campaign.to_stix2,
                &#34;incident&#34;: self.opencti.incident.to_stix2,
                &#34;malware&#34;: self.opencti.malware.to_stix2,
                &#34;tool&#34;: self.opencti.tool.to_stix2,
                &#34;vulnerability&#34;: self.opencti.vulnerability.to_stix2,
                &#34;attack-pattern&#34;: self.opencti.attack_pattern.to_stix2,
                &#34;course-of-action&#34;: self.opencti.course_of_action.to_stix2,
                &#34;report&#34;: self.opencti.report.to_stix2,
                &#34;note&#34;: self.opencti.note.to_stix2,
                &#34;opinion&#34;: self.opencti.opinion.to_stix2,
                &#34;indicator&#34;: self.opencti.indicator.to_stix2,
            }
            do_export = exporter.get(
                entity_type, lambda **kwargs: self.unknown_type({&#34;type&#34;: entity_type})
            )
            uuids = []
            for entity in entities_list:
                entity_bundle = do_export(
                    entity=entity,
                    max_marking_definition_entity=max_marking_definition_entity,
                )
                if entity_bundle is not None:
                    entity_bundle_filtered = self.filter_objects(uuids, entity_bundle)
                    for x in entity_bundle_filtered:
                        uuids.append(x[&#34;id&#34;])
                    bundle[&#34;objects&#34;] = bundle[&#34;objects&#34;] + entity_bundle_filtered

        return bundle

    def prepare_export(
        self, entity, stix_object, mode=&#34;simple&#34;, max_marking_definition_entity=None
    ):
        if (
            self.check_max_marking_definition(
                max_marking_definition_entity, entity[&#34;markingDefinitions&#34;]
            )
            is False
        ):
            self.opencti.log(
                &#34;info&#34;,
                &#34;Marking definitions of &#34;
                + stix_object[&#34;type&#34;]
                + &#39; &#34;&#39;
                + stix_object[&#34;name&#34;]
                + &#39;&#34; are less than max definition, not exporting.&#39;,
            )
            return []
        result = []
        objects_to_get = []
        relations_to_get = []
        if &#34;createdByRef&#34; in entity and entity[&#34;createdByRef&#34;] is not None:
            entity_created_by_ref = entity[&#34;createdByRef&#34;]
            if entity_created_by_ref[&#34;entity_type&#34;] == &#34;user&#34;:
                identity_class = &#34;individual&#34;
            elif entity_created_by_ref[&#34;entity_type&#34;] == &#34;sector&#34;:
                identity_class = &#34;class&#34;
            else:
                identity_class = entity_created_by_ref[&#34;entity_type&#34;]

            created_by_ref = dict()
            created_by_ref[&#34;id&#34;] = entity_created_by_ref[&#34;stix_id_key&#34;]
            created_by_ref[&#34;type&#34;] = &#34;identity&#34;
            created_by_ref[&#34;name&#34;] = entity_created_by_ref[&#34;name&#34;]
            created_by_ref[&#34;identity_class&#34;] = identity_class
            if self.opencti.not_empty(entity_created_by_ref[&#34;stix_label&#34;]):
                created_by_ref[&#34;labels&#34;] = entity_created_by_ref[&#34;stix_label&#34;]
            else:
                created_by_ref[&#34;labels&#34;] = [&#34;identity&#34;]
            created_by_ref[&#34;created&#34;] = self.format_date(
                entity_created_by_ref[&#34;created&#34;]
            )
            created_by_ref[&#34;modified&#34;] = self.format_date(
                entity_created_by_ref[&#34;modified&#34;]
            )
            if (
                entity_created_by_ref[&#34;entity_type&#34;] == &#34;organization&#34;
                and &#34;organization_class&#34; in entity_created_by_ref
            ):
                created_by_ref[CustomProperties.ORG_CLASS] = entity_created_by_ref[
                    &#34;organization_class&#34;
                ]
            if self.opencti.not_empty(entity_created_by_ref[&#34;alias&#34;]):
                created_by_ref[CustomProperties.ALIASES] = entity_created_by_ref[
                    &#34;alias&#34;
                ]
            created_by_ref[CustomProperties.IDENTITY_TYPE] = entity_created_by_ref[
                &#34;entity_type&#34;
            ]
            created_by_ref[CustomProperties.ID] = entity_created_by_ref[&#34;id&#34;]

            stix_object[&#34;created_by_ref&#34;] = created_by_ref[&#34;id&#34;]
            result.append(created_by_ref)
        if &#34;markingDefinitions&#34; in entity and len(entity[&#34;markingDefinitions&#34;]) &gt; 0:
            marking_definitions = []
            for entity_marking_definition in entity[&#34;markingDefinitions&#34;]:
                marking_definition = {
                    &#34;id&#34;: entity_marking_definition[&#34;stix_id_key&#34;],
                    &#34;type&#34;: &#34;marking-definition&#34;,
                    &#34;definition_type&#34;: entity_marking_definition[
                        &#34;definition_type&#34;
                    ].lower(),
                    &#34;definition&#34;: {
                        entity_marking_definition[
                            &#34;definition_type&#34;
                        ]: entity_marking_definition[&#34;definition&#34;]
                    },
                    &#34;created&#34;: entity_marking_definition[&#34;created&#34;],
                    CustomProperties.MODIFIED: entity_marking_definition[&#34;modified&#34;],
                    CustomProperties.ID: entity_marking_definition[&#34;id&#34;],
                }
                marking_definitions.append(marking_definition[&#34;id&#34;])
                result.append(marking_definition)
            stix_object[&#34;object_marking_refs&#34;] = marking_definitions
        if &#34;tags&#34; in entity and len(entity[&#34;tags&#34;]) &gt; 0:
            tags = []
            for entity_tag in entity[&#34;tags&#34;]:
                tag = dict()
                tag[&#34;id&#34;] = entity_tag[&#34;id&#34;]
                tag[&#34;tag_type&#34;] = entity_tag[&#34;tag_type&#34;]
                tag[&#34;value&#34;] = entity_tag[&#34;value&#34;]
                tag[&#34;color&#34;] = entity_tag[&#34;color&#34;]
                tags.append(tag)
            stix_object[CustomProperties.TAG_TYPE] = tags
        if &#34;killChainPhases&#34; in entity and len(entity[&#34;killChainPhases&#34;]) &gt; 0:
            kill_chain_phases = []
            for entity_kill_chain_phase in entity[&#34;killChainPhases&#34;]:
                kill_chain_phase = {
                    &#34;id&#34;: entity_kill_chain_phase[&#34;stix_id_key&#34;],
                    &#34;kill_chain_name&#34;: entity_kill_chain_phase[&#34;kill_chain_name&#34;],
                    &#34;phase_name&#34;: entity_kill_chain_phase[&#34;phase_name&#34;],
                    CustomProperties.ID: entity_kill_chain_phase[&#34;id&#34;],
                    CustomProperties.PHASE_ORDER: entity_kill_chain_phase[
                        &#34;phase_order&#34;
                    ],
                    CustomProperties.CREATED: entity_kill_chain_phase[&#34;created&#34;],
                    CustomProperties.MODIFIED: entity_kill_chain_phase[&#34;modified&#34;],
                }
                kill_chain_phases.append(kill_chain_phase)
            stix_object[&#34;kill_chain_phases&#34;] = kill_chain_phases
        if &#34;externalReferences&#34; in entity and len(entity[&#34;externalReferences&#34;]) &gt; 0:
            external_references = []
            for entity_external_reference in entity[&#34;externalReferences&#34;]:
                external_reference = dict()
                external_reference[&#34;id&#34;] = entity_external_reference[&#34;stix_id_key&#34;]
                if self.opencti.not_empty(entity_external_reference[&#34;source_name&#34;]):
                    external_reference[&#34;source_name&#34;] = entity_external_reference[
                        &#34;source_name&#34;
                    ]
                if self.opencti.not_empty(entity_external_reference[&#34;description&#34;]):
                    external_reference[&#34;description&#34;] = entity_external_reference[
                        &#34;description&#34;
                    ]
                if self.opencti.not_empty(entity_external_reference[&#34;url&#34;]):
                    external_reference[&#34;url&#34;] = entity_external_reference[&#34;url&#34;]
                if self.opencti.not_empty(entity_external_reference[&#34;hash&#34;]):
                    external_reference[&#34;hash&#34;] = entity_external_reference[&#34;hash&#34;]
                if self.opencti.not_empty(entity_external_reference[&#34;external_id&#34;]):
                    external_reference[&#34;external_id&#34;] = entity_external_reference[
                        &#34;external_id&#34;
                    ]
                external_reference[CustomProperties.ID] = entity_external_reference[
                    &#34;id&#34;
                ]
                external_reference[
                    CustomProperties.CREATED
                ] = entity_external_reference[&#34;created&#34;]
                external_reference[
                    CustomProperties.MODIFIED
                ] = entity_external_reference[&#34;modified&#34;]
                external_references.append(external_reference)
            stix_object[&#34;external_references&#34;] = external_references
        if &#34;objectRefs&#34; in entity and len(entity[&#34;objectRefs&#34;]) &gt; 0:
            object_refs = []
            objects_to_get = entity[&#34;objectRefs&#34;]
            for entity_object_ref in entity[&#34;objectRefs&#34;]:
                object_refs.append(entity_object_ref[&#34;stix_id_key&#34;])
            if &#34;relationRefs&#34; in entity and len(entity[&#34;relationRefs&#34;]) &gt; 0:
                relations_to_get = entity[&#34;relationRefs&#34;]
                for entity_relation_ref in entity[&#34;relationRefs&#34;]:
                    if entity_relation_ref[&#34;stix_id_key&#34;] not in object_refs:
                        object_refs.append(entity_relation_ref[&#34;stix_id_key&#34;])
            stix_object[&#34;object_refs&#34;] = object_refs

        uuids = []
        for x in result:
            uuids.append(x[&#34;id&#34;])

        observables_stix_ids = []
        observable_object_data = None
        if &#34;observableRefs&#34; in entity and len(entity[&#34;observableRefs&#34;]) &gt; 0:
            observable_object_data = self.export_stix_observables(entity)
            if observable_object_data is not None:
                observable_object_bundle = self.filter_objects(
                    uuids, [observable_object_data[&#34;observedData&#34;]]
                )
                uuids = uuids + [x[&#34;id&#34;] for x in observable_object_bundle]
                result = result + observable_object_bundle
                observables_stix_ids = (
                    observables_stix_ids + observable_object_data[&#34;stixIds&#34;]
                )
                if stix_object[&#34;type&#34;] == &#34;report&#34;:
                    if &#34;object_refs&#34; in stix_object:
                        stix_object[&#34;object_refs&#34;].append(
                            observable_object_data[&#34;observedData&#34;][&#34;id&#34;]
                        )
                    else:
                        stix_object[&#34;object_refs&#34;] = [
                            observable_object_data[&#34;observedData&#34;][&#34;id&#34;]
                        ]
        result.append(stix_object)

        if mode == &#34;simple&#34;:
            return result
        elif mode == &#34;full&#34;:
            # Get extra relations
            stix_relations = self.opencti.stix_relation.list(
                fromId=entity[&#34;id&#34;], forceNatural=True
            )
            for stix_relation in stix_relations:
                if self.check_max_marking_definition(
                    max_marking_definition_entity, stix_relation[&#34;markingDefinitions&#34;]
                ):
                    if stix_relation[&#34;to&#34;][&#34;id&#34;] == entity[&#34;id&#34;]:
                        other_side_entity = stix_relation[&#34;from&#34;]
                    else:
                        other_side_entity = stix_relation[&#34;to&#34;]
                    objects_to_get.append(other_side_entity)
                    if other_side_entity[&#34;stix_id_key&#34;] in observables_stix_ids:
                        other_side_entity[&#34;stix_id_key&#34;] = observable_object_data[
                            &#34;observedData&#34;
                        ][&#34;id&#34;]
                    relation_object_data = self.opencti.stix_relation.to_stix2(
                        entity=stix_relation
                    )
                    relation_object_bundle = self.filter_objects(
                        uuids, relation_object_data
                    )
                    uuids = uuids + [x[&#34;id&#34;] for x in relation_object_bundle]
                    result = result + relation_object_bundle
                else:
                    self.opencti.log(
                        &#34;info&#34;,
                        &#34;Marking definitions of &#34;
                        + stix_relation[&#34;entity_type&#34;]
                        + &#39; &#34;&#39;
                        + stix_relation[&#34;id&#34;]
                        + &#39;&#34; are less than max definition, not exporting the relation AND the target entity.&#39;,
                    )

            # Export
            exporter = {
                &#34;identity&#34;: self.opencti.identity.to_stix2,
                &#34;threat-actor&#34;: self.opencti.threat_actor.to_stix2,
                &#34;intrusion-set&#34;: self.opencti.intrusion_set.to_stix2,
                &#34;campaign&#34;: self.opencti.campaign.to_stix2,
                &#34;incident&#34;: self.opencti.incident.to_stix2,
                &#34;malware&#34;: self.opencti.malware.to_stix2,
                &#34;tool&#34;: self.opencti.tool.to_stix2,
                &#34;vulnerability&#34;: self.opencti.vulnerability.to_stix2,
                &#34;attack-pattern&#34;: self.opencti.attack_pattern.to_stix2,
                &#34;course-of-action&#34;: self.opencti.course_of_action.to_stix2,
                &#34;report&#34;: self.opencti.report.to_stix2,
                &#34;note&#34;: self.opencti.note.to_stix2,
                &#34;opinion&#34;: self.opencti.opinion.to_stix2,
                &#34;indicator&#34;: self.opencti.indicator.to_stix2,
            }

            # Get extra objects
            for entity_object in objects_to_get:
                # Map types
                if IdentityTypes.has_value(entity_object[&#34;entity_type&#34;]):
                    entity_object[&#34;entity_type&#34;] = &#34;identity&#34;
                do_export = exporter.get(
                    entity_object[&#34;entity_type&#34;],
                    lambda **kwargs: self.unknown_type(
                        {&#34;type&#34;: entity_object[&#34;entity_type&#34;]}
                    ),
                )
                entity_object_data = do_export(id=entity_object[&#34;id&#34;])
                # Add to result
                entity_object_bundle = self.filter_objects(uuids, entity_object_data)
                uuids = uuids + [x[&#34;id&#34;] for x in entity_object_bundle]
                result = result + entity_object_bundle
            for relation_object in relations_to_get:
                relation_object_data = self.opencti.stix_relation.to_stix2(
                    id=relation_object[&#34;id&#34;]
                )
                relation_object_bundle = self.filter_objects(
                    uuids, relation_object_data
                )
                uuids = uuids + [x[&#34;id&#34;] for x in relation_object_bundle]
                result = result + relation_object_bundle

            # Get extra reports
            &#34;&#34;&#34;
            for uuid in uuids:
                if &#34;marking-definition&#34; not in uuid:
                    reports = self.opencti.stix_entity.reports(id=uuid)
                    for report in reports:
                        report_object_data = self.opencti.report.to_stix2(
                            entity=report,
                            mode=&#34;simple&#34;,
                            max_marking_definition_entity=max_marking_definition_entity,
                        )
                        report_object_bundle = self.filter_objects(
                            uuids, report_object_data
                        )
                        uuids = uuids + [x[&#34;id&#34;] for x in report_object_bundle]
                        result = result + report_object_bundle
            &#34;&#34;&#34;

            # Refilter all the reports object refs
            final_result = []
            for entity in result:
                if entity[&#34;type&#34;] == &#34;report&#34;:
                    if &#34;object_refs&#34; in entity:
                        entity[&#34;object_refs&#34;] = [
                            k for k in entity[&#34;object_refs&#34;] if k in uuids
                        ]
                    final_result.append(entity)
                else:
                    final_result.append(entity)
            return final_result
        else:
            return []

    # TODO move in MarkingDefinition
    def create_marking_definition(self, stix_object, extras, update=False):
        definition_type = stix_object[&#34;definition_type&#34;]
        definition = stix_object[&#34;definition&#34;][stix_object[&#34;definition_type&#34;]]
        if stix_object[&#34;definition_type&#34;] == &#34;tlp&#34;:
            definition_type = &#34;TLP&#34;
            definition = (
                &#34;TLP:&#34;
                + stix_object[&#34;definition&#34;][stix_object[&#34;definition_type&#34;]].upper()
            )
        return self.opencti.marking_definition.create(
            definition_type=definition_type,
            definition=definition,
            level=stix_object[CustomProperties.LEVEL]
            if CustomProperties.LEVEL in stix_object
            else 0,
            color=stix_object[CustomProperties.COLOR]
            if CustomProperties.COLOR in stix_object
            else None,
            id=stix_object[CustomProperties.ID]
            if CustomProperties.ID in stix_object
            else None,
            stix_id_key=stix_object[&#34;id&#34;],
            created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
            modified=stix_object[CustomProperties.MODIFIED]
            if CustomProperties.MODIFIED in stix_object
            else None,
            createdByRef=extras[&#34;created_by_ref_id&#34;]
            if &#34;created_by_ref_id&#34; in extras
            else None,
        )

    # TODO move in Identity
    def create_identity(self, stix_object, extras, update=False):
        if CustomProperties.IDENTITY_TYPE in stix_object:
            type = stix_object[CustomProperties.IDENTITY_TYPE].capitalize()
        else:
            if stix_object[&#34;identity_class&#34;] == &#34;individual&#34;:
                type = &#34;User&#34;
            elif stix_object[&#34;identity_class&#34;] == &#34;organization&#34;:
                type = &#34;Organization&#34;
            elif stix_object[&#34;identity_class&#34;] == &#34;group&#34;:
                type = &#34;Organization&#34;
            elif stix_object[&#34;identity_class&#34;] == &#34;class&#34;:
                type = &#34;Sector&#34;
            else:
                return None
        return self.opencti.identity.create(
            type=type,
            name=stix_object[&#34;name&#34;],
            description=self.convert_markdown(stix_object[&#34;description&#34;])
            if &#34;description&#34; in stix_object
            else &#34;&#34;,
            alias=self.pick_aliases(stix_object),
            id=stix_object[CustomProperties.ID]
            if CustomProperties.ID in stix_object
            else None,
            stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
            created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
            modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
            createdByRef=extras[&#34;created_by_ref_id&#34;]
            if &#34;created_by_ref_id&#34; in extras
            else None,
            markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
            if &#34;marking_definitions_ids&#34; in extras
            else [],
            update=update,
        )

    # TODO move in ThreatActor
    def create_threat_actor(self, stix_object, extras, update=False):
        return self.opencti.threat_actor.create(
            name=stix_object[&#34;name&#34;],
            description=self.convert_markdown(stix_object[&#34;description&#34;])
            if &#34;description&#34; in stix_object
            else &#34;&#34;,
            alias=self.pick_aliases(stix_object),
            goal=stix_object[&#34;goals&#34;] if &#34;goals&#34; in stix_object else None,
            sophistication=stix_object[&#34;sophistication&#34;]
            if &#34;sophistication&#34; in stix_object
            else None,
            resource_level=stix_object[&#34;resource_level&#34;]
            if &#34;resource_level&#34; in stix_object
            else None,
            primary_motivaton=stix_object[&#34;primary_motivation&#34;]
            if &#34;primary_motivation&#34; in stix_object
            else None,
            secondary_motivation=stix_object[&#34;secondary_motivations&#34;]
            if &#34;secondary_motivations&#34; in stix_object
            else None,
            personal_motivation=stix_object[&#34;personal_motivations&#34;]
            if &#34;personal_motivations&#34; in stix_object
            else None,
            id=stix_object[CustomProperties.ID]
            if CustomProperties.ID in stix_object
            else None,
            stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
            created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
            modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
            createdByRef=extras[&#34;created_by_ref_id&#34;]
            if &#34;created_by_ref_id&#34; in extras
            else None,
            markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
            if &#34;marking_definitions_ids&#34; in extras
            else [],
            update=update,
        )

    # TODO move in IntrusionSet
    def create_intrusion_set(self, stix_object, extras, update=False):
        return self.opencti.intrusion_set.create(
            name=stix_object[&#34;name&#34;],
            description=self.convert_markdown(stix_object[&#34;description&#34;])
            if &#34;description&#34; in stix_object
            else &#34;&#34;,
            alias=self.pick_aliases(stix_object),
            first_seen=stix_object[CustomProperties.FIRST_SEEN]
            if CustomProperties.FIRST_SEEN in stix_object
            else None,
            last_seen=stix_object[CustomProperties.LAST_SEEN]
            if CustomProperties.LAST_SEEN in stix_object
            else None,
            goal=stix_object[&#34;goals&#34;] if &#34;goals&#34; in stix_object else None,
            sophistication=stix_object[&#34;sophistication&#34;]
            if &#34;sophistication&#34; in stix_object
            else None,
            resource_level=stix_object[&#34;resource_level&#34;]
            if &#34;resource_level&#34; in stix_object
            else None,
            primary_motivation=stix_object[&#34;primary_motivation&#34;]
            if &#34;primary_motivation&#34; in stix_object
            else None,
            secondary_motivation=stix_object[&#34;secondary_motivations&#34;]
            if &#34;secondary_motivations&#34; in stix_object
            else None,
            id=stix_object[CustomProperties.ID]
            if CustomProperties.ID in stix_object
            else None,
            stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
            created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
            modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
            createdByRef=extras[&#34;created_by_ref_id&#34;]
            if &#34;created_by_ref_id&#34; in extras
            else None,
            markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
            if &#34;marking_definitions_ids&#34; in extras
            else [],
            update=update,
        )

    # TODO move in Campaign
    def create_campaign(self, stix_object, extras, update=False):
        return self.opencti.campaign.create(
            name=stix_object[&#34;name&#34;],
            description=self.convert_markdown(stix_object[&#34;description&#34;])
            if &#34;description&#34; in stix_object
            else &#34;&#34;,
            alias=self.pick_aliases(stix_object),
            objective=stix_object[&#34;objective&#34;] if &#34;objective&#34; in stix_object else None,
            first_seen=stix_object[CustomProperties.FIRST_SEEN]
            if CustomProperties.FIRST_SEEN in stix_object
            else None,
            last_seen=stix_object[CustomProperties.LAST_SEEN]
            if CustomProperties.LAST_SEEN in stix_object
            else None,
            id=stix_object[CustomProperties.ID]
            if CustomProperties.ID in stix_object
            else None,
            stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
            created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
            modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
            createdByRef=extras[&#34;created_by_ref_id&#34;]
            if &#34;created_by_ref_id&#34; in extras
            else None,
            markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
            if &#34;marking_definitions_ids&#34; in extras
            else [],
            uodate=update,
        )

    # TODO move in Incident
    def create_incident(self, stix_object, extras, update=False):
        return self.opencti.incident.create(
            name=stix_object[&#34;name&#34;],
            description=self.convert_markdown(stix_object[&#34;description&#34;])
            if &#34;description&#34; in stix_object
            else &#34;&#34;,
            alias=self.pick_aliases(stix_object),
            objective=stix_object[&#34;objective&#34;] if &#34;objective&#34; in stix_object else None,
            first_seen=stix_object[&#34;first_seen&#34;]
            if &#34;first_seen&#34; in stix_object
            else None,
            last_seen=stix_object[&#34;last_seen&#34;] if &#34;last_seen&#34; in stix_object else None,
            id=stix_object[CustomProperties.ID]
            if CustomProperties.ID in stix_object
            else None,
            stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
            created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
            modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
            createdByRef=extras[&#34;created_by_ref_id&#34;]
            if &#34;created_by_ref_id&#34; in extras
            else None,
            markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
            if &#34;marking_definitions_ids&#34; in extras
            else [],
            update=update,
        )

    # TODO move in Malware
    def create_malware(self, stix_object, extras, update=False):
        return self.opencti.malware.create(
            name=stix_object[&#34;name&#34;],
            description=self.convert_markdown(stix_object[&#34;description&#34;])
            if &#34;description&#34; in stix_object
            else &#34;&#34;,
            alias=self.pick_aliases(stix_object),
            id=stix_object[CustomProperties.ID]
            if CustomProperties.ID in stix_object
            else None,
            stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
            created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
            modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
            createdByRef=extras[&#34;created_by_ref_id&#34;]
            if &#34;created_by_ref_id&#34; in extras
            else None,
            markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
            if &#34;marking_definitions_ids&#34; in extras
            else [],
            killChainPhases=extras[&#34;kill_chain_phases_ids&#34;]
            if &#34;kill_chain_phases_ids&#34; in extras
            else [],
            update=update,
        )

    # TODO move in Tool
    def create_tool(self, stix_object, extras, update=False):
        return self.opencti.tool.create(
            name=stix_object[&#34;name&#34;],
            description=self.convert_markdown(stix_object[&#34;description&#34;])
            if &#34;description&#34; in stix_object
            else &#34;&#34;,
            alias=self.pick_aliases(stix_object),
            id=stix_object[CustomProperties.ID]
            if CustomProperties.ID in stix_object
            else None,
            stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
            created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
            modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
            createdByRef=extras[&#34;created_by_ref_id&#34;]
            if &#34;created_by_ref_id&#34; in extras
            else None,
            markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
            if &#34;marking_definitions_ids&#34; in extras
            else [],
            killChainPhases=extras[&#34;kill_chain_phases_ids&#34;]
            if &#34;kill_chain_phases_ids&#34; in extras
            else [],
            update=update,
        )

    # TODO move in Vulnerability
    def create_vulnerability(self, stix_object, extras, update=False):
        return self.opencti.vulnerability.create(
            name=stix_object[&#34;name&#34;],
            description=self.convert_markdown(stix_object[&#34;description&#34;])
            if &#34;description&#34; in stix_object
            else &#34;&#34;,
            base_score=stix_object[CustomProperties.BASE_SCORE]
            if CustomProperties.BASE_SCORE in stix_object
            else None,
            base_severity=stix_object[CustomProperties.BASE_SEVERITY]
            if CustomProperties.BASE_SEVERITY in stix_object
            else None,
            attack_vector=stix_object[CustomProperties.ATTACK_VECTOR]
            if CustomProperties.ATTACK_VECTOR in stix_object
            else None,
            integrity_impact=stix_object[CustomProperties.INTEGRITY_IMPACT]
            if CustomProperties.INTEGRITY_IMPACT in stix_object
            else None,
            availability_impact=stix_object[CustomProperties.AVAILABILITY_IMPACT]
            if CustomProperties.AVAILABILITY_IMPACT in stix_object
            else None,
            alias=self.pick_aliases(stix_object),
            id=stix_object[CustomProperties.ID]
            if CustomProperties.ID in stix_object
            else None,
            stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
            created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
            modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
            createdByRef=extras[&#34;created_by_ref_id&#34;]
            if &#34;created_by_ref_id&#34; in extras
            else None,
            markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
            if &#34;marking_definitions_ids&#34; in extras
            else [],
            update=update,
        )

    def create_attack_pattern(self, stix_object, extras, update=False):
        return self.opencti.attack_pattern.import_from_stix2(
            stixObject=stix_object, extras=extras, update=update
        )

    # TODO move in Course Of Action
    def create_course_of_action(self, stix_object, extras, update=False):
        return self.opencti.course_of_action.create(
            name=stix_object[&#34;name&#34;],
            description=self.convert_markdown(stix_object[&#34;description&#34;])
            if &#34;description&#34; in stix_object
            else &#34;&#34;,
            alias=self.pick_aliases(stix_object),
            id=stix_object[CustomProperties.ID]
            if CustomProperties.ID in stix_object
            else None,
            stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
            created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
            modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
            createdByRef=extras[&#34;created_by_ref_id&#34;]
            if &#34;created_by_ref_id&#34; in extras
            else None,
            markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
            if &#34;marking_definitions_ids&#34; in extras
            else [],
            update=update,
        )

    def create_report(self, stix_object, extras, update=False):
        return self.opencti.report.import_from_stix2(
            stixObject=stix_object, extras=extras, update=update
        )

    def create_note(self, stix_object, extras, update=False):
        return self.opencti.note.import_from_stix2(
            stixObject=stix_object, extras=extras, update=update
        )

    def create_opinion(self, stix_object, extras, update=False):
        return self.opencti.opinion.import_from_stix2(
            stixObject=stix_object, extras=extras, update=update
        )

    def export_stix_observables(self, entity):
        stix_ids = []
        observed_data = dict()
        observed_data[&#34;id&#34;] = &#34;observed-data--&#34; + str(uuid.uuid4())
        observed_data[&#34;type&#34;] = &#34;observed-data&#34;
        observed_data[&#34;number_observed&#34;] = len(entity[&#34;observableRefs&#34;])
        observed_data[&#34;objects&#34;] = []
        for observable in entity[&#34;observableRefs&#34;]:
            stix_observable = dict()
            stix_observable[CustomProperties.OBSERVABLE_TYPE] = observable[
                &#34;entity_type&#34;
            ]
            stix_observable[CustomProperties.OBSERVABLE_VALUE] = observable[
                &#34;observable_value&#34;
            ]
            stix_observable[&#34;type&#34;] = observable[&#34;entity_type&#34;]
            observed_data[&#34;objects&#34;].append(stix_observable)
            stix_ids.append(observable[&#34;stix_id_key&#34;])

        return {&#34;observedData&#34;: observed_data, &#34;stixIds&#34;: stix_ids}

    def create_indicator(self, stix_object, extras, update=False):
        return self.opencti.indicator.create(
            name=stix_object[&#34;name&#34;],
            description=self.convert_markdown(stix_object[&#34;description&#34;])
            if &#34;description&#34; in stix_object
            else &#34;&#34;,
            indicator_pattern=stix_object[CustomProperties.INDICATOR_PATTERN]
            if CustomProperties.INDICATOR_PATTERN in stix_object
            else stix_object[&#34;pattern&#34;],
            main_observable_type=stix_object[CustomProperties.OBSERVABLE_TYPE]
            if CustomProperties.OBSERVABLE_TYPE in stix_object
            else &#34;Unknown&#34;,
            pattern_type=stix_object[CustomProperties.PATTERN_TYPE]
            if CustomProperties.PATTERN_TYPE in stix_object
            else &#34;stix&#34;,
            valid_from=stix_object[&#34;valid_from&#34;]
            if &#34;valid_from&#34; in stix_object
            else None,
            valid_until=stix_object[&#34;valid_until&#34;]
            if &#34;valid_until&#34; in stix_object
            else None,
            id=stix_object[CustomProperties.ID]
            if CustomProperties.ID in stix_object
            else None,
            stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
            created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
            modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
            createdByRef=extras[&#34;created_by_ref_id&#34;]
            if &#34;created_by_ref_id&#34; in extras
            else None,
            markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
            if &#34;marking_definitions_ids&#34; in extras
            else None,
            update=update,
        )

    def resolve_author(self, title):
        if &#34;fireeye&#34; in title.lower() or &#34;mandiant&#34; in title.lower():
            return self.get_author(&#34;FireEye&#34;)
        if &#34;eset&#34; in title.lower():
            return self.get_author(&#34;ESET&#34;)
        if &#34;dragos&#34; in title.lower():
            return self.get_author(&#34;Dragos&#34;)
        if &#34;us-cert&#34; in title.lower():
            return self.get_author(&#34;US-CERT&#34;)
        if (
            &#34;unit 42&#34; in title.lower()
            or &#34;unit42&#34; in title.lower()
            or &#34;palo alto&#34; in title.lower()
        ):
            return self.get_author(&#34;Palo Alto Networks&#34;)
        if &#34;accenture&#34; in title.lower():
            return self.get_author(&#34;Accenture&#34;)
        if &#34;symantec&#34; in title.lower():
            return self.get_author(&#34;Symantec&#34;)
        if &#34;trendmicro&#34; in title.lower() or &#34;trend micro&#34; in title.lower():
            return self.get_author(&#34;Trend Micro&#34;)
        if &#34;mcafee&#34; in title.lower():
            return self.get_author(&#34;McAfee&#34;)
        if &#34;crowdstrike&#34; in title.lower():
            return self.get_author(&#34;CrowdStrike&#34;)
        if &#34;securelist&#34; in title.lower() or &#34;kaspersky&#34; in title.lower():
            return self.get_author(&#34;Kaspersky&#34;)
        if &#34;f-secure&#34; in title.lower():
            return self.get_author(&#34;F-Secure&#34;)
        if &#34;checkpoint&#34; in title.lower():
            return self.get_author(&#34;CheckPoint&#34;)
        if &#34;talos&#34; in title.lower():
            return self.get_author(&#34;Cisco Talos&#34;)
        if &#34;secureworks&#34; in title.lower():
            return self.get_author(&#34;Dell SecureWorks&#34;)
        if &#34;microsoft&#34; in title.lower():
            return self.get_author(&#34;Microsoft&#34;)
        if &#34;mitre att&amp;ck&#34; in title.lower():
            return self.get_author(&#34;The MITRE Corporation&#34;)
        return None

    def get_author(self, name):
        if name in self.mapping_cache:
            return self.mapping_cache[name]
        else:
            author = self.opencti.identity.create(
                type=&#34;Organization&#34;, name=name, description=&#34;&#34;,
            )
            self.mapping_cache[name] = author
            return author

    def import_bundle(self, stix_bundle, update=False, types=None) -&gt; List:
        if types is None:
            types = []

        # Check if the bundle is correctly formatted
        if &#34;type&#34; not in stix_bundle or stix_bundle[&#34;type&#34;] != &#34;bundle&#34;:
            raise ValueError(&#34;JSON data type is not a STIX2 bundle&#34;)
        if &#34;objects&#34; not in stix_bundle or len(stix_bundle[&#34;objects&#34;]) == 0:
            raise ValueError(&#34;JSON data objects is empty&#34;)

        # Import every elements in a specific order
        imported_elements = []

        # Marking definitions
        start_time = time.time()
        for item in stix_bundle[&#34;objects&#34;]:
            if item[&#34;type&#34;] == &#34;marking-definition&#34;:
                self.import_object(item, update, types)
                imported_elements.append({&#34;id&#34;: item[&#34;id&#34;], &#34;type&#34;: item[&#34;type&#34;]})
        end_time = time.time()
        self.opencti.log(
            &#34;info&#34;,
            &#34;Marking definitions imported in: %ssecs&#34; % round(end_time - start_time),
        )

        # Identities
        start_time = time.time()
        for item in stix_bundle[&#34;objects&#34;]:
            if item[&#34;type&#34;] == &#34;identity&#34; and (
                len(types) == 0
                or &#34;identity&#34; in types
                or (
                    CustomProperties.IDENTITY_TYPE in item
                    and item[CustomProperties.IDENTITY_TYPE] in types
                )
            ):
                self.import_object(item, update, types)
                imported_elements.append({&#34;id&#34;: item[&#34;id&#34;], &#34;type&#34;: item[&#34;type&#34;]})
        end_time = time.time()
        self.opencti.log(
            &#34;info&#34;, &#34;Identities imported in: %ssecs&#34; % round(end_time - start_time)
        )

        # StixDomainObjects except Report/Opinion/Notes
        start_time = time.time()
        for item in stix_bundle[&#34;objects&#34;]:
            if (
                item[&#34;type&#34;] != &#34;relationship&#34;
                and item[&#34;type&#34;] != &#34;report&#34;
                and item[&#34;type&#34;] != &#34;note&#34;
                and item[&#34;type&#34;] != &#34;opinion&#34;
                and item[&#34;type&#34;] != &#34;observed-data&#34;
                and (len(types) == 0 or item[&#34;type&#34;] in types)
            ):
                self.import_object(item, update, types)
                imported_elements.append({&#34;id&#34;: item[&#34;id&#34;], &#34;type&#34;: item[&#34;type&#34;]})
        end_time = time.time()
        self.opencti.log(
            &#34;info&#34;, &#34;Objects imported in: %ssecs&#34; % round(end_time - start_time)
        )

        # StixCyberObservables
        start_time = time.time()
        for item in stix_bundle[&#34;objects&#34;]:
            if item[&#34;type&#34;] == &#34;observed-data&#34; and (
                len(types) == 0 or &#34;observed-data&#34; in types
            ):
                self.import_observables(item)
        end_time = time.time()
        self.opencti.log(
            &#34;info&#34;, &#34;Observables imported in: %ssecs&#34; % round(end_time - start_time)
        )

        # StixRelationObjects
        start_time = time.time()
        for item in stix_bundle[&#34;objects&#34;]:
            if item[&#34;type&#34;] == &#34;relationship&#34;:
                # Import only relationships between entities
                if (
                    CustomProperties.SOURCE_REF not in item
                    or &#34;relationship&#34; not in item[CustomProperties.SOURCE_REF]
                ) and (
                    CustomProperties.TARGET_REF not in item
                    or &#34;relationship&#34; not in item[CustomProperties.TARGET_REF]
                ):
                    source_ref = (
                        item[CustomProperties.SOURCE_REF]
                        if CustomProperties.SOURCE_REF in item
                        else item[&#34;source_ref&#34;]
                    )
                    target_ref = (
                        item[CustomProperties.TARGET_REF]
                        if CustomProperties.TARGET_REF in item
                        else item[&#34;target_ref&#34;]
                    )
                    if &#34;observed-data&#34; in source_ref:
                        if source_ref in self.mapping_cache:
                            for observable in self.mapping_cache[source_ref]:
                                item[CustomProperties.SOURCE_REF] = observable[&#34;id&#34;]
                                self.import_relationship(item, update, types)
                    elif &#34;observed-data&#34; in target_ref:
                        if target_ref in self.mapping_cache:
                            for observable in self.mapping_cache[target_ref]:
                                item[CustomProperties.TARGET_REF] = observable[&#34;id&#34;]
                                self.import_relationship(item, update, types)
                    else:
                        self.import_relationship(item, update, types)
                    imported_elements.append({&#34;id&#34;: item[&#34;id&#34;], &#34;type&#34;: item[&#34;type&#34;]})
        end_time = time.time()
        self.opencti.log(
            &#34;info&#34;, &#34;Relationships imported in: %ssecs&#34; % round(end_time - start_time)
        )

        # StixRelationObjects (with relationships)
        start_time = time.time()
        for item in stix_bundle[&#34;objects&#34;]:
            if item[&#34;type&#34;] == &#34;relationship&#34;:
                if (
                    CustomProperties.SOURCE_REF in item
                    and &#34;relationship&#34; in item[CustomProperties.SOURCE_REF]
                ) or (
                    CustomProperties.TARGET_REF in item
                    and &#34;relationship&#34; in item[CustomProperties.TARGET_REF]
                ):
                    self.import_relationship(item, update, types)
                    imported_elements.append({&#34;id&#34;: item[&#34;id&#34;], &#34;type&#34;: item[&#34;type&#34;]})
        end_time = time.time()
        self.opencti.log(
            &#34;info&#34;,
            &#34;Relationships to relationships imported in: %ssecs&#34;
            % round(end_time - start_time),
        )

        # Reports
        start_time = time.time()
        for item in stix_bundle[&#34;objects&#34;]:
            if item[&#34;type&#34;] == &#34;report&#34; and (len(types) == 0 or &#34;report&#34; in types):
                self.import_object(item, update, types)
                imported_elements.append({&#34;id&#34;: item[&#34;id&#34;], &#34;type&#34;: item[&#34;type&#34;]})
        end_time = time.time()
        self.opencti.log(
            &#34;info&#34;, &#34;Reports imported in: %ssecs&#34; % round(end_time - start_time)
        )

        # Notes
        start_time = time.time()
        for item in stix_bundle[&#34;objects&#34;]:
            if item[&#34;type&#34;] == &#34;note&#34; and (len(types) == 0 or &#34;note&#34; in types):
                self.import_object(item, update, types)
                imported_elements.append({&#34;id&#34;: item[&#34;id&#34;], &#34;type&#34;: item[&#34;type&#34;]})
        end_time = time.time()
        self.opencti.log(
            &#34;info&#34;, &#34;Notes imported in: %ssecs&#34; % round(end_time - start_time)
        )

        # Opinions
        start_time = time.time()
        for item in stix_bundle[&#34;objects&#34;]:
            if item[&#34;type&#34;] == &#34;opinion&#34; and (len(types) == 0 or &#34;opinion&#34; in types):
                self.import_object(item, update, types)
                imported_elements.append({&#34;id&#34;: item[&#34;id&#34;], &#34;type&#34;: item[&#34;type&#34;]})
        end_time = time.time()
        self.opencti.log(
            &#34;info&#34;, &#34;Opinions imported in: %ssecs&#34; % round(end_time - start_time)
        )
        return imported_elements</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pycti.OpenCTIStix2.check_max_marking_definition"><code class="name flex">
<span>def <span class="ident">check_max_marking_definition</span></span>(<span>self, max_marking_definition_entity, entity_marking_definitions)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_max_marking_definition(
    self, max_marking_definition_entity, entity_marking_definitions
):
    # Max is not set, return True
    if max_marking_definition_entity is None:
        return True
    # Filter entity markings definition to the max_marking_definition type
    typed_entity_marking_definitions = []
    for entity_marking_definition in entity_marking_definitions:
        if (
            entity_marking_definition[&#34;definition_type&#34;]
            == max_marking_definition_entity[&#34;definition_type&#34;]
        ):
            typed_entity_marking_definitions.append(entity_marking_definition)
    # No entity marking defintions of the max_marking_definition type
    if len(typed_entity_marking_definitions) == 0:
        return True

    # Check if level is less or equal to max
    for typed_entity_marking_definition in typed_entity_marking_definitions:
        if (
            typed_entity_marking_definition[&#34;level&#34;]
            &lt;= max_marking_definition_entity[&#34;level&#34;]
        ):
            return True
    return False</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIStix2.convert_markdown"><code class="name flex">
<span>def <span class="ident">convert_markdown</span></span>(<span>self, text)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_markdown(self, text):
    return text.replace(&#34;&lt;code&gt;&#34;, &#34;`&#34;).replace(&#34;&lt;/code&gt;&#34;, &#34;`&#34;)</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIStix2.create_attack_pattern"><code class="name flex">
<span>def <span class="ident">create_attack_pattern</span></span>(<span>self, stix_object, extras, update=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_attack_pattern(self, stix_object, extras, update=False):
    return self.opencti.attack_pattern.import_from_stix2(
        stixObject=stix_object, extras=extras, update=update
    )</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIStix2.create_campaign"><code class="name flex">
<span>def <span class="ident">create_campaign</span></span>(<span>self, stix_object, extras, update=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_campaign(self, stix_object, extras, update=False):
    return self.opencti.campaign.create(
        name=stix_object[&#34;name&#34;],
        description=self.convert_markdown(stix_object[&#34;description&#34;])
        if &#34;description&#34; in stix_object
        else &#34;&#34;,
        alias=self.pick_aliases(stix_object),
        objective=stix_object[&#34;objective&#34;] if &#34;objective&#34; in stix_object else None,
        first_seen=stix_object[CustomProperties.FIRST_SEEN]
        if CustomProperties.FIRST_SEEN in stix_object
        else None,
        last_seen=stix_object[CustomProperties.LAST_SEEN]
        if CustomProperties.LAST_SEEN in stix_object
        else None,
        id=stix_object[CustomProperties.ID]
        if CustomProperties.ID in stix_object
        else None,
        stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
        created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
        modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
        createdByRef=extras[&#34;created_by_ref_id&#34;]
        if &#34;created_by_ref_id&#34; in extras
        else None,
        markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
        if &#34;marking_definitions_ids&#34; in extras
        else [],
        uodate=update,
    )</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIStix2.create_course_of_action"><code class="name flex">
<span>def <span class="ident">create_course_of_action</span></span>(<span>self, stix_object, extras, update=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_course_of_action(self, stix_object, extras, update=False):
    return self.opencti.course_of_action.create(
        name=stix_object[&#34;name&#34;],
        description=self.convert_markdown(stix_object[&#34;description&#34;])
        if &#34;description&#34; in stix_object
        else &#34;&#34;,
        alias=self.pick_aliases(stix_object),
        id=stix_object[CustomProperties.ID]
        if CustomProperties.ID in stix_object
        else None,
        stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
        created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
        modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
        createdByRef=extras[&#34;created_by_ref_id&#34;]
        if &#34;created_by_ref_id&#34; in extras
        else None,
        markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
        if &#34;marking_definitions_ids&#34; in extras
        else [],
        update=update,
    )</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIStix2.create_identity"><code class="name flex">
<span>def <span class="ident">create_identity</span></span>(<span>self, stix_object, extras, update=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_identity(self, stix_object, extras, update=False):
    if CustomProperties.IDENTITY_TYPE in stix_object:
        type = stix_object[CustomProperties.IDENTITY_TYPE].capitalize()
    else:
        if stix_object[&#34;identity_class&#34;] == &#34;individual&#34;:
            type = &#34;User&#34;
        elif stix_object[&#34;identity_class&#34;] == &#34;organization&#34;:
            type = &#34;Organization&#34;
        elif stix_object[&#34;identity_class&#34;] == &#34;group&#34;:
            type = &#34;Organization&#34;
        elif stix_object[&#34;identity_class&#34;] == &#34;class&#34;:
            type = &#34;Sector&#34;
        else:
            return None
    return self.opencti.identity.create(
        type=type,
        name=stix_object[&#34;name&#34;],
        description=self.convert_markdown(stix_object[&#34;description&#34;])
        if &#34;description&#34; in stix_object
        else &#34;&#34;,
        alias=self.pick_aliases(stix_object),
        id=stix_object[CustomProperties.ID]
        if CustomProperties.ID in stix_object
        else None,
        stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
        created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
        modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
        createdByRef=extras[&#34;created_by_ref_id&#34;]
        if &#34;created_by_ref_id&#34; in extras
        else None,
        markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
        if &#34;marking_definitions_ids&#34; in extras
        else [],
        update=update,
    )</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIStix2.create_incident"><code class="name flex">
<span>def <span class="ident">create_incident</span></span>(<span>self, stix_object, extras, update=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_incident(self, stix_object, extras, update=False):
    return self.opencti.incident.create(
        name=stix_object[&#34;name&#34;],
        description=self.convert_markdown(stix_object[&#34;description&#34;])
        if &#34;description&#34; in stix_object
        else &#34;&#34;,
        alias=self.pick_aliases(stix_object),
        objective=stix_object[&#34;objective&#34;] if &#34;objective&#34; in stix_object else None,
        first_seen=stix_object[&#34;first_seen&#34;]
        if &#34;first_seen&#34; in stix_object
        else None,
        last_seen=stix_object[&#34;last_seen&#34;] if &#34;last_seen&#34; in stix_object else None,
        id=stix_object[CustomProperties.ID]
        if CustomProperties.ID in stix_object
        else None,
        stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
        created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
        modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
        createdByRef=extras[&#34;created_by_ref_id&#34;]
        if &#34;created_by_ref_id&#34; in extras
        else None,
        markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
        if &#34;marking_definitions_ids&#34; in extras
        else [],
        update=update,
    )</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIStix2.create_indicator"><code class="name flex">
<span>def <span class="ident">create_indicator</span></span>(<span>self, stix_object, extras, update=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_indicator(self, stix_object, extras, update=False):
    return self.opencti.indicator.create(
        name=stix_object[&#34;name&#34;],
        description=self.convert_markdown(stix_object[&#34;description&#34;])
        if &#34;description&#34; in stix_object
        else &#34;&#34;,
        indicator_pattern=stix_object[CustomProperties.INDICATOR_PATTERN]
        if CustomProperties.INDICATOR_PATTERN in stix_object
        else stix_object[&#34;pattern&#34;],
        main_observable_type=stix_object[CustomProperties.OBSERVABLE_TYPE]
        if CustomProperties.OBSERVABLE_TYPE in stix_object
        else &#34;Unknown&#34;,
        pattern_type=stix_object[CustomProperties.PATTERN_TYPE]
        if CustomProperties.PATTERN_TYPE in stix_object
        else &#34;stix&#34;,
        valid_from=stix_object[&#34;valid_from&#34;]
        if &#34;valid_from&#34; in stix_object
        else None,
        valid_until=stix_object[&#34;valid_until&#34;]
        if &#34;valid_until&#34; in stix_object
        else None,
        id=stix_object[CustomProperties.ID]
        if CustomProperties.ID in stix_object
        else None,
        stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
        created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
        modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
        createdByRef=extras[&#34;created_by_ref_id&#34;]
        if &#34;created_by_ref_id&#34; in extras
        else None,
        markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
        if &#34;marking_definitions_ids&#34; in extras
        else None,
        update=update,
    )</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIStix2.create_intrusion_set"><code class="name flex">
<span>def <span class="ident">create_intrusion_set</span></span>(<span>self, stix_object, extras, update=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_intrusion_set(self, stix_object, extras, update=False):
    return self.opencti.intrusion_set.create(
        name=stix_object[&#34;name&#34;],
        description=self.convert_markdown(stix_object[&#34;description&#34;])
        if &#34;description&#34; in stix_object
        else &#34;&#34;,
        alias=self.pick_aliases(stix_object),
        first_seen=stix_object[CustomProperties.FIRST_SEEN]
        if CustomProperties.FIRST_SEEN in stix_object
        else None,
        last_seen=stix_object[CustomProperties.LAST_SEEN]
        if CustomProperties.LAST_SEEN in stix_object
        else None,
        goal=stix_object[&#34;goals&#34;] if &#34;goals&#34; in stix_object else None,
        sophistication=stix_object[&#34;sophistication&#34;]
        if &#34;sophistication&#34; in stix_object
        else None,
        resource_level=stix_object[&#34;resource_level&#34;]
        if &#34;resource_level&#34; in stix_object
        else None,
        primary_motivation=stix_object[&#34;primary_motivation&#34;]
        if &#34;primary_motivation&#34; in stix_object
        else None,
        secondary_motivation=stix_object[&#34;secondary_motivations&#34;]
        if &#34;secondary_motivations&#34; in stix_object
        else None,
        id=stix_object[CustomProperties.ID]
        if CustomProperties.ID in stix_object
        else None,
        stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
        created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
        modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
        createdByRef=extras[&#34;created_by_ref_id&#34;]
        if &#34;created_by_ref_id&#34; in extras
        else None,
        markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
        if &#34;marking_definitions_ids&#34; in extras
        else [],
        update=update,
    )</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIStix2.create_malware"><code class="name flex">
<span>def <span class="ident">create_malware</span></span>(<span>self, stix_object, extras, update=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_malware(self, stix_object, extras, update=False):
    return self.opencti.malware.create(
        name=stix_object[&#34;name&#34;],
        description=self.convert_markdown(stix_object[&#34;description&#34;])
        if &#34;description&#34; in stix_object
        else &#34;&#34;,
        alias=self.pick_aliases(stix_object),
        id=stix_object[CustomProperties.ID]
        if CustomProperties.ID in stix_object
        else None,
        stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
        created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
        modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
        createdByRef=extras[&#34;created_by_ref_id&#34;]
        if &#34;created_by_ref_id&#34; in extras
        else None,
        markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
        if &#34;marking_definitions_ids&#34; in extras
        else [],
        killChainPhases=extras[&#34;kill_chain_phases_ids&#34;]
        if &#34;kill_chain_phases_ids&#34; in extras
        else [],
        update=update,
    )</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIStix2.create_marking_definition"><code class="name flex">
<span>def <span class="ident">create_marking_definition</span></span>(<span>self, stix_object, extras, update=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_marking_definition(self, stix_object, extras, update=False):
    definition_type = stix_object[&#34;definition_type&#34;]
    definition = stix_object[&#34;definition&#34;][stix_object[&#34;definition_type&#34;]]
    if stix_object[&#34;definition_type&#34;] == &#34;tlp&#34;:
        definition_type = &#34;TLP&#34;
        definition = (
            &#34;TLP:&#34;
            + stix_object[&#34;definition&#34;][stix_object[&#34;definition_type&#34;]].upper()
        )
    return self.opencti.marking_definition.create(
        definition_type=definition_type,
        definition=definition,
        level=stix_object[CustomProperties.LEVEL]
        if CustomProperties.LEVEL in stix_object
        else 0,
        color=stix_object[CustomProperties.COLOR]
        if CustomProperties.COLOR in stix_object
        else None,
        id=stix_object[CustomProperties.ID]
        if CustomProperties.ID in stix_object
        else None,
        stix_id_key=stix_object[&#34;id&#34;],
        created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
        modified=stix_object[CustomProperties.MODIFIED]
        if CustomProperties.MODIFIED in stix_object
        else None,
        createdByRef=extras[&#34;created_by_ref_id&#34;]
        if &#34;created_by_ref_id&#34; in extras
        else None,
    )</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIStix2.create_note"><code class="name flex">
<span>def <span class="ident">create_note</span></span>(<span>self, stix_object, extras, update=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_note(self, stix_object, extras, update=False):
    return self.opencti.note.import_from_stix2(
        stixObject=stix_object, extras=extras, update=update
    )</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIStix2.create_opinion"><code class="name flex">
<span>def <span class="ident">create_opinion</span></span>(<span>self, stix_object, extras, update=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_opinion(self, stix_object, extras, update=False):
    return self.opencti.opinion.import_from_stix2(
        stixObject=stix_object, extras=extras, update=update
    )</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIStix2.create_report"><code class="name flex">
<span>def <span class="ident">create_report</span></span>(<span>self, stix_object, extras, update=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_report(self, stix_object, extras, update=False):
    return self.opencti.report.import_from_stix2(
        stixObject=stix_object, extras=extras, update=update
    )</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIStix2.create_threat_actor"><code class="name flex">
<span>def <span class="ident">create_threat_actor</span></span>(<span>self, stix_object, extras, update=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_threat_actor(self, stix_object, extras, update=False):
    return self.opencti.threat_actor.create(
        name=stix_object[&#34;name&#34;],
        description=self.convert_markdown(stix_object[&#34;description&#34;])
        if &#34;description&#34; in stix_object
        else &#34;&#34;,
        alias=self.pick_aliases(stix_object),
        goal=stix_object[&#34;goals&#34;] if &#34;goals&#34; in stix_object else None,
        sophistication=stix_object[&#34;sophistication&#34;]
        if &#34;sophistication&#34; in stix_object
        else None,
        resource_level=stix_object[&#34;resource_level&#34;]
        if &#34;resource_level&#34; in stix_object
        else None,
        primary_motivaton=stix_object[&#34;primary_motivation&#34;]
        if &#34;primary_motivation&#34; in stix_object
        else None,
        secondary_motivation=stix_object[&#34;secondary_motivations&#34;]
        if &#34;secondary_motivations&#34; in stix_object
        else None,
        personal_motivation=stix_object[&#34;personal_motivations&#34;]
        if &#34;personal_motivations&#34; in stix_object
        else None,
        id=stix_object[CustomProperties.ID]
        if CustomProperties.ID in stix_object
        else None,
        stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
        created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
        modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
        createdByRef=extras[&#34;created_by_ref_id&#34;]
        if &#34;created_by_ref_id&#34; in extras
        else None,
        markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
        if &#34;marking_definitions_ids&#34; in extras
        else [],
        update=update,
    )</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIStix2.create_tool"><code class="name flex">
<span>def <span class="ident">create_tool</span></span>(<span>self, stix_object, extras, update=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_tool(self, stix_object, extras, update=False):
    return self.opencti.tool.create(
        name=stix_object[&#34;name&#34;],
        description=self.convert_markdown(stix_object[&#34;description&#34;])
        if &#34;description&#34; in stix_object
        else &#34;&#34;,
        alias=self.pick_aliases(stix_object),
        id=stix_object[CustomProperties.ID]
        if CustomProperties.ID in stix_object
        else None,
        stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
        created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
        modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
        createdByRef=extras[&#34;created_by_ref_id&#34;]
        if &#34;created_by_ref_id&#34; in extras
        else None,
        markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
        if &#34;marking_definitions_ids&#34; in extras
        else [],
        killChainPhases=extras[&#34;kill_chain_phases_ids&#34;]
        if &#34;kill_chain_phases_ids&#34; in extras
        else [],
        update=update,
    )</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIStix2.create_vulnerability"><code class="name flex">
<span>def <span class="ident">create_vulnerability</span></span>(<span>self, stix_object, extras, update=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_vulnerability(self, stix_object, extras, update=False):
    return self.opencti.vulnerability.create(
        name=stix_object[&#34;name&#34;],
        description=self.convert_markdown(stix_object[&#34;description&#34;])
        if &#34;description&#34; in stix_object
        else &#34;&#34;,
        base_score=stix_object[CustomProperties.BASE_SCORE]
        if CustomProperties.BASE_SCORE in stix_object
        else None,
        base_severity=stix_object[CustomProperties.BASE_SEVERITY]
        if CustomProperties.BASE_SEVERITY in stix_object
        else None,
        attack_vector=stix_object[CustomProperties.ATTACK_VECTOR]
        if CustomProperties.ATTACK_VECTOR in stix_object
        else None,
        integrity_impact=stix_object[CustomProperties.INTEGRITY_IMPACT]
        if CustomProperties.INTEGRITY_IMPACT in stix_object
        else None,
        availability_impact=stix_object[CustomProperties.AVAILABILITY_IMPACT]
        if CustomProperties.AVAILABILITY_IMPACT in stix_object
        else None,
        alias=self.pick_aliases(stix_object),
        id=stix_object[CustomProperties.ID]
        if CustomProperties.ID in stix_object
        else None,
        stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
        created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
        modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
        createdByRef=extras[&#34;created_by_ref_id&#34;]
        if &#34;created_by_ref_id&#34; in extras
        else None,
        markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
        if &#34;marking_definitions_ids&#34; in extras
        else [],
        update=update,
    )</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIStix2.export_entity"><code class="name flex">
<span>def <span class="ident">export_entity</span></span>(<span>self, entity_type, entity_id, mode='simple', max_marking_definition=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_entity(
    self, entity_type, entity_id, mode=&#34;simple&#34;, max_marking_definition=None
):
    max_marking_definition_entity = (
        self.opencti.marking_definition.read(id=max_marking_definition)
        if max_marking_definition is not None
        else None
    )
    bundle = {
        &#34;type&#34;: &#34;bundle&#34;,
        &#34;id&#34;: &#34;bundle--&#34; + str(uuid.uuid4()),
        &#34;objects&#34;: [],
    }
    # Map types
    if IdentityTypes.has_value(entity_type):
        entity_type = &#34;identity&#34;

    # Export
    exporter = {
        &#34;identity&#34;: self.opencti.identity.to_stix2,
        &#34;threat-actor&#34;: self.opencti.threat_actor.to_stix2,
        &#34;intrusion-set&#34;: self.opencti.intrusion_set.to_stix2,
        &#34;campaign&#34;: self.opencti.campaign.to_stix2,
        &#34;incident&#34;: self.opencti.incident.to_stix2,
        &#34;malware&#34;: self.opencti.malware.to_stix2,
        &#34;tool&#34;: self.opencti.tool.to_stix2,
        &#34;vulnerability&#34;: self.opencti.vulnerability.to_stix2,
        &#34;attack-pattern&#34;: self.opencti.attack_pattern.to_stix2,
        &#34;course-of-action&#34;: self.opencti.course_of_action.to_stix2,
        &#34;report&#34;: self.opencti.report.to_stix2,
        &#34;note&#34;: self.opencti.note.to_stix2,
        &#34;opinion&#34;: self.opencti.opinion.to_stix2,
        &#34;indicator&#34;: self.opencti.indicator.to_stix2,
    }
    do_export = exporter.get(
        entity_type, lambda **kwargs: self.unknown_type({&#34;type&#34;: entity_type})
    )
    objects = do_export(
        id=entity_id,
        mode=mode,
        max_marking_definition_entity=max_marking_definition_entity,
    )
    if objects is not None:
        bundle[&#34;objects&#34;].extend(objects)
    return bundle</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIStix2.export_list"><code class="name flex">
<span>def <span class="ident">export_list</span></span>(<span>self, entity_type, search=None, filters=None, order_by=None, order_mode=None, max_marking_definition=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_list(
    self,
    entity_type,
    search=None,
    filters=None,
    order_by=None,
    order_mode=None,
    max_marking_definition=None,
):
    max_marking_definition_entity = (
        self.opencti.marking_definition.read(id=max_marking_definition)
        if max_marking_definition is not None
        else None
    )
    bundle = {
        &#34;type&#34;: &#34;bundle&#34;,
        &#34;id&#34;: &#34;bundle--&#34; + str(uuid.uuid4()),
        &#34;objects&#34;: [],
    }

    if IdentityTypes.has_value(entity_type):
        if filters is not None:
            filters.append({&#34;key&#34;: &#34;entity_type&#34;, &#34;values&#34;: [entity_type]})
        else:
            filters = [{&#34;key&#34;: &#34;entity_type&#34;, &#34;values&#34;: [entity_type]}]
        entity_type = &#34;identity&#34;

    # List
    lister = {
        &#34;identity&#34;: self.opencti.identity.list,
        &#34;threat-actor&#34;: self.opencti.threat_actor.list,
        &#34;intrusion-set&#34;: self.opencti.intrusion_set.list,
        &#34;campaign&#34;: self.opencti.campaign.list,
        &#34;incident&#34;: self.opencti.incident.list,
        &#34;malware&#34;: self.opencti.malware.list,
        &#34;tool&#34;: self.opencti.tool.list,
        &#34;vulnerability&#34;: self.opencti.vulnerability.list,
        &#34;attack-pattern&#34;: self.opencti.attack_pattern.list,
        &#34;course-of-action&#34;: self.opencti.course_of_action.list,
        &#34;report&#34;: self.opencti.report.list,
        &#34;note&#34;: self.opencti.note.list,
        &#34;opinion&#34;: self.opencti.opinion.list,
        &#34;indicator&#34;: self.opencti.indicator.list,
    }
    do_list = lister.get(
        entity_type, lambda **kwargs: self.unknown_type({&#34;type&#34;: entity_type})
    )
    entities_list = do_list(
        search=search,
        filters=filters,
        orderBy=order_by,
        orderMode=order_mode,
        getAll=True,
    )

    if entities_list is not None:
        # Export
        exporter = {
            &#34;identity&#34;: self.opencti.identity.to_stix2,
            &#34;threat-actor&#34;: self.opencti.threat_actor.to_stix2,
            &#34;intrusion-set&#34;: self.opencti.intrusion_set.to_stix2,
            &#34;campaign&#34;: self.opencti.campaign.to_stix2,
            &#34;incident&#34;: self.opencti.incident.to_stix2,
            &#34;malware&#34;: self.opencti.malware.to_stix2,
            &#34;tool&#34;: self.opencti.tool.to_stix2,
            &#34;vulnerability&#34;: self.opencti.vulnerability.to_stix2,
            &#34;attack-pattern&#34;: self.opencti.attack_pattern.to_stix2,
            &#34;course-of-action&#34;: self.opencti.course_of_action.to_stix2,
            &#34;report&#34;: self.opencti.report.to_stix2,
            &#34;note&#34;: self.opencti.note.to_stix2,
            &#34;opinion&#34;: self.opencti.opinion.to_stix2,
            &#34;indicator&#34;: self.opencti.indicator.to_stix2,
        }
        do_export = exporter.get(
            entity_type, lambda **kwargs: self.unknown_type({&#34;type&#34;: entity_type})
        )
        uuids = []
        for entity in entities_list:
            entity_bundle = do_export(
                entity=entity,
                max_marking_definition_entity=max_marking_definition_entity,
            )
            if entity_bundle is not None:
                entity_bundle_filtered = self.filter_objects(uuids, entity_bundle)
                for x in entity_bundle_filtered:
                    uuids.append(x[&#34;id&#34;])
                bundle[&#34;objects&#34;] = bundle[&#34;objects&#34;] + entity_bundle_filtered

    return bundle</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIStix2.export_stix_observables"><code class="name flex">
<span>def <span class="ident">export_stix_observables</span></span>(<span>self, entity)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_stix_observables(self, entity):
    stix_ids = []
    observed_data = dict()
    observed_data[&#34;id&#34;] = &#34;observed-data--&#34; + str(uuid.uuid4())
    observed_data[&#34;type&#34;] = &#34;observed-data&#34;
    observed_data[&#34;number_observed&#34;] = len(entity[&#34;observableRefs&#34;])
    observed_data[&#34;objects&#34;] = []
    for observable in entity[&#34;observableRefs&#34;]:
        stix_observable = dict()
        stix_observable[CustomProperties.OBSERVABLE_TYPE] = observable[
            &#34;entity_type&#34;
        ]
        stix_observable[CustomProperties.OBSERVABLE_VALUE] = observable[
            &#34;observable_value&#34;
        ]
        stix_observable[&#34;type&#34;] = observable[&#34;entity_type&#34;]
        observed_data[&#34;objects&#34;].append(stix_observable)
        stix_ids.append(observable[&#34;stix_id_key&#34;])

    return {&#34;observedData&#34;: observed_data, &#34;stixIds&#34;: stix_ids}</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIStix2.extract_embedded_relationships"><code class="name flex">
<span>def <span class="ident">extract_embedded_relationships</span></span>(<span>self, stix_object, types=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_embedded_relationships(self, stix_object, types=None):
    # Created By Ref
    created_by_ref_id = None
    if &#34;created_by_ref&#34; in stix_object:
        created_by_ref = stix_object[&#34;created_by_ref&#34;]
        if created_by_ref in self.mapping_cache:
            created_by_ref_result = self.mapping_cache[created_by_ref]
        else:
            created_by_ref_result = self.opencti.stix_domain_entity.read(
                id=created_by_ref
            )
            if created_by_ref_result is not None:
                self.mapping_cache[created_by_ref] = {
                    &#34;id&#34;: created_by_ref_result[&#34;id&#34;],
                    &#34;type&#34;: created_by_ref_result[&#34;entity_type&#34;],
                }
        if created_by_ref_result is not None:
            created_by_ref_id = created_by_ref_result[&#34;id&#34;]

    # Object Marking Refs
    marking_definitions_ids = []
    if &#34;object_marking_refs&#34; in stix_object:
        for object_marking_ref in stix_object[&#34;object_marking_refs&#34;]:
            if object_marking_ref in self.mapping_cache:
                object_marking_ref_result = self.mapping_cache[object_marking_ref]
            else:
                object_marking_ref_result = self.opencti.marking_definition.read(
                    id=object_marking_ref
                )
                if object_marking_ref_result is not None:
                    self.mapping_cache[object_marking_ref] = {
                        &#34;id&#34;: object_marking_ref_result[&#34;id&#34;],
                        &#34;type&#34;: object_marking_ref_result[&#34;entity_type&#34;],
                    }
            if object_marking_ref_result is not None:
                marking_definitions_ids.append(object_marking_ref_result[&#34;id&#34;])

    # Object Tags
    tags_ids = []
    if CustomProperties.TAG_TYPE in stix_object:
        for tag in stix_object[CustomProperties.TAG_TYPE]:
            tag_result = None
            if &#34;id&#34; in tag:
                if tag[&#34;id&#34;] in self.mapping_cache:
                    tag_result = self.mapping_cache[tag[&#34;id&#34;]]
                else:
                    tag_result = self.opencti.tag.read(id=tag[&#34;id&#34;])
            if tag_result is not None:
                self.mapping_cache[tag[&#34;id&#34;]] = {&#34;id&#34;: tag_result[&#34;id&#34;]}
            else:
                tag_result = self.opencti.tag.create(
                    tag_type=tag[&#34;tag_type&#34;],
                    value=tag[&#34;value&#34;],
                    color=tag[&#34;color&#34;],
                    id=tag[&#34;id&#34;] if &#34;id&#34; in tag else None,
                )
            if tag_result is not None:
                tags_ids.append(tag_result[&#34;id&#34;])

    # Kill Chain Phases
    kill_chain_phases_ids = []
    if &#34;kill_chain_phases&#34; in stix_object:
        for kill_chain_phase in stix_object[&#34;kill_chain_phases&#34;]:
            if kill_chain_phase[&#34;phase_name&#34;] in self.mapping_cache:
                kill_chain_phase = self.mapping_cache[
                    kill_chain_phase[&#34;phase_name&#34;]
                ]
            else:
                kill_chain_phase = self.opencti.kill_chain_phase.create(
                    kill_chain_name=kill_chain_phase[&#34;kill_chain_name&#34;],
                    phase_name=kill_chain_phase[&#34;phase_name&#34;],
                    phase_order=kill_chain_phase[CustomProperties.PHASE_ORDER]
                    if CustomProperties.PHASE_ORDER in kill_chain_phase
                    else 0,
                    id=kill_chain_phase[CustomProperties.ID]
                    if CustomProperties.ID in kill_chain_phase
                    else None,
                    stix_id_key=kill_chain_phase[&#34;id&#34;]
                    if &#34;id&#34; in kill_chain_phase
                    else None,
                    created=kill_chain_phase[CustomProperties.CREATED]
                    if CustomProperties.CREATED in kill_chain_phase
                    else None,
                    modified=kill_chain_phase[CustomProperties.MODIFIED]
                    if CustomProperties.MODIFIED in kill_chain_phase
                    else None,
                )
                self.mapping_cache[kill_chain_phase[&#34;phase_name&#34;]] = {
                    &#34;id&#34;: kill_chain_phase[&#34;id&#34;],
                    &#34;type&#34;: kill_chain_phase[&#34;entity_type&#34;],
                }
            kill_chain_phases_ids.append(kill_chain_phase[&#34;id&#34;])

    # Object refs
    object_refs_ids = []
    if &#34;object_refs&#34; in stix_object:
        for object_ref in stix_object[&#34;object_refs&#34;]:
            object_ref_result = None
            if object_ref in self.mapping_cache:
                object_ref_result = self.mapping_cache[object_ref]
            elif &#34;relationship&#34; in object_ref:
                object_ref_result = self.opencti.stix_relation.read(id=object_ref)
                if object_ref_result is not None:
                    self.mapping_cache[object_ref] = {
                        &#34;id&#34;: object_ref_result[&#34;id&#34;],
                        &#34;type&#34;: object_ref_result[&#34;entity_type&#34;],
                    }
            elif &#34;observed-data&#34; not in object_ref:
                object_ref_result = self.opencti.stix_entity.read(id=object_ref)
                if object_ref_result is not None:
                    self.mapping_cache[object_ref] = {
                        &#34;id&#34;: object_ref_result[&#34;id&#34;],
                        &#34;type&#34;: object_ref_result[&#34;entity_type&#34;],
                    }
            if &#34;observed-data&#34; not in object_ref:
                if object_ref_result is not None:
                    object_refs_ids.append(object_ref_result[&#34;id&#34;])
            else:
                object_refs_ids.append(object_ref)

    # External References
    reports = {}
    external_references_ids = []
    if &#34;external_references&#34; in stix_object:
        for external_reference in stix_object[&#34;external_references&#34;]:
            if &#34;url&#34; in external_reference and &#34;source_name&#34; in external_reference:
                url = external_reference[&#34;url&#34;]
                source_name = external_reference[&#34;source_name&#34;]
            else:
                continue
            if url in self.mapping_cache:
                external_reference_id = self.mapping_cache[url][&#34;id&#34;]
            else:
                external_reference_id = self.opencti.external_reference.create(
                    source_name=source_name,
                    url=url,
                    external_id=external_reference[&#34;external_id&#34;]
                    if &#34;external_id&#34; in external_reference
                    else None,
                    description=external_reference[&#34;description&#34;]
                    if &#34;description&#34; in external_reference
                    else None,
                    id=external_reference[CustomProperties.ID]
                    if CustomProperties.ID in external_reference
                    else None,
                    stix_id_key=external_reference[&#34;id&#34;]
                    if &#34;id&#34; in external_reference
                    else None,
                    created=external_reference[CustomProperties.CREATED]
                    if CustomProperties.CREATED in external_reference
                    else None,
                    modified=external_reference[CustomProperties.MODIFIED]
                    if CustomProperties.MODIFIED in external_reference
                    else None,
                )[&#34;id&#34;]
            self.mapping_cache[url] = {&#34;id&#34;: external_reference_id}
            external_references_ids.append(external_reference_id)

            if stix_object[&#34;type&#34;] in [
                &#34;threat-actor&#34;,
                &#34;intrusion-set&#34;,
                &#34;campaign&#34;,
                &#34;incident&#34;,
                &#34;malware&#34;,
                &#34;relationship&#34;,
            ] and (types is None or &#34;report&#34; in types):
                # Add a corresponding report
                # Extract date
                try:
                    if &#34;description&#34; in external_reference:
                        matches = datefinder.find_dates(
                            external_reference[&#34;description&#34;]
                        )
                    else:
                        matches = datefinder.find_dates(source_name)
                except:
                    matches = None
                published = None
                today = datetime.datetime.today()
                if matches is not None:
                    for match in matches:
                        if match &lt; today:
                            published = match.strftime(&#34;%Y-%m-%dT%H:%M:%SZ&#34;)
                if published is None:
                    published = today.strftime(&#34;%Y-%m-%dT%H:%M:%SZ&#34;)

                if &#34;mitre&#34; in source_name and &#34;name&#34; in stix_object:
                    title = &#34;[MITRE ATT&amp;CK] &#34; + stix_object[&#34;name&#34;]
                    if &#34;modified&#34; in stix_object:
                        published = stix_object[&#34;modified&#34;]
                elif &#34;amitt&#34; in source_name and &#34;name&#34; in stix_object:
                    title = &#34;[AM!TT] &#34; + stix_object[&#34;name&#34;]
                    if &#34;modified&#34; in stix_object:
                        published = stix_object[&#34;modified&#34;]
                else:
                    title = source_name

                if &#34;external_id&#34; in external_reference:
                    title = title + &#34; (&#34; + external_reference[&#34;external_id&#34;] + &#34;)&#34;

                author = self.resolve_author(title)
                report = self.opencti.report.create(
                    name=title,
                    external_reference_id=external_reference_id,
                    description=external_reference[&#34;description&#34;]
                    if &#34;description&#34; in external_reference
                    else &#34;&#34;,
                    published=published,
                    report_class=&#34;Threat Report&#34;,
                    object_status=2,
                    createdByRef=author[&#34;id&#34;] if author is not None else None,
                    update=True,
                )
                # Add marking
                if &#34;marking_tlpwhite&#34; in self.mapping_cache:
                    object_marking_ref_result = self.mapping_cache[
                        &#34;marking_tlpwhite&#34;
                    ]
                else:
                    object_marking_ref_result = self.opencti.marking_definition.read(
                        filters=[
                            {&#34;key&#34;: &#34;definition_type&#34;, &#34;values&#34;: [&#34;TLP&#34;]},
                            {&#34;key&#34;: &#34;definition&#34;, &#34;values&#34;: [&#34;TLP:WHITE&#34;]},
                        ]
                    )
                if object_marking_ref_result is not None:
                    self.mapping_cache[&#34;marking_tlpwhite&#34;] = {
                        &#34;id&#34;: object_marking_ref_result[&#34;id&#34;]
                    }
                    self.opencti.stix_entity.add_marking_definition(
                        id=report[&#34;id&#34;],
                        marking_definition_id=object_marking_ref_result[&#34;id&#34;],
                    )

                # Add external reference to report
                self.opencti.stix_entity.add_external_reference(
                    id=report[&#34;id&#34;], external_reference_id=external_reference_id,
                )
                reports[external_reference_id] = report

    return {
        &#34;created_by_ref&#34;: created_by_ref_id,
        &#34;marking_definitions&#34;: marking_definitions_ids,
        &#34;tags&#34;: tags_ids,
        &#34;kill_chain_phases&#34;: kill_chain_phases_ids,
        &#34;object_refs&#34;: object_refs_ids,
        &#34;external_references&#34;: external_references_ids,
        &#34;reports&#34;: reports,
    }</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIStix2.filter_objects"><code class="name flex">
<span>def <span class="ident">filter_objects</span></span>(<span>self, uuids, objects)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_objects(self, uuids, objects):
    result = []
    if objects is not None:
        for object in objects:
            if &#34;id&#34; in object and object[&#34;id&#34;] not in uuids:
                result.append(object)
    return result</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIStix2.format_date"><code class="name flex">
<span>def <span class="ident">format_date</span></span>(<span>self, date)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format_date(self, date):
    if isinstance(date, datetime.date):
        return date.isoformat(timespec=&#34;milliseconds&#34;).replace(&#34;+00:00&#34;, &#34;Z&#34;)
    if date is not None:
        return (
            dateutil.parser.parse(date)
            .isoformat(timespec=&#34;milliseconds&#34;)
            .replace(&#34;+00:00&#34;, &#34;Z&#34;)
        )
    else:
        return (
            datetime.datetime.utcnow()
            .isoformat(timespec=&#34;milliseconds&#34;)
            .replace(&#34;+00:00&#34;, &#34;Z&#34;)
        )</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIStix2.get_author"><code class="name flex">
<span>def <span class="ident">get_author</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_author(self, name):
    if name in self.mapping_cache:
        return self.mapping_cache[name]
    else:
        author = self.opencti.identity.create(
            type=&#34;Organization&#34;, name=name, description=&#34;&#34;,
        )
        self.mapping_cache[name] = author
        return author</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIStix2.import_bundle"><code class="name flex">
<span>def <span class="ident">import_bundle</span></span>(<span>self, stix_bundle, update=False, types=None) ->List</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def import_bundle(self, stix_bundle, update=False, types=None) -&gt; List:
    if types is None:
        types = []

    # Check if the bundle is correctly formatted
    if &#34;type&#34; not in stix_bundle or stix_bundle[&#34;type&#34;] != &#34;bundle&#34;:
        raise ValueError(&#34;JSON data type is not a STIX2 bundle&#34;)
    if &#34;objects&#34; not in stix_bundle or len(stix_bundle[&#34;objects&#34;]) == 0:
        raise ValueError(&#34;JSON data objects is empty&#34;)

    # Import every elements in a specific order
    imported_elements = []

    # Marking definitions
    start_time = time.time()
    for item in stix_bundle[&#34;objects&#34;]:
        if item[&#34;type&#34;] == &#34;marking-definition&#34;:
            self.import_object(item, update, types)
            imported_elements.append({&#34;id&#34;: item[&#34;id&#34;], &#34;type&#34;: item[&#34;type&#34;]})
    end_time = time.time()
    self.opencti.log(
        &#34;info&#34;,
        &#34;Marking definitions imported in: %ssecs&#34; % round(end_time - start_time),
    )

    # Identities
    start_time = time.time()
    for item in stix_bundle[&#34;objects&#34;]:
        if item[&#34;type&#34;] == &#34;identity&#34; and (
            len(types) == 0
            or &#34;identity&#34; in types
            or (
                CustomProperties.IDENTITY_TYPE in item
                and item[CustomProperties.IDENTITY_TYPE] in types
            )
        ):
            self.import_object(item, update, types)
            imported_elements.append({&#34;id&#34;: item[&#34;id&#34;], &#34;type&#34;: item[&#34;type&#34;]})
    end_time = time.time()
    self.opencti.log(
        &#34;info&#34;, &#34;Identities imported in: %ssecs&#34; % round(end_time - start_time)
    )

    # StixDomainObjects except Report/Opinion/Notes
    start_time = time.time()
    for item in stix_bundle[&#34;objects&#34;]:
        if (
            item[&#34;type&#34;] != &#34;relationship&#34;
            and item[&#34;type&#34;] != &#34;report&#34;
            and item[&#34;type&#34;] != &#34;note&#34;
            and item[&#34;type&#34;] != &#34;opinion&#34;
            and item[&#34;type&#34;] != &#34;observed-data&#34;
            and (len(types) == 0 or item[&#34;type&#34;] in types)
        ):
            self.import_object(item, update, types)
            imported_elements.append({&#34;id&#34;: item[&#34;id&#34;], &#34;type&#34;: item[&#34;type&#34;]})
    end_time = time.time()
    self.opencti.log(
        &#34;info&#34;, &#34;Objects imported in: %ssecs&#34; % round(end_time - start_time)
    )

    # StixCyberObservables
    start_time = time.time()
    for item in stix_bundle[&#34;objects&#34;]:
        if item[&#34;type&#34;] == &#34;observed-data&#34; and (
            len(types) == 0 or &#34;observed-data&#34; in types
        ):
            self.import_observables(item)
    end_time = time.time()
    self.opencti.log(
        &#34;info&#34;, &#34;Observables imported in: %ssecs&#34; % round(end_time - start_time)
    )

    # StixRelationObjects
    start_time = time.time()
    for item in stix_bundle[&#34;objects&#34;]:
        if item[&#34;type&#34;] == &#34;relationship&#34;:
            # Import only relationships between entities
            if (
                CustomProperties.SOURCE_REF not in item
                or &#34;relationship&#34; not in item[CustomProperties.SOURCE_REF]
            ) and (
                CustomProperties.TARGET_REF not in item
                or &#34;relationship&#34; not in item[CustomProperties.TARGET_REF]
            ):
                source_ref = (
                    item[CustomProperties.SOURCE_REF]
                    if CustomProperties.SOURCE_REF in item
                    else item[&#34;source_ref&#34;]
                )
                target_ref = (
                    item[CustomProperties.TARGET_REF]
                    if CustomProperties.TARGET_REF in item
                    else item[&#34;target_ref&#34;]
                )
                if &#34;observed-data&#34; in source_ref:
                    if source_ref in self.mapping_cache:
                        for observable in self.mapping_cache[source_ref]:
                            item[CustomProperties.SOURCE_REF] = observable[&#34;id&#34;]
                            self.import_relationship(item, update, types)
                elif &#34;observed-data&#34; in target_ref:
                    if target_ref in self.mapping_cache:
                        for observable in self.mapping_cache[target_ref]:
                            item[CustomProperties.TARGET_REF] = observable[&#34;id&#34;]
                            self.import_relationship(item, update, types)
                else:
                    self.import_relationship(item, update, types)
                imported_elements.append({&#34;id&#34;: item[&#34;id&#34;], &#34;type&#34;: item[&#34;type&#34;]})
    end_time = time.time()
    self.opencti.log(
        &#34;info&#34;, &#34;Relationships imported in: %ssecs&#34; % round(end_time - start_time)
    )

    # StixRelationObjects (with relationships)
    start_time = time.time()
    for item in stix_bundle[&#34;objects&#34;]:
        if item[&#34;type&#34;] == &#34;relationship&#34;:
            if (
                CustomProperties.SOURCE_REF in item
                and &#34;relationship&#34; in item[CustomProperties.SOURCE_REF]
            ) or (
                CustomProperties.TARGET_REF in item
                and &#34;relationship&#34; in item[CustomProperties.TARGET_REF]
            ):
                self.import_relationship(item, update, types)
                imported_elements.append({&#34;id&#34;: item[&#34;id&#34;], &#34;type&#34;: item[&#34;type&#34;]})
    end_time = time.time()
    self.opencti.log(
        &#34;info&#34;,
        &#34;Relationships to relationships imported in: %ssecs&#34;
        % round(end_time - start_time),
    )

    # Reports
    start_time = time.time()
    for item in stix_bundle[&#34;objects&#34;]:
        if item[&#34;type&#34;] == &#34;report&#34; and (len(types) == 0 or &#34;report&#34; in types):
            self.import_object(item, update, types)
            imported_elements.append({&#34;id&#34;: item[&#34;id&#34;], &#34;type&#34;: item[&#34;type&#34;]})
    end_time = time.time()
    self.opencti.log(
        &#34;info&#34;, &#34;Reports imported in: %ssecs&#34; % round(end_time - start_time)
    )

    # Notes
    start_time = time.time()
    for item in stix_bundle[&#34;objects&#34;]:
        if item[&#34;type&#34;] == &#34;note&#34; and (len(types) == 0 or &#34;note&#34; in types):
            self.import_object(item, update, types)
            imported_elements.append({&#34;id&#34;: item[&#34;id&#34;], &#34;type&#34;: item[&#34;type&#34;]})
    end_time = time.time()
    self.opencti.log(
        &#34;info&#34;, &#34;Notes imported in: %ssecs&#34; % round(end_time - start_time)
    )

    # Opinions
    start_time = time.time()
    for item in stix_bundle[&#34;objects&#34;]:
        if item[&#34;type&#34;] == &#34;opinion&#34; and (len(types) == 0 or &#34;opinion&#34; in types):
            self.import_object(item, update, types)
            imported_elements.append({&#34;id&#34;: item[&#34;id&#34;], &#34;type&#34;: item[&#34;type&#34;]})
    end_time = time.time()
    self.opencti.log(
        &#34;info&#34;, &#34;Opinions imported in: %ssecs&#34; % round(end_time - start_time)
    )
    return imported_elements</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIStix2.import_bundle_from_file"><code class="name flex">
<span>def <span class="ident">import_bundle_from_file</span></span>(<span>self, file_path, update=False, types=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def import_bundle_from_file(self, file_path, update=False, types=None):
    if types is None:
        types = []
    if not os.path.isfile(file_path):
        self.opencti.log(&#34;error&#34;, &#34;The bundle file does not exists&#34;)
        return None

    with open(os.path.join(file_path)) as file:
        data = json.load(file)

    return self.import_bundle(data, update, types)</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIStix2.import_bundle_from_json"><code class="name flex">
<span>def <span class="ident">import_bundle_from_json</span></span>(<span>self, json_data, update=False, types=None) ->List</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def import_bundle_from_json(self, json_data, update=False, types=None) -&gt; List:
    if types is None:
        types = []
    data = json.loads(json_data)
    return self.import_bundle(data, update, types)</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIStix2.import_object"><code class="name flex">
<span>def <span class="ident">import_object</span></span>(<span>self, stix_object, update=False, types=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def import_object(self, stix_object, update=False, types=None):
    self.opencti.log(
        &#34;info&#34;,
        &#34;Importing a &#34; + stix_object[&#34;type&#34;] + &#34; (id: &#34; + stix_object[&#34;id&#34;] + &#34;)&#34;,
    )

    # Extract
    embedded_relationships = self.extract_embedded_relationships(stix_object, types)
    created_by_ref_id = embedded_relationships[&#34;created_by_ref&#34;]
    marking_definitions_ids = embedded_relationships[&#34;marking_definitions&#34;]
    tags_ids = embedded_relationships[&#34;tags&#34;]
    kill_chain_phases_ids = embedded_relationships[&#34;kill_chain_phases&#34;]
    object_refs_ids = embedded_relationships[&#34;object_refs&#34;]
    external_references_ids = embedded_relationships[&#34;external_references&#34;]
    reports = embedded_relationships[&#34;reports&#34;]

    # Extra
    extras = {
        &#34;created_by_ref_id&#34;: created_by_ref_id,
        &#34;marking_definitions_ids&#34;: marking_definitions_ids,
        &#34;tags_ids&#34;: tags_ids,
        &#34;kill_chain_phases_ids&#34;: kill_chain_phases_ids,
        &#34;object_refs_ids&#34;: object_refs_ids,
        &#34;external_references_ids&#34;: external_references_ids,
        &#34;reports&#34;: reports,
    }

    # Import
    importer = {
        &#34;marking-definition&#34;: self.create_marking_definition,
        &#34;identity&#34;: self.create_identity,
        &#34;threat-actor&#34;: self.create_threat_actor,
        &#34;intrusion-set&#34;: self.create_intrusion_set,
        &#34;campaign&#34;: self.create_campaign,
        &#34;x-opencti-incident&#34;: self.create_incident,
        &#34;malware&#34;: self.create_malware,
        &#34;tool&#34;: self.create_tool,
        &#34;vulnerability&#34;: self.create_vulnerability,
        &#34;attack-pattern&#34;: self.create_attack_pattern,
        &#34;course-of-action&#34;: self.create_course_of_action,
        &#34;report&#34;: self.create_report,
        &#34;note&#34;: self.create_note,
        &#34;opinion&#34;: self.create_opinion,
        &#34;indicator&#34;: self.create_indicator,
    }
    do_import = importer.get(
        stix_object[&#34;type&#34;],
        lambda stix_object, extras, update: self.unknown_type(stix_object),
    )
    stix_object_results = do_import(stix_object, extras, update)

    if stix_object_results is None:
        return stix_object_results

    if not isinstance(stix_object_results, list):
        stix_object_results = [stix_object_results]

    for stix_object_result in stix_object_results:
        # Add embedded relationships
        self.mapping_cache[stix_object[&#34;id&#34;]] = {
            &#34;id&#34;: stix_object_result[&#34;id&#34;],
            &#34;type&#34;: stix_object_result[&#34;entity_type&#34;],
            &#34;observableRefs&#34;: stix_object_result[&#34;observableRefs&#34;]
            if &#34;observableRefs&#34; in stix_object_result
            else [],
        }
        self.mapping_cache[stix_object_result[&#34;id&#34;]] = {
            &#34;id&#34;: stix_object_result[&#34;id&#34;],
            &#34;type&#34;: stix_object_result[&#34;entity_type&#34;],
            &#34;observableRefs&#34;: stix_object_result[&#34;observableRefs&#34;]
            if &#34;observableRefs&#34; in stix_object_result
            else [],
        }

        # Add tags
        for tag_id in tags_ids:
            self.opencti.stix_entity.add_tag(
                id=stix_object_result[&#34;id&#34;], tag_id=tag_id,
            )
        # Add external references
        for external_reference_id in external_references_ids:
            self.opencti.stix_entity.add_external_reference(
                id=stix_object_result[&#34;id&#34;],
                external_reference_id=external_reference_id,
            )
            if external_reference_id in reports:
                self.opencti.report.add_stix_entity(
                    id=reports[external_reference_id][&#34;id&#34;],
                    entity_id=stix_object_result[&#34;id&#34;],
                )
        # Add object refs
        for object_refs_id in object_refs_ids:
            if &#34;observed-data&#34; in object_refs_id:
                if object_refs_id in self.mapping_cache:
                    for observable in self.mapping_cache[object_refs_id]:
                        if stix_object_result[&#34;entity_type&#34;] == &#34;report&#34;:
                            self.opencti.report.add_stix_observable(
                                id=stix_object_result[&#34;id&#34;],
                                stix_observable_id=observable[&#34;id&#34;],
                            )
                        elif stix_object_result[&#34;entity_type&#34;] == &#34;note&#34;:
                            self.opencti.note.add_stix_observable(
                                id=stix_object_result[&#34;id&#34;],
                                stix_observable_id=observable[&#34;id&#34;],
                            )
                        elif stix_object_result[&#34;entity_type&#34;] == &#34;opinion&#34;:
                            self.opencti.opinion.add_stix_observable(
                                id=stix_object_result[&#34;id&#34;],
                                stix_observable_id=observable[&#34;id&#34;],
                            )
            else:
                if stix_object_result[&#34;entity_type&#34;] == &#34;report&#34;:
                    self.opencti.report.add_stix_entity(
                        id=stix_object_result[&#34;id&#34;], entity_id=object_refs_id,
                    )
                elif stix_object_result[&#34;entity_type&#34;] == &#34;note&#34;:
                    self.opencti.note.add_stix_entity(
                        id=stix_object_result[&#34;id&#34;], entity_id=object_refs_id,
                    )
                elif stix_object_result[&#34;entity_type&#34;] == &#34;opinion&#34;:
                    self.opencti.opinion.add_stix_entity(
                        id=stix_object_result[&#34;id&#34;], entity_id=object_refs_id,
                    )
                if (
                    object_refs_id in self.mapping_cache
                    and &#34;observableRefs&#34; in self.mapping_cache[object_refs_id]
                    and self.mapping_cache[object_refs_id] is not None
                    and self.mapping_cache[object_refs_id][&#34;observableRefs&#34;]
                    is not None
                    and len(self.mapping_cache[object_refs_id][&#34;observableRefs&#34;])
                    &gt; 0
                ):
                    for observable_ref in self.mapping_cache[object_refs_id][
                        &#34;observableRefs&#34;
                    ]:
                        if stix_object_result[&#34;entity_type&#34;] == &#34;report&#34;:
                            self.opencti.report.add_stix_observable(
                                id=stix_object_result[&#34;id&#34;],
                                stix_observable_id=observable_ref[&#34;id&#34;],
                            )
                        elif stix_object_result[&#34;entity_type&#34;] == &#34;note&#34;:
                            self.opencti.note.add_stix_observable(
                                id=stix_object_result[&#34;id&#34;],
                                stix_observable_id=observable_ref[&#34;id&#34;],
                            )
                        elif stix_object_result[&#34;entity_type&#34;] == &#34;opinion&#34;:
                            self.opencti.opinion.add_stix_observable(
                                id=stix_object_result[&#34;id&#34;],
                                stix_observable_id=observable_ref[&#34;id&#34;],
                            )
        # Add files
        if CustomProperties.FILES in stix_object:
            for file in stix_object[CustomProperties.FILES]:
                self.opencti.stix_domain_entity.add_file(
                    id=stix_object_result[&#34;id&#34;],
                    file_name=file[&#34;name&#34;],
                    data=base64.b64decode(file[&#34;data&#34;]),
                    mime_type=file[&#34;mime_type&#34;],
                )

    return stix_object_results</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIStix2.import_observables"><code class="name flex">
<span>def <span class="ident">import_observables</span></span>(<span>self, stix_object)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def import_observables(self, stix_object):
    # Extract
    embedded_relationships = self.extract_embedded_relationships(stix_object)
    created_by_ref_id = embedded_relationships[&#34;created_by_ref&#34;]
    marking_definitions_ids = embedded_relationships[&#34;marking_definitions&#34;]

    observables_to_create = {}
    relations_to_create = []
    for key, observable_item in stix_object[&#34;objects&#34;].items():
        # TODO artifact
        if (
            CustomProperties.OBSERVABLE_TYPE in observable_item
            and CustomProperties.OBSERVABLE_VALUE in observable_item
        ):
            observables_to_create[key] = [
                {
                    &#34;id&#34;: str(uuid.uuid4()),
                    &#34;stix_id&#34;: &#34;observable--&#34; + str(uuid.uuid4()),
                    &#34;type&#34;: observable_item[CustomProperties.OBSERVABLE_TYPE],
                    &#34;value&#34;: observable_item[CustomProperties.OBSERVABLE_VALUE],
                }
            ]
        elif observable_item[&#34;type&#34;] == &#34;autonomous-system&#34;:
            observables_to_create[key] = [
                {
                    &#34;id&#34;: str(uuid.uuid4()),
                    &#34;stix_id&#34;: &#34;observable--&#34; + str(uuid.uuid4()),
                    &#34;type&#34;: ObservableTypes.AUTONOMOUS_SYSTEM.value,
                    &#34;value&#34;: &#34;AS&#34; + observable_item[&#34;number&#34;],
                }
            ]
        elif observable_item[&#34;type&#34;] == &#34;directory&#34;:
            observables_to_create[key] = [
                {
                    &#34;id&#34;: str(uuid.uuid4()),
                    &#34;stix_id&#34;: &#34;observable--&#34; + str(uuid.uuid4()),
                    &#34;type&#34;: ObservableTypes.DIRECTORY.value,
                    &#34;value&#34;: observable_item[&#34;path&#34;],
                }
            ]
        elif observable_item[&#34;type&#34;] == &#34;domain-name&#34;:
            observables_to_create[key] = [
                {
                    &#34;id&#34;: str(uuid.uuid4()),
                    &#34;stix_id&#34;: &#34;observable--&#34; + str(uuid.uuid4()),
                    &#34;type&#34;: ObservableTypes.DOMAIN.value,
                    &#34;value&#34;: observable_item[&#34;value&#34;],
                }
            ]
        elif observable_item[&#34;type&#34;] == &#34;email-addr&#34;:
            observables_to_create[key] = [
                {
                    &#34;id&#34;: str(uuid.uuid4()),
                    &#34;stix_id&#34;: &#34;observable--&#34; + str(uuid.uuid4()),
                    &#34;type&#34;: ObservableTypes.EMAIL_ADDR.value,
                    &#34;value&#34;: observable_item[&#34;value&#34;],
                }
            ]
            # TODO Belongs to ref
        # TODO email-message
        # TODO mime-part-type
        elif observable_item[&#34;type&#34;] == &#34;file&#34;:
            observables_to_create[key] = []
            if &#34;name&#34; in observable_item:
                observables_to_create[key].append(
                    {
                        &#34;id&#34;: str(uuid.uuid4()),
                        &#34;type&#34;: ObservableTypes.FILE_NAME.value,
                        &#34;value&#34;: observable_item[&#34;name&#34;],
                    }
                )
            if &#34;hashes&#34; in observable_item:
                for keyfile, value in observable_item[&#34;hashes&#34;].items():
                    if keyfile == &#34;MD5&#34;:
                        observables_to_create[key].append(
                            {
                                &#34;id&#34;: str(uuid.uuid4()),
                                &#34;type&#34;: ObservableTypes.FILE_HASH_MD5.value,
                                &#34;value&#34;: value,
                            }
                        )
                    if keyfile == &#34;SHA-1&#34;:
                        observables_to_create[key].append(
                            {
                                &#34;id&#34;: str(uuid.uuid4()),
                                &#34;type&#34;: ObservableTypes.FILE_HASH_SHA1.value,
                                &#34;value&#34;: value,
                            }
                        )
                    if keyfile == &#34;SHA-256&#34;:
                        observables_to_create[key].append(
                            {
                                &#34;id&#34;: str(uuid.uuid4()),
                                &#34;type&#34;: ObservableTypes.FILE_HASH_SHA256.value,
                                &#34;value&#34;: value,
                            }
                        )
        elif observable_item[&#34;type&#34;] == &#34;ipv4-addr&#34;:
            observables_to_create[key] = [
                {
                    &#34;id&#34;: str(uuid.uuid4()),
                    &#34;type&#34;: ObservableTypes.IPV4_ADDR.value,
                    &#34;value&#34;: observable_item[&#34;value&#34;],
                }
            ]
        elif observable_item[&#34;type&#34;] == &#34;ipv6-addr&#34;:
            observables_to_create[key] = [
                {
                    &#34;id&#34;: str(uuid.uuid4()),
                    &#34;type&#34;: ObservableTypes.IPV6_ADDR.value,
                    &#34;value&#34;: observable_item[&#34;value&#34;],
                }
            ]
        elif observable_item[&#34;type&#34;] == &#34;mac-addr&#34;:
            observables_to_create[key] = [
                {
                    &#34;id&#34;: str(uuid.uuid4()),
                    &#34;type&#34;: ObservableTypes.MAC_ADDR.value,
                    &#34;value&#34;: observable_item[&#34;value&#34;],
                }
            ]
        elif observable_item[&#34;type&#34;] == &#34;windows-registry-key&#34;:
            observables_to_create[key] = [
                {
                    &#34;id&#34;: str(uuid.uuid4()),
                    &#34;type&#34;: ObservableTypes.REGISTRY_KEY.value,
                    &#34;value&#34;: observable_item[&#34;key&#34;],
                }
            ]

    for key, observable_item in stix_object[&#34;objects&#34;].items():
        if observable_item[&#34;type&#34;] == &#34;directory&#34;:
            if &#34;contains_refs&#34; in observable_item:
                for file in observable_item[&#34;contains_refs&#34;]:
                    for observable_to_create_from in observables_to_create[key]:
                        for observables_to_create_to in observables_to_create[file]:
                            if (
                                observable_to_create_from[&#34;id&#34;]
                                != observables_to_create_to[&#34;id&#34;]
                            ):
                                relations_to_create.append(
                                    {
                                        &#34;id&#34;: str(uuid.uuid4()),
                                        &#34;from&#34;: observable_to_create_from[&#34;id&#34;],
                                        &#34;to&#34;: observables_to_create_to[&#34;id&#34;],
                                        &#34;type&#34;: &#34;contains&#34;,
                                    }
                                )
        if observable_item[&#34;type&#34;] == &#34;domain-name&#34;:
            if &#34;resolves_to_refs&#34; in observable_item:
                for resolved in observable_item[&#34;resolves_to_refs&#34;]:
                    for observable_to_create_from in observables_to_create[key]:
                        for observables_to_create_to in observables_to_create[
                            resolved
                        ]:
                            if (
                                observable_to_create_from[&#34;id&#34;]
                                != observables_to_create_to[&#34;id&#34;]
                            ):
                                relations_to_create.append(
                                    {
                                        &#34;id&#34;: str(uuid.uuid4()),
                                        &#34;from&#34;: observable_to_create_from[&#34;id&#34;],
                                        &#34;fromType&#34;: observable_to_create_from[
                                            &#34;type&#34;
                                        ],
                                        &#34;to&#34;: observables_to_create_to[&#34;id&#34;],
                                        &#34;toType&#34;: observables_to_create_to[&#34;type&#34;],
                                        &#34;type&#34;: &#34;resolves&#34;,
                                    }
                                )
        if observable_item[&#34;type&#34;] == &#34;file&#34;:
            for observable_to_create_from in observables_to_create[key]:
                for observables_to_create_to in observables_to_create[key]:
                    if (
                        observable_to_create_from[&#34;id&#34;]
                        != observables_to_create_to[&#34;id&#34;]
                    ):
                        relations_to_create.append(
                            {
                                &#34;id&#34;: str(uuid.uuid4()),
                                &#34;from&#34;: observable_to_create_from[&#34;id&#34;],
                                &#34;fromType&#34;: observable_to_create_from[&#34;type&#34;],
                                &#34;to&#34;: observables_to_create_to[&#34;id&#34;],
                                &#34;toType&#34;: observables_to_create_to[&#34;type&#34;],
                                &#34;type&#34;: &#34;corresponds&#34;,
                            }
                        )
        if observable_item[&#34;type&#34;] == &#34;ipv4-addr&#34;:
            if &#34;belongs_to_refs&#34; in observable_item:
                for belonging in observable_item[&#34;belongs_to_refs&#34;]:
                    for observable_to_create_from in observables_to_create[key]:
                        for observables_to_create_to in observables_to_create[
                            belonging
                        ]:
                            if (
                                observable_to_create_from[&#34;id&#34;]
                                != observables_to_create_to[&#34;id&#34;]
                            ):
                                relations_to_create.append(
                                    {
                                        &#34;id&#34;: str(uuid.uuid4()),
                                        &#34;from&#34;: observable_to_create_from[&#34;id&#34;],
                                        &#34;fromType&#34;: observable_to_create_from[
                                            &#34;type&#34;
                                        ],
                                        &#34;to&#34;: observables_to_create_to[&#34;id&#34;],
                                        &#34;toType&#34;: observables_to_create_to[&#34;type&#34;],
                                        &#34;type&#34;: &#34;belongs&#34;,
                                    }
                                )

    stix_observables_mapping = {}
    self.mapping_cache[stix_object[&#34;id&#34;]] = []
    for key, observable_to_create in observables_to_create.items():
        for observable in observable_to_create:
            observable_result = self.opencti.stix_observable.create(
                type=observable[&#34;type&#34;],
                observable_value=observable[&#34;value&#34;],
                id=observable[&#34;id&#34;],
                createdByRef=created_by_ref_id,
                markingDefinitions=marking_definitions_ids,
                createIndicator=stix_object[CustomProperties.CREATE_INDICATOR]
                if CustomProperties.CREATE_INDICATOR in stix_object
                else False,
            )
            stix_observables_mapping[observable[&#34;id&#34;]] = observable_result[&#34;id&#34;]
            self.mapping_cache[stix_object[&#34;id&#34;]].append(
                {
                    &#34;id&#34;: observable_result[&#34;id&#34;],
                    &#34;type&#34;: observable_result[&#34;entity_type&#34;],
                }
            )

    stix_observable_relations_mapping = {}
    for relation_to_create in relations_to_create:
        stix_observable_relation_result = self.opencti.stix_observable_relation.create(
            fromId=stix_observables_mapping[relation_to_create[&#34;from&#34;]],
            fromType=relation_to_create[&#34;fromType&#34;],
            toId=stix_observables_mapping[relation_to_create[&#34;to&#34;]],
            toType=relation_to_create[&#34;toType&#34;],
            relationship_type=relation_to_create[&#34;type&#34;],
            createdByRef=created_by_ref_id,
            markingDefinitions=marking_definitions_ids,
        )
        stix_observable_relations_mapping[
            relation_to_create[&#34;id&#34;]
        ] = stix_observable_relation_result[&#34;id&#34;]</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIStix2.import_relationship"><code class="name flex">
<span>def <span class="ident">import_relationship</span></span>(<span>self, stix_relation, update=False, types=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def import_relationship(self, stix_relation, update=False, types=None):
    # Extract
    embedded_relationships = self.extract_embedded_relationships(
        stix_relation, types
    )
    created_by_ref_id = embedded_relationships[&#34;created_by_ref&#34;]
    marking_definitions_ids = embedded_relationships[&#34;marking_definitions&#34;]
    kill_chain_phases_ids = embedded_relationships[&#34;kill_chain_phases&#34;]
    external_references_ids = embedded_relationships[&#34;external_references&#34;]
    reports = embedded_relationships[&#34;reports&#34;]

    # Extra
    extras = {
        &#34;created_by_ref_id&#34;: created_by_ref_id,
        &#34;marking_definitions_ids&#34;: marking_definitions_ids,
        &#34;kill_chain_phases_ids&#34;: kill_chain_phases_ids,
        &#34;external_references_ids&#34;: external_references_ids,
        &#34;reports&#34;: reports,
    }

    # Create the relation

    ### Get the SOURCE_REF
    if CustomProperties.SOURCE_REF in stix_relation:
        source_ref = stix_relation[CustomProperties.SOURCE_REF]
    else:
        source_ref = stix_relation[&#34;source_ref&#34;]
    if source_ref in self.mapping_cache:
        if (
            StixObservableRelationTypes.has_value(
                stix_relation[&#34;relationship_type&#34;]
            )
            and &#34;observableRefs&#34; in self.mapping_cache[source_ref]
            and self.mapping_cache[source_ref][&#34;observableRefs&#34;] is not None
            and len(self.mapping_cache[source_ref][&#34;observableRefs&#34;]) &gt; 0
        ):
            source_id = self.mapping_cache[source_ref][&#34;observableRefs&#34;][0][&#34;id&#34;]
            source_type = self.mapping_cache[source_ref][&#34;observableRefs&#34;][0][
                &#34;entity_type&#34;
            ]
        else:
            source_id = self.mapping_cache[source_ref][&#34;id&#34;]
            source_type = self.mapping_cache[source_ref][&#34;type&#34;]
    else:
        stix_object_result = self.opencti.stix_entity.read(id=source_ref)
        if stix_object_result is not None:
            source_id = stix_object_result[&#34;id&#34;]
            source_type = stix_object_result[&#34;entity_type&#34;]
        else:
            self.opencti.log(
                &#34;error&#34;,
                &#34;Source ref of the relationship not found, doing nothing...&#34;,
            )
            return None

    ### Get the TARGET_REF
    if CustomProperties.TARGET_REF in stix_relation:
        target_ref = stix_relation[CustomProperties.TARGET_REF]
    else:
        target_ref = stix_relation[&#34;target_ref&#34;]
    if target_ref in self.mapping_cache:
        if (
            StixObservableRelationTypes.has_value(
                stix_relation[&#34;relationship_type&#34;]
            )
            and &#34;observableRefs&#34; in self.mapping_cache[target_ref]
            and self.mapping_cache[target_ref][&#34;observableRefs&#34;] is not None
            and len(self.mapping_cache[target_ref][&#34;observableRefs&#34;]) &gt; 0
        ):
            target_id = self.mapping_cache[target_ref][&#34;observableRefs&#34;][0][&#34;id&#34;]
            target_type = self.mapping_cache[target_ref][&#34;observableRefs&#34;][0][
                &#34;entity_type&#34;
            ]
        else:
            target_id = self.mapping_cache[target_ref][&#34;id&#34;]
            target_type = self.mapping_cache[target_ref][&#34;type&#34;]
    else:
        stix_object_result = self.opencti.stix_entity.read(id=target_ref)
        if stix_object_result is not None:
            target_id = stix_object_result[&#34;id&#34;]
            target_type = stix_object_result[&#34;entity_type&#34;]
        else:
            self.opencti.log(
                &#34;error&#34;,
                &#34;Target ref of the relationship not found, doing nothing...&#34;,
            )
            return None

    date = None
    if &#34;external_references&#34; in stix_relation:
        for external_reference in stix_relation[&#34;external_references&#34;]:
            try:
                if &#34;description&#34; in external_reference:
                    matches = datefinder.find_dates(
                        external_reference[&#34;description&#34;]
                    )
                else:
                    matches = datefinder.find_dates(
                        external_reference[&#34;source_name&#34;]
                    )
            except:
                matches = None
            date = None
            today = datetime.datetime.today()
            if matches is not None:
                for match in matches:
                    if match &lt; today:
                        date = match.strftime(&#34;%Y-%m-%dT%H:%M:%SZ&#34;)
    if date is None:
        date = datetime.datetime.today().strftime(&#34;%Y-%m-%dT%H:%M:%SZ&#34;)

    stix_relation_result = None
    if StixObservableRelationTypes.has_value(stix_relation[&#34;relationship_type&#34;]):
        stix_relation_result = self.opencti.stix_observable_relation.create(
            fromId=source_id,
            fromType=source_type,
            toId=target_id,
            toType=target_type,
            relationship_type=stix_relation[&#34;relationship_type&#34;],
            description=self.convert_markdown(stix_relation[&#34;description&#34;])
            if &#34;description&#34; in stix_relation
            else None,
            first_seen=stix_relation[CustomProperties.FIRST_SEEN]
            if CustomProperties.FIRST_SEEN in stix_relation
            else date,
            last_seen=stix_relation[CustomProperties.LAST_SEEN]
            if CustomProperties.LAST_SEEN in stix_relation
            else date,
            weight=stix_relation[CustomProperties.WEIGHT]
            if CustomProperties.WEIGHT in stix_relation
            else 1,
            role_played=stix_relation[CustomProperties.ROLE_PLAYED]
            if CustomProperties.ROLE_PLAYED in stix_relation
            else None,
            id=stix_relation[CustomProperties.ID]
            if CustomProperties.ID in stix_relation
            else None,
            stix_id_key=stix_relation[&#34;id&#34;] if &#34;id&#34; in stix_relation else None,
            created=stix_relation[&#34;created&#34;]
            if &#34;created&#34; in stix_relation
            else None,
            modified=stix_relation[&#34;modified&#34;]
            if &#34;modified&#34; in stix_relation
            else None,
            createdByRef=extras[&#34;created_by_ref_id&#34;]
            if &#34;created_by_ref_id&#34; in extras
            else None,
            markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
            if &#34;marking_definitions_ids&#34; in extras
            else [],
            killChainPhases=extras[&#34;kill_chain_phases_ids&#34;]
            if &#34;kill_chain_phases_ids&#34; in extras
            else [],
            update=update,
            ignore_dates=stix_relation[CustomProperties.IGNORE_DATES]
            if CustomProperties.IGNORE_DATES in stix_relation
            else None,
        )
    else:
        stix_relation_result = self.opencti.stix_relation.create(
            fromId=source_id,
            fromType=source_type,
            toId=target_id,
            toType=target_type,
            relationship_type=stix_relation[&#34;relationship_type&#34;],
            description=self.convert_markdown(stix_relation[&#34;description&#34;])
            if &#34;description&#34; in stix_relation
            else None,
            first_seen=stix_relation[CustomProperties.FIRST_SEEN]
            if CustomProperties.FIRST_SEEN in stix_relation
            else date,
            last_seen=stix_relation[CustomProperties.LAST_SEEN]
            if CustomProperties.LAST_SEEN in stix_relation
            else date,
            weight=stix_relation[CustomProperties.WEIGHT]
            if CustomProperties.WEIGHT in stix_relation
            else 1,
            role_played=stix_relation[CustomProperties.ROLE_PLAYED]
            if CustomProperties.ROLE_PLAYED in stix_relation
            else None,
            id=stix_relation[CustomProperties.ID]
            if CustomProperties.ID in stix_relation
            else None,
            stix_id_key=stix_relation[&#34;id&#34;] if &#34;id&#34; in stix_relation else None,
            created=stix_relation[&#34;created&#34;]
            if &#34;created&#34; in stix_relation
            else None,
            modified=stix_relation[&#34;modified&#34;]
            if &#34;modified&#34; in stix_relation
            else None,
            createdByRef=extras[&#34;created_by_ref_id&#34;]
            if &#34;created_by_ref_id&#34; in extras
            else None,
            markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
            if &#34;marking_definitions_ids&#34; in extras
            else [],
            killChainPhases=extras[&#34;kill_chain_phases_ids&#34;]
            if &#34;kill_chain_phases_ids&#34; in extras
            else [],
            update=update,
            ignore_dates=stix_relation[CustomProperties.IGNORE_DATES]
            if CustomProperties.IGNORE_DATES in stix_relation
            else None,
        )
    if stix_relation_result is not None:
        self.mapping_cache[stix_relation[&#34;id&#34;]] = {
            &#34;id&#34;: stix_relation_result[&#34;id&#34;],
            &#34;type&#34;: stix_relation_result[&#34;entity_type&#34;],
        }
    else:
        return None

    # Add external references
    for external_reference_id in external_references_ids:
        self.opencti.stix_entity.add_external_reference(
            id=stix_relation_result[&#34;id&#34;],
            external_reference_id=external_reference_id,
        )
        if external_reference_id in reports:
            self.opencti.report.add_stix_entity(
                id=reports[external_reference_id][&#34;id&#34;],
                entity_id=stix_relation_result[&#34;id&#34;],
            )
            self.opencti.report.add_stix_entity(
                id=reports[external_reference_id][&#34;id&#34;], entity_id=source_id,
            )
            self.opencti.report.add_stix_entity(
                id=reports[external_reference_id][&#34;id&#34;], entity_id=target_id,
            )</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIStix2.pick_aliases"><code class="name flex">
<span>def <span class="ident">pick_aliases</span></span>(<span>self, stix_object)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pick_aliases(self, stix_object):
    # Add aliases
    if CustomProperties.ALIASES in stix_object:
        return stix_object[CustomProperties.ALIASES]
    elif &#34;x_mitre_aliases&#34; in stix_object:
        return stix_object[&#34;x_mitre_aliases&#34;]
    elif &#34;x_amitt_aliases&#34; in stix_object:
        return stix_object[&#34;x_amitt_aliases&#34;]
    elif &#34;aliases&#34; in stix_object:
        return stix_object[&#34;aliases&#34;]
    return None</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIStix2.prepare_export"><code class="name flex">
<span>def <span class="ident">prepare_export</span></span>(<span>self, entity, stix_object, mode='simple', max_marking_definition_entity=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepare_export(
    self, entity, stix_object, mode=&#34;simple&#34;, max_marking_definition_entity=None
):
    if (
        self.check_max_marking_definition(
            max_marking_definition_entity, entity[&#34;markingDefinitions&#34;]
        )
        is False
    ):
        self.opencti.log(
            &#34;info&#34;,
            &#34;Marking definitions of &#34;
            + stix_object[&#34;type&#34;]
            + &#39; &#34;&#39;
            + stix_object[&#34;name&#34;]
            + &#39;&#34; are less than max definition, not exporting.&#39;,
        )
        return []
    result = []
    objects_to_get = []
    relations_to_get = []
    if &#34;createdByRef&#34; in entity and entity[&#34;createdByRef&#34;] is not None:
        entity_created_by_ref = entity[&#34;createdByRef&#34;]
        if entity_created_by_ref[&#34;entity_type&#34;] == &#34;user&#34;:
            identity_class = &#34;individual&#34;
        elif entity_created_by_ref[&#34;entity_type&#34;] == &#34;sector&#34;:
            identity_class = &#34;class&#34;
        else:
            identity_class = entity_created_by_ref[&#34;entity_type&#34;]

        created_by_ref = dict()
        created_by_ref[&#34;id&#34;] = entity_created_by_ref[&#34;stix_id_key&#34;]
        created_by_ref[&#34;type&#34;] = &#34;identity&#34;
        created_by_ref[&#34;name&#34;] = entity_created_by_ref[&#34;name&#34;]
        created_by_ref[&#34;identity_class&#34;] = identity_class
        if self.opencti.not_empty(entity_created_by_ref[&#34;stix_label&#34;]):
            created_by_ref[&#34;labels&#34;] = entity_created_by_ref[&#34;stix_label&#34;]
        else:
            created_by_ref[&#34;labels&#34;] = [&#34;identity&#34;]
        created_by_ref[&#34;created&#34;] = self.format_date(
            entity_created_by_ref[&#34;created&#34;]
        )
        created_by_ref[&#34;modified&#34;] = self.format_date(
            entity_created_by_ref[&#34;modified&#34;]
        )
        if (
            entity_created_by_ref[&#34;entity_type&#34;] == &#34;organization&#34;
            and &#34;organization_class&#34; in entity_created_by_ref
        ):
            created_by_ref[CustomProperties.ORG_CLASS] = entity_created_by_ref[
                &#34;organization_class&#34;
            ]
        if self.opencti.not_empty(entity_created_by_ref[&#34;alias&#34;]):
            created_by_ref[CustomProperties.ALIASES] = entity_created_by_ref[
                &#34;alias&#34;
            ]
        created_by_ref[CustomProperties.IDENTITY_TYPE] = entity_created_by_ref[
            &#34;entity_type&#34;
        ]
        created_by_ref[CustomProperties.ID] = entity_created_by_ref[&#34;id&#34;]

        stix_object[&#34;created_by_ref&#34;] = created_by_ref[&#34;id&#34;]
        result.append(created_by_ref)
    if &#34;markingDefinitions&#34; in entity and len(entity[&#34;markingDefinitions&#34;]) &gt; 0:
        marking_definitions = []
        for entity_marking_definition in entity[&#34;markingDefinitions&#34;]:
            marking_definition = {
                &#34;id&#34;: entity_marking_definition[&#34;stix_id_key&#34;],
                &#34;type&#34;: &#34;marking-definition&#34;,
                &#34;definition_type&#34;: entity_marking_definition[
                    &#34;definition_type&#34;
                ].lower(),
                &#34;definition&#34;: {
                    entity_marking_definition[
                        &#34;definition_type&#34;
                    ]: entity_marking_definition[&#34;definition&#34;]
                },
                &#34;created&#34;: entity_marking_definition[&#34;created&#34;],
                CustomProperties.MODIFIED: entity_marking_definition[&#34;modified&#34;],
                CustomProperties.ID: entity_marking_definition[&#34;id&#34;],
            }
            marking_definitions.append(marking_definition[&#34;id&#34;])
            result.append(marking_definition)
        stix_object[&#34;object_marking_refs&#34;] = marking_definitions
    if &#34;tags&#34; in entity and len(entity[&#34;tags&#34;]) &gt; 0:
        tags = []
        for entity_tag in entity[&#34;tags&#34;]:
            tag = dict()
            tag[&#34;id&#34;] = entity_tag[&#34;id&#34;]
            tag[&#34;tag_type&#34;] = entity_tag[&#34;tag_type&#34;]
            tag[&#34;value&#34;] = entity_tag[&#34;value&#34;]
            tag[&#34;color&#34;] = entity_tag[&#34;color&#34;]
            tags.append(tag)
        stix_object[CustomProperties.TAG_TYPE] = tags
    if &#34;killChainPhases&#34; in entity and len(entity[&#34;killChainPhases&#34;]) &gt; 0:
        kill_chain_phases = []
        for entity_kill_chain_phase in entity[&#34;killChainPhases&#34;]:
            kill_chain_phase = {
                &#34;id&#34;: entity_kill_chain_phase[&#34;stix_id_key&#34;],
                &#34;kill_chain_name&#34;: entity_kill_chain_phase[&#34;kill_chain_name&#34;],
                &#34;phase_name&#34;: entity_kill_chain_phase[&#34;phase_name&#34;],
                CustomProperties.ID: entity_kill_chain_phase[&#34;id&#34;],
                CustomProperties.PHASE_ORDER: entity_kill_chain_phase[
                    &#34;phase_order&#34;
                ],
                CustomProperties.CREATED: entity_kill_chain_phase[&#34;created&#34;],
                CustomProperties.MODIFIED: entity_kill_chain_phase[&#34;modified&#34;],
            }
            kill_chain_phases.append(kill_chain_phase)
        stix_object[&#34;kill_chain_phases&#34;] = kill_chain_phases
    if &#34;externalReferences&#34; in entity and len(entity[&#34;externalReferences&#34;]) &gt; 0:
        external_references = []
        for entity_external_reference in entity[&#34;externalReferences&#34;]:
            external_reference = dict()
            external_reference[&#34;id&#34;] = entity_external_reference[&#34;stix_id_key&#34;]
            if self.opencti.not_empty(entity_external_reference[&#34;source_name&#34;]):
                external_reference[&#34;source_name&#34;] = entity_external_reference[
                    &#34;source_name&#34;
                ]
            if self.opencti.not_empty(entity_external_reference[&#34;description&#34;]):
                external_reference[&#34;description&#34;] = entity_external_reference[
                    &#34;description&#34;
                ]
            if self.opencti.not_empty(entity_external_reference[&#34;url&#34;]):
                external_reference[&#34;url&#34;] = entity_external_reference[&#34;url&#34;]
            if self.opencti.not_empty(entity_external_reference[&#34;hash&#34;]):
                external_reference[&#34;hash&#34;] = entity_external_reference[&#34;hash&#34;]
            if self.opencti.not_empty(entity_external_reference[&#34;external_id&#34;]):
                external_reference[&#34;external_id&#34;] = entity_external_reference[
                    &#34;external_id&#34;
                ]
            external_reference[CustomProperties.ID] = entity_external_reference[
                &#34;id&#34;
            ]
            external_reference[
                CustomProperties.CREATED
            ] = entity_external_reference[&#34;created&#34;]
            external_reference[
                CustomProperties.MODIFIED
            ] = entity_external_reference[&#34;modified&#34;]
            external_references.append(external_reference)
        stix_object[&#34;external_references&#34;] = external_references
    if &#34;objectRefs&#34; in entity and len(entity[&#34;objectRefs&#34;]) &gt; 0:
        object_refs = []
        objects_to_get = entity[&#34;objectRefs&#34;]
        for entity_object_ref in entity[&#34;objectRefs&#34;]:
            object_refs.append(entity_object_ref[&#34;stix_id_key&#34;])
        if &#34;relationRefs&#34; in entity and len(entity[&#34;relationRefs&#34;]) &gt; 0:
            relations_to_get = entity[&#34;relationRefs&#34;]
            for entity_relation_ref in entity[&#34;relationRefs&#34;]:
                if entity_relation_ref[&#34;stix_id_key&#34;] not in object_refs:
                    object_refs.append(entity_relation_ref[&#34;stix_id_key&#34;])
        stix_object[&#34;object_refs&#34;] = object_refs

    uuids = []
    for x in result:
        uuids.append(x[&#34;id&#34;])

    observables_stix_ids = []
    observable_object_data = None
    if &#34;observableRefs&#34; in entity and len(entity[&#34;observableRefs&#34;]) &gt; 0:
        observable_object_data = self.export_stix_observables(entity)
        if observable_object_data is not None:
            observable_object_bundle = self.filter_objects(
                uuids, [observable_object_data[&#34;observedData&#34;]]
            )
            uuids = uuids + [x[&#34;id&#34;] for x in observable_object_bundle]
            result = result + observable_object_bundle
            observables_stix_ids = (
                observables_stix_ids + observable_object_data[&#34;stixIds&#34;]
            )
            if stix_object[&#34;type&#34;] == &#34;report&#34;:
                if &#34;object_refs&#34; in stix_object:
                    stix_object[&#34;object_refs&#34;].append(
                        observable_object_data[&#34;observedData&#34;][&#34;id&#34;]
                    )
                else:
                    stix_object[&#34;object_refs&#34;] = [
                        observable_object_data[&#34;observedData&#34;][&#34;id&#34;]
                    ]
    result.append(stix_object)

    if mode == &#34;simple&#34;:
        return result
    elif mode == &#34;full&#34;:
        # Get extra relations
        stix_relations = self.opencti.stix_relation.list(
            fromId=entity[&#34;id&#34;], forceNatural=True
        )
        for stix_relation in stix_relations:
            if self.check_max_marking_definition(
                max_marking_definition_entity, stix_relation[&#34;markingDefinitions&#34;]
            ):
                if stix_relation[&#34;to&#34;][&#34;id&#34;] == entity[&#34;id&#34;]:
                    other_side_entity = stix_relation[&#34;from&#34;]
                else:
                    other_side_entity = stix_relation[&#34;to&#34;]
                objects_to_get.append(other_side_entity)
                if other_side_entity[&#34;stix_id_key&#34;] in observables_stix_ids:
                    other_side_entity[&#34;stix_id_key&#34;] = observable_object_data[
                        &#34;observedData&#34;
                    ][&#34;id&#34;]
                relation_object_data = self.opencti.stix_relation.to_stix2(
                    entity=stix_relation
                )
                relation_object_bundle = self.filter_objects(
                    uuids, relation_object_data
                )
                uuids = uuids + [x[&#34;id&#34;] for x in relation_object_bundle]
                result = result + relation_object_bundle
            else:
                self.opencti.log(
                    &#34;info&#34;,
                    &#34;Marking definitions of &#34;
                    + stix_relation[&#34;entity_type&#34;]
                    + &#39; &#34;&#39;
                    + stix_relation[&#34;id&#34;]
                    + &#39;&#34; are less than max definition, not exporting the relation AND the target entity.&#39;,
                )

        # Export
        exporter = {
            &#34;identity&#34;: self.opencti.identity.to_stix2,
            &#34;threat-actor&#34;: self.opencti.threat_actor.to_stix2,
            &#34;intrusion-set&#34;: self.opencti.intrusion_set.to_stix2,
            &#34;campaign&#34;: self.opencti.campaign.to_stix2,
            &#34;incident&#34;: self.opencti.incident.to_stix2,
            &#34;malware&#34;: self.opencti.malware.to_stix2,
            &#34;tool&#34;: self.opencti.tool.to_stix2,
            &#34;vulnerability&#34;: self.opencti.vulnerability.to_stix2,
            &#34;attack-pattern&#34;: self.opencti.attack_pattern.to_stix2,
            &#34;course-of-action&#34;: self.opencti.course_of_action.to_stix2,
            &#34;report&#34;: self.opencti.report.to_stix2,
            &#34;note&#34;: self.opencti.note.to_stix2,
            &#34;opinion&#34;: self.opencti.opinion.to_stix2,
            &#34;indicator&#34;: self.opencti.indicator.to_stix2,
        }

        # Get extra objects
        for entity_object in objects_to_get:
            # Map types
            if IdentityTypes.has_value(entity_object[&#34;entity_type&#34;]):
                entity_object[&#34;entity_type&#34;] = &#34;identity&#34;
            do_export = exporter.get(
                entity_object[&#34;entity_type&#34;],
                lambda **kwargs: self.unknown_type(
                    {&#34;type&#34;: entity_object[&#34;entity_type&#34;]}
                ),
            )
            entity_object_data = do_export(id=entity_object[&#34;id&#34;])
            # Add to result
            entity_object_bundle = self.filter_objects(uuids, entity_object_data)
            uuids = uuids + [x[&#34;id&#34;] for x in entity_object_bundle]
            result = result + entity_object_bundle
        for relation_object in relations_to_get:
            relation_object_data = self.opencti.stix_relation.to_stix2(
                id=relation_object[&#34;id&#34;]
            )
            relation_object_bundle = self.filter_objects(
                uuids, relation_object_data
            )
            uuids = uuids + [x[&#34;id&#34;] for x in relation_object_bundle]
            result = result + relation_object_bundle

        # Get extra reports
        &#34;&#34;&#34;
        for uuid in uuids:
            if &#34;marking-definition&#34; not in uuid:
                reports = self.opencti.stix_entity.reports(id=uuid)
                for report in reports:
                    report_object_data = self.opencti.report.to_stix2(
                        entity=report,
                        mode=&#34;simple&#34;,
                        max_marking_definition_entity=max_marking_definition_entity,
                    )
                    report_object_bundle = self.filter_objects(
                        uuids, report_object_data
                    )
                    uuids = uuids + [x[&#34;id&#34;] for x in report_object_bundle]
                    result = result + report_object_bundle
        &#34;&#34;&#34;

        # Refilter all the reports object refs
        final_result = []
        for entity in result:
            if entity[&#34;type&#34;] == &#34;report&#34;:
                if &#34;object_refs&#34; in entity:
                    entity[&#34;object_refs&#34;] = [
                        k for k in entity[&#34;object_refs&#34;] if k in uuids
                    ]
                final_result.append(entity)
            else:
                final_result.append(entity)
        return final_result
    else:
        return []</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIStix2.resolve_author"><code class="name flex">
<span>def <span class="ident">resolve_author</span></span>(<span>self, title)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resolve_author(self, title):
    if &#34;fireeye&#34; in title.lower() or &#34;mandiant&#34; in title.lower():
        return self.get_author(&#34;FireEye&#34;)
    if &#34;eset&#34; in title.lower():
        return self.get_author(&#34;ESET&#34;)
    if &#34;dragos&#34; in title.lower():
        return self.get_author(&#34;Dragos&#34;)
    if &#34;us-cert&#34; in title.lower():
        return self.get_author(&#34;US-CERT&#34;)
    if (
        &#34;unit 42&#34; in title.lower()
        or &#34;unit42&#34; in title.lower()
        or &#34;palo alto&#34; in title.lower()
    ):
        return self.get_author(&#34;Palo Alto Networks&#34;)
    if &#34;accenture&#34; in title.lower():
        return self.get_author(&#34;Accenture&#34;)
    if &#34;symantec&#34; in title.lower():
        return self.get_author(&#34;Symantec&#34;)
    if &#34;trendmicro&#34; in title.lower() or &#34;trend micro&#34; in title.lower():
        return self.get_author(&#34;Trend Micro&#34;)
    if &#34;mcafee&#34; in title.lower():
        return self.get_author(&#34;McAfee&#34;)
    if &#34;crowdstrike&#34; in title.lower():
        return self.get_author(&#34;CrowdStrike&#34;)
    if &#34;securelist&#34; in title.lower() or &#34;kaspersky&#34; in title.lower():
        return self.get_author(&#34;Kaspersky&#34;)
    if &#34;f-secure&#34; in title.lower():
        return self.get_author(&#34;F-Secure&#34;)
    if &#34;checkpoint&#34; in title.lower():
        return self.get_author(&#34;CheckPoint&#34;)
    if &#34;talos&#34; in title.lower():
        return self.get_author(&#34;Cisco Talos&#34;)
    if &#34;secureworks&#34; in title.lower():
        return self.get_author(&#34;Dell SecureWorks&#34;)
    if &#34;microsoft&#34; in title.lower():
        return self.get_author(&#34;Microsoft&#34;)
    if &#34;mitre att&amp;ck&#34; in title.lower():
        return self.get_author(&#34;The MITRE Corporation&#34;)
    return None</code></pre>
</details>
</dd>
<dt id="pycti.OpenCTIStix2.unknown_type"><code class="name flex">
<span>def <span class="ident">unknown_type</span></span>(<span>self, stix_object)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unknown_type(self, stix_object):
    self.opencti.log(
        &#34;error&#34;,
        &#39;Unknown object type &#34;&#39; + stix_object[&#34;type&#34;] + &#39;&#34;, doing nothing...&#39;,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pycti.Opinion"><code class="flex name class">
<span>class <span class="ident">Opinion</span></span>
<span>(</span><span>opencti)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Opinion:
    def __init__(self, opencti):
        self.opencti = opencti
        self.properties = &#34;&#34;&#34;
            id
            stix_id_key
            entity_type
            stix_label
            name
            alias
            description
            explanation
            graph_data
            created
            modified
            created_at
            updated_at
            createdByRef {
                node {
                    id
                    entity_type
                    stix_id_key
                    stix_label
                    name
                    alias
                    description
                    created
                    modified
                    ... on Organization {
                        organization_class
                    }
                }
                relation {
                    id
                }
            }
            markingDefinitions {
                edges {
                    node {
                        id
                        entity_type
                        stix_id_key
                        definition_type
                        definition
                        level
                        color
                        created
                        modified
                    }
                    relation {
                        id
                    }
                }
            }
            tags {
                edges {
                    node {
                        id
                        tag_type
                        value
                        color
                    }
                    relation {
                        id
                    }
                }
            }            
            externalReferences {
                edges {
                    node {
                        id
                        entity_type
                        stix_id_key
                        source_name
                        description
                        url
                        hash
                        external_id
                        created
                        modified
                    }
                    relation {
                        id
                    }
                }
            }
            objectRefs {
                edges {
                    node {
                        id
                        stix_id_key
                        entity_type
                    }
                }
            }
            observableRefs {
                edges {
                    node {
                        id
                        stix_id_key
                        entity_type
                        observable_value
                    }
                }
            }
            relationRefs {
                edges {
                    node {
                        id
                        stix_id_key
                    }
                }
            }
        &#34;&#34;&#34;

    &#34;&#34;&#34;
        List Opinion objects

        :param filters: the filters to apply
        :param search: the search keyword
        :param first: return the first n rows from the after ID (or the beginning if not set)
        :param after: ID of the first row for pagination
        :return List of Opinion objects
    &#34;&#34;&#34;

    def list(self, **kwargs):
        filters = kwargs.get(&#34;filters&#34;, None)
        search = kwargs.get(&#34;search&#34;, None)
        first = kwargs.get(&#34;first&#34;, 500)
        after = kwargs.get(&#34;after&#34;, None)
        order_by = kwargs.get(&#34;orderBy&#34;, None)
        order_mode = kwargs.get(&#34;orderMode&#34;, None)
        get_all = kwargs.get(&#34;getAll&#34;, False)
        if get_all:
            first = 500

        self.opencti.log(
            &#34;info&#34;, &#34;Listing Opinions with filters &#34; + json.dumps(filters) + &#34;.&#34;
        )
        query = (
            &#34;&#34;&#34;
            query Opinions($filters: [OpinionsFiltering], $search: String, $first: Int, $after: ID, $orderBy: OpinionsOrdering, $orderMode: OrderingMode) {
                opinions(filters: $filters, search: $search, first: $first, after: $after, orderBy: $orderBy, orderMode: $orderMode) {
                    edges {
                        node {
                            &#34;&#34;&#34;
            + self.properties
            + &#34;&#34;&#34;
                        }
                    }
                    pageInfo {
                        startCursor
                        endCursor
                        hasNextPage
                        hasPreviousPage
                        globalCount
                    }                    
                }
            }
        &#34;&#34;&#34;
        )
        result = self.opencti.query(
            query,
            {
                &#34;filters&#34;: filters,
                &#34;search&#34;: search,
                &#34;first&#34;: first,
                &#34;after&#34;: after,
                &#34;orderBy&#34;: order_by,
                &#34;orderMode&#34;: order_mode,
            },
        )
        return self.opencti.process_multiple(result[&#34;data&#34;][&#34;opinions&#34;])

    &#34;&#34;&#34;
        Read a Opinion object

        :param id: the id of the Opinion
        :param filters: the filters to apply if no id provided
        :return Opinion object
    &#34;&#34;&#34;

    def read(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        filters = kwargs.get(&#34;filters&#34;, None)
        custom_attributes = kwargs.get(&#34;customAttributes&#34;, None)
        if id is not None:
            self.opencti.log(&#34;info&#34;, &#34;Reading Opinion {&#34; + id + &#34;}.&#34;)
            query = (
                &#34;&#34;&#34;
                query Opinion($id: String!) {
                    opinion(id: $id) {
                        &#34;&#34;&#34;
                + (
                    custom_attributes
                    if custom_attributes is not None
                    else self.properties
                )
                + &#34;&#34;&#34;
                    }
                }
            &#34;&#34;&#34;
            )
            result = self.opencti.query(query, {&#34;id&#34;: id})
            return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;opinion&#34;])
        elif filters is not None:
            result = self.list(filters=filters)
            if len(result) &gt; 0:
                return result[0]
            else:
                return None

    &#34;&#34;&#34;
        Read a Opinion object by stix_id or name

        :param type: the Stix-Domain-Entity type
        :param stix_id_key: the STIX ID of the Stix-Domain-Entity
        :param name: the name of the Stix-Domain-Entity
        :return Stix-Domain-Entity object
    &#34;&#34;&#34;

    def get_by_stix_id_or_name(self, **kwargs):
        stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
        description = kwargs.get(&#34;description&#34;, None)
        explanation = kwargs.get(&#34;explanation&#34;, None)
        custom_attributes = kwargs.get(explanation, None)
        object_result = None
        if stix_id_key is not None:
            object_result = self.read(
                id=stix_id_key, customAttributes=custom_attributes
            )
        if (
            object_result is None
            and description is not None
            and explanation is not None
        ):
            object_result = self.read(
                filters=[
                    {&#34;key&#34;: &#34;description&#34;, &#34;values&#34;: [description]},
                    {&#34;key&#34;: &#34;explanation&#34;, &#34;values&#34;: [explanation]},
                ],
                customAttributes=custom_attributes,
            )
        return object_result

    &#34;&#34;&#34;
        Check if a opinion already contains a STIX entity
        
        :return Boolean
    &#34;&#34;&#34;

    def contains_stix_entity(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        entity_id = kwargs.get(&#34;entity_id&#34;, None)
        if id is not None and entity_id is not None:
            self.opencti.log(
                &#34;info&#34;,
                &#34;Checking Stix-Entity {&#34; + entity_id + &#34;} in Opinion {&#34; + id + &#34;}&#34;,
            )
            query = &#34;&#34;&#34;
                query OpinionContainsStixDomainEntity($id: String!, $objectId: String!) {
                    opinionContainsStixDomainEntity(id: $id, objectId: $objectId)
                }
            &#34;&#34;&#34;
            result = self.opencti.query(query, {&#34;id&#34;: id, &#34;objectId&#34;: entity_id})
            if result[&#34;data&#34;][&#34;opinionContainsStixDomainEntity&#34;]:
                return True
            query = &#34;&#34;&#34;
                query OpinionContainsStixRelation($id: String!, $objectId: String!) {
                    opinionContainsStixRelation(id: $id, objectId: $objectId)
                }
            &#34;&#34;&#34;
            result = self.opencti.query(query, {&#34;id&#34;: id, &#34;objectId&#34;: entity_id})
            return result[&#34;data&#34;][&#34;opinionContainsStixRelation&#34;]
        else:
            self.opencti.log(
                &#34;error&#34;, &#34;[opencti_opinion] Missing parameters: id or entity_id&#34;,
            )

    &#34;&#34;&#34;
        Check if a opinion already contains a STIX observable

        :return Boolean
    &#34;&#34;&#34;

    def contains_stix_observable(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        stix_observable_id = kwargs.get(&#34;stix_observable_id&#34;, None)
        if id is not None and stix_observable_id is not None:
            self.opencti.log(
                &#34;info&#34;,
                &#34;Checking Stix-Observable {&#34;
                + stix_observable_id
                + &#34;} in Opinion {&#34;
                + id
                + &#34;}&#34;,
            )
            query = &#34;&#34;&#34;
                query OpinionContainsStixObservable($id: String!, $objectId: String!) {
                    opinionContainsStixObservable(id: $id, objectId: $objectId)
                }
            &#34;&#34;&#34;
            result = self.opencti.query(
                query, {&#34;id&#34;: id, &#34;objectId&#34;: stix_observable_id}
            )
            return result[&#34;data&#34;][&#34;opinionContainsStixObservable&#34;]
        else:
            self.opencti.log(
                &#34;error&#34;,
                &#34;[opencti_opinion] Missing parameters: id or stix_observable_id&#34;,
            )

    &#34;&#34;&#34;
        Create a Opinion object

        :param name: the name of the Opinion
        :return Opinion object
    &#34;&#34;&#34;

    def create_raw(self, **kwargs):
        name = kwargs.get(&#34;name&#34;, None)
        description = kwargs.get(&#34;description&#34;, None)
        explanation = kwargs.get(&#34;explanation&#34;, None)
        graph_data = kwargs.get(&#34;graph_data&#34;, None)
        id = kwargs.get(&#34;id&#34;, None)
        stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
        created = kwargs.get(&#34;created&#34;, None)
        modified = kwargs.get(&#34;modified&#34;, None)
        created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
        marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)

        if name is not None and description is not None and explanation is not None:
            self.opencti.log(&#34;info&#34;, &#34;Creating Opinion {&#34; + name + &#34;}.&#34;)
            query = (
                &#34;&#34;&#34;
                mutation OpinionAdd($input: OpinionAddInput) {
                    opinionAdd(input: $input) {
                        &#34;&#34;&#34;
                + self.properties
                + &#34;&#34;&#34;
                    }
                }
            &#34;&#34;&#34;
            )
            result = self.opencti.query(
                query,
                {
                    &#34;input&#34;: {
                        &#34;name&#34;: name,
                        &#34;description&#34;: description,
                        &#34;explanation&#34;: explanation,
                        &#34;graph_data&#34;: graph_data,
                        &#34;internal_id_key&#34;: id,
                        &#34;stix_id_key&#34;: stix_id_key,
                        &#34;created&#34;: created,
                        &#34;modified&#34;: modified,
                        &#34;createdByRef&#34;: created_by_ref,
                        &#34;markingDefinitions&#34;: marking_definitions,
                    }
                },
            )
            return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;opinionAdd&#34;])
        else:
            self.opencti.log(
                &#34;error&#34;,
                &#34;[opencti_opinion] Missing parameters: name and description and explanation&#34;,
            )

    &#34;&#34;&#34;
         Create a Opinion object only if it not exists, update it on request

         :param name: the name of the Opinion
         :param description: the description of the Opinion
         :param published: the publication date of the Opinion
         :return Opinion object
     &#34;&#34;&#34;

    def create(self, **kwargs):
        name = kwargs.get(&#34;name&#34;, None)
        external_reference_id = kwargs.get(&#34;external_reference_id&#34;, None)
        description = kwargs.get(&#34;description&#34;, None)
        explanation = kwargs.get(&#34;explanation&#34;, None)
        graph_data = kwargs.get(&#34;graph_data&#34;, None)
        id = kwargs.get(&#34;id&#34;, None)
        stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
        created = kwargs.get(&#34;created&#34;, None)
        modified = kwargs.get(&#34;modified&#34;, None)
        created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
        marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)
        update = kwargs.get(&#34;update&#34;, False)
        custom_attributes = &#34;&#34;&#34;
            id
            entity_type
            name
            description 
            ... on Opinion {
                observableRefs {
                    edges {
                        node {
                            id
                            entity_type
                            stix_id_key
                            observable_value
                        }
                        relation {
                            id
                        }
                    }
                }
            }
        &#34;&#34;&#34;
        object_result = None
        if external_reference_id is not None:
            object_result = self.opencti.stix_domain_entity.read(
                types=[&#34;Opinion&#34;],
                filters=[
                    {&#34;key&#34;: &#34;hasExternalReference&#34;, &#34;values&#34;: [external_reference_id]}
                ],
                customAttributes=custom_attributes,
            )
        if (
            object_result is None
            and description is not None
            and explanation is not None
        ):
            object_result = self.get_by_stix_id_or_name(
                stix_id_key=stix_id_key,
                description=description,
                explanation=explanation,
                custom_attributes=custom_attributes,
            )
        if object_result is not None:
            if update:
                if object_result[&#34;name&#34;] != name:
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;name&#34;, value=name
                    )
                    object_result[&#34;name&#34;] = name
                if object_result[&#34;description&#34;] != description:
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;description&#34;, value=description
                    )
                    object_result[&#34;description&#34;] = description
                if object_result[&#34;explanation&#34;] != explanation:
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;explanation&#34;, value=explanation
                    )
                    object_result[&#34;explanation&#34;] = explanation
            if external_reference_id is not None:
                self.opencti.stix_entity.add_external_reference(
                    id=object_result[&#34;id&#34;],
                    entity=object_result,
                    external_reference_id=external_reference_id,
                )
            return object_result
        else:
            opinion = self.create_raw(
                name=name,
                description=description,
                explanation=explanation,
                graph_data=graph_data,
                id=id,
                stix_id_key=stix_id_key,
                created=created,
                modified=modified,
                createdByRef=created_by_ref,
                markingDefinitions=marking_definitions,
            )
            if external_reference_id is not None:
                self.opencti.stix_entity.add_external_reference(
                    id=opinion[&#34;id&#34;],
                    entity=opinion,
                    external_reference_id=external_reference_id,
                )
            return opinion

    &#34;&#34;&#34;
        Add a Stix-Entity object to Opinion object (object_refs)

        :param id: the id of the Opinion
        :param entity_id: the id of the Stix-Entity
        :return Boolean
    &#34;&#34;&#34;

    def add_stix_entity(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        opinion = kwargs.get(&#34;opinion&#34;, None)
        entity_id = kwargs.get(&#34;entity_id&#34;, None)
        if id is not None and entity_id is not None:
            if opinion is not None:
                if (
                    entity_id in opinion[&#34;objectRefsIds&#34;]
                    or entity_id in opinion[&#34;relationRefsIds&#34;]
                ):
                    return True
            else:
                if self.contains_stix_entity(id=id, entity_id=entity_id):
                    return True
            self.opencti.log(
                &#34;info&#34;,
                &#34;Adding Stix-Entity {&#34; + entity_id + &#34;} to Opinion {&#34; + id + &#34;}&#34;,
            )
            query = &#34;&#34;&#34;
               mutation OpinionEdit($id: ID!, $input: RelationAddInput) {
                   opinionEdit(id: $id) {
                        relationAdd(input: $input) {
                            id
                        }
                   }
               }
            &#34;&#34;&#34;
            self.opencti.query(
                query,
                {
                    &#34;id&#34;: id,
                    &#34;input&#34;: {
                        &#34;fromRole&#34;: &#34;knowledge_aggregation&#34;,
                        &#34;toId&#34;: entity_id,
                        &#34;toRole&#34;: &#34;so&#34;,
                        &#34;through&#34;: &#34;object_refs&#34;,
                    },
                },
            )
            return True
        else:
            self.opencti.log(
                &#34;error&#34;, &#34;[opencti_opinion] Missing parameters: id and entity_id&#34;
            )
            return False

    &#34;&#34;&#34;
        Add a Stix-Observable object to Opinion object (observable_refs)

        :param id: the id of the Opinion
        :param entity_id: the id of the Stix-Observable
        :return Boolean
    &#34;&#34;&#34;

    def add_stix_observable(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        opinion = kwargs.get(&#34;opinion&#34;, None)
        stix_observable_id = kwargs.get(&#34;stix_observable_id&#34;, None)
        if id is not None and stix_observable_id is not None:
            if opinion is not None:
                if stix_observable_id in opinion[&#34;observableRefsIds&#34;]:
                    return True
            else:
                if self.contains_stix_observable(
                    id=id, stix_observable_id=stix_observable_id
                ):
                    return True
            self.opencti.log(
                &#34;info&#34;,
                &#34;Adding Stix-Observable {&#34;
                + stix_observable_id
                + &#34;} to Opinion {&#34;
                + id
                + &#34;}&#34;,
            )
            query = &#34;&#34;&#34;
               mutation OpinionEdit($id: ID!, $input: RelationAddInput) {
                   opinionEdit(id: $id) {
                        relationAdd(input: $input) {
                            id
                        }
                   }
               }
            &#34;&#34;&#34;
            self.opencti.query(
                query,
                {
                    &#34;id&#34;: id,
                    &#34;input&#34;: {
                        &#34;fromRole&#34;: &#34;observables_aggregation&#34;,
                        &#34;toId&#34;: stix_observable_id,
                        &#34;toRole&#34;: &#34;soo&#34;,
                        &#34;through&#34;: &#34;observable_refs&#34;,
                    },
                },
            )
            return True
        else:
            self.opencti.log(
                &#34;error&#34;,
                &#34;[opencti_opinion] Missing parameters: id and stix_observable_id&#34;,
            )
            return False

    &#34;&#34;&#34;
        Import a Opinion object from a STIX2 object

        :param stixObject: the Stix-Object Opinion
        :return Opinion object
    &#34;&#34;&#34;

    def import_from_stix2(self, **kwargs):
        stix_object = kwargs.get(&#34;stixObject&#34;, None)
        extras = kwargs.get(&#34;extras&#34;, {})
        update = kwargs.get(&#34;update&#34;, False)
        if stix_object is not None:
            return self.create(
                explanation=self.opencti.stix2.convert_markdown(
                    stix_object[&#34;explanation&#34;]
                )
                if &#34;explanation&#34; in stix_object
                else &#34;&#34;,
                description=self.opencti.stix2.convert_markdown(stix_object[&#34;opinion&#34;])
                if &#34;opinion&#34; in stix_object
                else &#34;&#34;,
                name=stix_object[CustomProperties.NAME]
                if CustomProperties.NAME in stix_object
                else &#34;&#34;,
                graph_data=stix_object[CustomProperties.GRAPH_DATA]
                if CustomProperties.GRAPH_DATA in stix_object
                else &#34;&#34;,
                id=stix_object[CustomProperties.ID]
                if CustomProperties.ID in stix_object
                else None,
                stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
                created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
                modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
                createdByRef=extras[&#34;created_by_ref_id&#34;]
                if &#34;created_by_ref_id&#34; in extras
                else None,
                markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
                if &#34;marking_definitions_ids&#34; in extras
                else [],
                update=update,
            )
        else:
            self.opencti.log(
                &#34;error&#34;, &#34;[opencti_attack_pattern] Missing parameters: stixObject&#34;
            )

    &#34;&#34;&#34;
        Export a Opinion object in STIX2

        :param id: the id of the Opinion
        :return Opinion object
    &#34;&#34;&#34;

    def to_stix2(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        mode = kwargs.get(&#34;mode&#34;, &#34;simple&#34;)
        max_marking_definition_entity = kwargs.get(
            &#34;max_marking_definition_entity&#34;, None
        )
        entity = kwargs.get(&#34;entity&#34;, None)
        if id is not None and entity is None:
            entity = self.read(id=id)
        if entity is not None:
            opinion = dict()
            opinion[&#34;id&#34;] = entity[&#34;stix_id_key&#34;]
            opinion[&#34;type&#34;] = &#34;opinion&#34;
            opinion[&#34;spec_version&#34;] = SPEC_VERSION
            opinion[&#34;explanation&#34;] = entity[&#34;explanation&#34;]
            opinion[&#34;opinion&#34;] = entity[&#34;description&#34;]
            if self.opencti.not_empty(entity[&#34;stix_label&#34;]):
                opinion[&#34;labels&#34;] = entity[&#34;stix_label&#34;]
            else:
                opinion[&#34;labels&#34;] = [&#34;opinion&#34;]
            if self.opencti.not_empty(entity[&#34;description&#34;]):
                opinion[&#34;abstract&#34;] = entity[&#34;description&#34;]
            opinion[&#34;created&#34;] = self.opencti.stix2.format_date(entity[&#34;created&#34;])
            opinion[&#34;modified&#34;] = self.opencti.stix2.format_date(entity[&#34;modified&#34;])
            if self.opencti.not_empty(entity[&#34;alias&#34;]):
                opinion[CustomProperties.ALIASES] = entity[&#34;alias&#34;]
            if self.opencti.not_empty(entity[&#34;name&#34;]):
                opinion[CustomProperties.NAME] = entity[&#34;name&#34;]
            if self.opencti.not_empty(entity[&#34;graph_data&#34;]):
                opinion[CustomProperties.GRAPH_DATA] = entity[&#34;graph_data&#34;]
            opinion[CustomProperties.ID] = entity[&#34;id&#34;]
            return self.opencti.stix2.prepare_export(
                entity, opinion, mode, max_marking_definition_entity
            )
        else:
            self.opencti.log(
                &#34;error&#34;, &#34;[opencti_opinion] Missing parameters: id or entity&#34;
            )</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pycti.Opinion.add_stix_entity"><code class="name flex">
<span>def <span class="ident">add_stix_entity</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_stix_entity(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    opinion = kwargs.get(&#34;opinion&#34;, None)
    entity_id = kwargs.get(&#34;entity_id&#34;, None)
    if id is not None and entity_id is not None:
        if opinion is not None:
            if (
                entity_id in opinion[&#34;objectRefsIds&#34;]
                or entity_id in opinion[&#34;relationRefsIds&#34;]
            ):
                return True
        else:
            if self.contains_stix_entity(id=id, entity_id=entity_id):
                return True
        self.opencti.log(
            &#34;info&#34;,
            &#34;Adding Stix-Entity {&#34; + entity_id + &#34;} to Opinion {&#34; + id + &#34;}&#34;,
        )
        query = &#34;&#34;&#34;
           mutation OpinionEdit($id: ID!, $input: RelationAddInput) {
               opinionEdit(id: $id) {
                    relationAdd(input: $input) {
                        id
                    }
               }
           }
        &#34;&#34;&#34;
        self.opencti.query(
            query,
            {
                &#34;id&#34;: id,
                &#34;input&#34;: {
                    &#34;fromRole&#34;: &#34;knowledge_aggregation&#34;,
                    &#34;toId&#34;: entity_id,
                    &#34;toRole&#34;: &#34;so&#34;,
                    &#34;through&#34;: &#34;object_refs&#34;,
                },
            },
        )
        return True
    else:
        self.opencti.log(
            &#34;error&#34;, &#34;[opencti_opinion] Missing parameters: id and entity_id&#34;
        )
        return False</code></pre>
</details>
</dd>
<dt id="pycti.Opinion.add_stix_observable"><code class="name flex">
<span>def <span class="ident">add_stix_observable</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_stix_observable(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    opinion = kwargs.get(&#34;opinion&#34;, None)
    stix_observable_id = kwargs.get(&#34;stix_observable_id&#34;, None)
    if id is not None and stix_observable_id is not None:
        if opinion is not None:
            if stix_observable_id in opinion[&#34;observableRefsIds&#34;]:
                return True
        else:
            if self.contains_stix_observable(
                id=id, stix_observable_id=stix_observable_id
            ):
                return True
        self.opencti.log(
            &#34;info&#34;,
            &#34;Adding Stix-Observable {&#34;
            + stix_observable_id
            + &#34;} to Opinion {&#34;
            + id
            + &#34;}&#34;,
        )
        query = &#34;&#34;&#34;
           mutation OpinionEdit($id: ID!, $input: RelationAddInput) {
               opinionEdit(id: $id) {
                    relationAdd(input: $input) {
                        id
                    }
               }
           }
        &#34;&#34;&#34;
        self.opencti.query(
            query,
            {
                &#34;id&#34;: id,
                &#34;input&#34;: {
                    &#34;fromRole&#34;: &#34;observables_aggregation&#34;,
                    &#34;toId&#34;: stix_observable_id,
                    &#34;toRole&#34;: &#34;soo&#34;,
                    &#34;through&#34;: &#34;observable_refs&#34;,
                },
            },
        )
        return True
    else:
        self.opencti.log(
            &#34;error&#34;,
            &#34;[opencti_opinion] Missing parameters: id and stix_observable_id&#34;,
        )
        return False</code></pre>
</details>
</dd>
<dt id="pycti.Opinion.contains_stix_entity"><code class="name flex">
<span>def <span class="ident">contains_stix_entity</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def contains_stix_entity(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    entity_id = kwargs.get(&#34;entity_id&#34;, None)
    if id is not None and entity_id is not None:
        self.opencti.log(
            &#34;info&#34;,
            &#34;Checking Stix-Entity {&#34; + entity_id + &#34;} in Opinion {&#34; + id + &#34;}&#34;,
        )
        query = &#34;&#34;&#34;
            query OpinionContainsStixDomainEntity($id: String!, $objectId: String!) {
                opinionContainsStixDomainEntity(id: $id, objectId: $objectId)
            }
        &#34;&#34;&#34;
        result = self.opencti.query(query, {&#34;id&#34;: id, &#34;objectId&#34;: entity_id})
        if result[&#34;data&#34;][&#34;opinionContainsStixDomainEntity&#34;]:
            return True
        query = &#34;&#34;&#34;
            query OpinionContainsStixRelation($id: String!, $objectId: String!) {
                opinionContainsStixRelation(id: $id, objectId: $objectId)
            }
        &#34;&#34;&#34;
        result = self.opencti.query(query, {&#34;id&#34;: id, &#34;objectId&#34;: entity_id})
        return result[&#34;data&#34;][&#34;opinionContainsStixRelation&#34;]
    else:
        self.opencti.log(
            &#34;error&#34;, &#34;[opencti_opinion] Missing parameters: id or entity_id&#34;,
        )</code></pre>
</details>
</dd>
<dt id="pycti.Opinion.contains_stix_observable"><code class="name flex">
<span>def <span class="ident">contains_stix_observable</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def contains_stix_observable(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    stix_observable_id = kwargs.get(&#34;stix_observable_id&#34;, None)
    if id is not None and stix_observable_id is not None:
        self.opencti.log(
            &#34;info&#34;,
            &#34;Checking Stix-Observable {&#34;
            + stix_observable_id
            + &#34;} in Opinion {&#34;
            + id
            + &#34;}&#34;,
        )
        query = &#34;&#34;&#34;
            query OpinionContainsStixObservable($id: String!, $objectId: String!) {
                opinionContainsStixObservable(id: $id, objectId: $objectId)
            }
        &#34;&#34;&#34;
        result = self.opencti.query(
            query, {&#34;id&#34;: id, &#34;objectId&#34;: stix_observable_id}
        )
        return result[&#34;data&#34;][&#34;opinionContainsStixObservable&#34;]
    else:
        self.opencti.log(
            &#34;error&#34;,
            &#34;[opencti_opinion] Missing parameters: id or stix_observable_id&#34;,
        )</code></pre>
</details>
</dd>
<dt id="pycti.Opinion.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create(self, **kwargs):
    name = kwargs.get(&#34;name&#34;, None)
    external_reference_id = kwargs.get(&#34;external_reference_id&#34;, None)
    description = kwargs.get(&#34;description&#34;, None)
    explanation = kwargs.get(&#34;explanation&#34;, None)
    graph_data = kwargs.get(&#34;graph_data&#34;, None)
    id = kwargs.get(&#34;id&#34;, None)
    stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
    created = kwargs.get(&#34;created&#34;, None)
    modified = kwargs.get(&#34;modified&#34;, None)
    created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
    marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)
    update = kwargs.get(&#34;update&#34;, False)
    custom_attributes = &#34;&#34;&#34;
        id
        entity_type
        name
        description 
        ... on Opinion {
            observableRefs {
                edges {
                    node {
                        id
                        entity_type
                        stix_id_key
                        observable_value
                    }
                    relation {
                        id
                    }
                }
            }
        }
    &#34;&#34;&#34;
    object_result = None
    if external_reference_id is not None:
        object_result = self.opencti.stix_domain_entity.read(
            types=[&#34;Opinion&#34;],
            filters=[
                {&#34;key&#34;: &#34;hasExternalReference&#34;, &#34;values&#34;: [external_reference_id]}
            ],
            customAttributes=custom_attributes,
        )
    if (
        object_result is None
        and description is not None
        and explanation is not None
    ):
        object_result = self.get_by_stix_id_or_name(
            stix_id_key=stix_id_key,
            description=description,
            explanation=explanation,
            custom_attributes=custom_attributes,
        )
    if object_result is not None:
        if update:
            if object_result[&#34;name&#34;] != name:
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;name&#34;, value=name
                )
                object_result[&#34;name&#34;] = name
            if object_result[&#34;description&#34;] != description:
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;description&#34;, value=description
                )
                object_result[&#34;description&#34;] = description
            if object_result[&#34;explanation&#34;] != explanation:
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;explanation&#34;, value=explanation
                )
                object_result[&#34;explanation&#34;] = explanation
        if external_reference_id is not None:
            self.opencti.stix_entity.add_external_reference(
                id=object_result[&#34;id&#34;],
                entity=object_result,
                external_reference_id=external_reference_id,
            )
        return object_result
    else:
        opinion = self.create_raw(
            name=name,
            description=description,
            explanation=explanation,
            graph_data=graph_data,
            id=id,
            stix_id_key=stix_id_key,
            created=created,
            modified=modified,
            createdByRef=created_by_ref,
            markingDefinitions=marking_definitions,
        )
        if external_reference_id is not None:
            self.opencti.stix_entity.add_external_reference(
                id=opinion[&#34;id&#34;],
                entity=opinion,
                external_reference_id=external_reference_id,
            )
        return opinion</code></pre>
</details>
</dd>
<dt id="pycti.Opinion.create_raw"><code class="name flex">
<span>def <span class="ident">create_raw</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_raw(self, **kwargs):
    name = kwargs.get(&#34;name&#34;, None)
    description = kwargs.get(&#34;description&#34;, None)
    explanation = kwargs.get(&#34;explanation&#34;, None)
    graph_data = kwargs.get(&#34;graph_data&#34;, None)
    id = kwargs.get(&#34;id&#34;, None)
    stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
    created = kwargs.get(&#34;created&#34;, None)
    modified = kwargs.get(&#34;modified&#34;, None)
    created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
    marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)

    if name is not None and description is not None and explanation is not None:
        self.opencti.log(&#34;info&#34;, &#34;Creating Opinion {&#34; + name + &#34;}.&#34;)
        query = (
            &#34;&#34;&#34;
            mutation OpinionAdd($input: OpinionAddInput) {
                opinionAdd(input: $input) {
                    &#34;&#34;&#34;
            + self.properties
            + &#34;&#34;&#34;
                }
            }
        &#34;&#34;&#34;
        )
        result = self.opencti.query(
            query,
            {
                &#34;input&#34;: {
                    &#34;name&#34;: name,
                    &#34;description&#34;: description,
                    &#34;explanation&#34;: explanation,
                    &#34;graph_data&#34;: graph_data,
                    &#34;internal_id_key&#34;: id,
                    &#34;stix_id_key&#34;: stix_id_key,
                    &#34;created&#34;: created,
                    &#34;modified&#34;: modified,
                    &#34;createdByRef&#34;: created_by_ref,
                    &#34;markingDefinitions&#34;: marking_definitions,
                }
            },
        )
        return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;opinionAdd&#34;])
    else:
        self.opencti.log(
            &#34;error&#34;,
            &#34;[opencti_opinion] Missing parameters: name and description and explanation&#34;,
        )</code></pre>
</details>
</dd>
<dt id="pycti.Opinion.get_by_stix_id_or_name"><code class="name flex">
<span>def <span class="ident">get_by_stix_id_or_name</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_by_stix_id_or_name(self, **kwargs):
    stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
    description = kwargs.get(&#34;description&#34;, None)
    explanation = kwargs.get(&#34;explanation&#34;, None)
    custom_attributes = kwargs.get(explanation, None)
    object_result = None
    if stix_id_key is not None:
        object_result = self.read(
            id=stix_id_key, customAttributes=custom_attributes
        )
    if (
        object_result is None
        and description is not None
        and explanation is not None
    ):
        object_result = self.read(
            filters=[
                {&#34;key&#34;: &#34;description&#34;, &#34;values&#34;: [description]},
                {&#34;key&#34;: &#34;explanation&#34;, &#34;values&#34;: [explanation]},
            ],
            customAttributes=custom_attributes,
        )
    return object_result</code></pre>
</details>
</dd>
<dt id="pycti.Opinion.import_from_stix2"><code class="name flex">
<span>def <span class="ident">import_from_stix2</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def import_from_stix2(self, **kwargs):
    stix_object = kwargs.get(&#34;stixObject&#34;, None)
    extras = kwargs.get(&#34;extras&#34;, {})
    update = kwargs.get(&#34;update&#34;, False)
    if stix_object is not None:
        return self.create(
            explanation=self.opencti.stix2.convert_markdown(
                stix_object[&#34;explanation&#34;]
            )
            if &#34;explanation&#34; in stix_object
            else &#34;&#34;,
            description=self.opencti.stix2.convert_markdown(stix_object[&#34;opinion&#34;])
            if &#34;opinion&#34; in stix_object
            else &#34;&#34;,
            name=stix_object[CustomProperties.NAME]
            if CustomProperties.NAME in stix_object
            else &#34;&#34;,
            graph_data=stix_object[CustomProperties.GRAPH_DATA]
            if CustomProperties.GRAPH_DATA in stix_object
            else &#34;&#34;,
            id=stix_object[CustomProperties.ID]
            if CustomProperties.ID in stix_object
            else None,
            stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
            created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
            modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
            createdByRef=extras[&#34;created_by_ref_id&#34;]
            if &#34;created_by_ref_id&#34; in extras
            else None,
            markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
            if &#34;marking_definitions_ids&#34; in extras
            else [],
            update=update,
        )
    else:
        self.opencti.log(
            &#34;error&#34;, &#34;[opencti_attack_pattern] Missing parameters: stixObject&#34;
        )</code></pre>
</details>
</dd>
<dt id="pycti.Opinion.list"><code class="name flex">
<span>def <span class="ident">list</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list(self, **kwargs):
    filters = kwargs.get(&#34;filters&#34;, None)
    search = kwargs.get(&#34;search&#34;, None)
    first = kwargs.get(&#34;first&#34;, 500)
    after = kwargs.get(&#34;after&#34;, None)
    order_by = kwargs.get(&#34;orderBy&#34;, None)
    order_mode = kwargs.get(&#34;orderMode&#34;, None)
    get_all = kwargs.get(&#34;getAll&#34;, False)
    if get_all:
        first = 500

    self.opencti.log(
        &#34;info&#34;, &#34;Listing Opinions with filters &#34; + json.dumps(filters) + &#34;.&#34;
    )
    query = (
        &#34;&#34;&#34;
        query Opinions($filters: [OpinionsFiltering], $search: String, $first: Int, $after: ID, $orderBy: OpinionsOrdering, $orderMode: OrderingMode) {
            opinions(filters: $filters, search: $search, first: $first, after: $after, orderBy: $orderBy, orderMode: $orderMode) {
                edges {
                    node {
                        &#34;&#34;&#34;
        + self.properties
        + &#34;&#34;&#34;
                    }
                }
                pageInfo {
                    startCursor
                    endCursor
                    hasNextPage
                    hasPreviousPage
                    globalCount
                }                    
            }
        }
    &#34;&#34;&#34;
    )
    result = self.opencti.query(
        query,
        {
            &#34;filters&#34;: filters,
            &#34;search&#34;: search,
            &#34;first&#34;: first,
            &#34;after&#34;: after,
            &#34;orderBy&#34;: order_by,
            &#34;orderMode&#34;: order_mode,
        },
    )
    return self.opencti.process_multiple(result[&#34;data&#34;][&#34;opinions&#34;])</code></pre>
</details>
</dd>
<dt id="pycti.Opinion.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    filters = kwargs.get(&#34;filters&#34;, None)
    custom_attributes = kwargs.get(&#34;customAttributes&#34;, None)
    if id is not None:
        self.opencti.log(&#34;info&#34;, &#34;Reading Opinion {&#34; + id + &#34;}.&#34;)
        query = (
            &#34;&#34;&#34;
            query Opinion($id: String!) {
                opinion(id: $id) {
                    &#34;&#34;&#34;
            + (
                custom_attributes
                if custom_attributes is not None
                else self.properties
            )
            + &#34;&#34;&#34;
                }
            }
        &#34;&#34;&#34;
        )
        result = self.opencti.query(query, {&#34;id&#34;: id})
        return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;opinion&#34;])
    elif filters is not None:
        result = self.list(filters=filters)
        if len(result) &gt; 0:
            return result[0]
        else:
            return None</code></pre>
</details>
</dd>
<dt id="pycti.Opinion.to_stix2"><code class="name flex">
<span>def <span class="ident">to_stix2</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_stix2(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    mode = kwargs.get(&#34;mode&#34;, &#34;simple&#34;)
    max_marking_definition_entity = kwargs.get(
        &#34;max_marking_definition_entity&#34;, None
    )
    entity = kwargs.get(&#34;entity&#34;, None)
    if id is not None and entity is None:
        entity = self.read(id=id)
    if entity is not None:
        opinion = dict()
        opinion[&#34;id&#34;] = entity[&#34;stix_id_key&#34;]
        opinion[&#34;type&#34;] = &#34;opinion&#34;
        opinion[&#34;spec_version&#34;] = SPEC_VERSION
        opinion[&#34;explanation&#34;] = entity[&#34;explanation&#34;]
        opinion[&#34;opinion&#34;] = entity[&#34;description&#34;]
        if self.opencti.not_empty(entity[&#34;stix_label&#34;]):
            opinion[&#34;labels&#34;] = entity[&#34;stix_label&#34;]
        else:
            opinion[&#34;labels&#34;] = [&#34;opinion&#34;]
        if self.opencti.not_empty(entity[&#34;description&#34;]):
            opinion[&#34;abstract&#34;] = entity[&#34;description&#34;]
        opinion[&#34;created&#34;] = self.opencti.stix2.format_date(entity[&#34;created&#34;])
        opinion[&#34;modified&#34;] = self.opencti.stix2.format_date(entity[&#34;modified&#34;])
        if self.opencti.not_empty(entity[&#34;alias&#34;]):
            opinion[CustomProperties.ALIASES] = entity[&#34;alias&#34;]
        if self.opencti.not_empty(entity[&#34;name&#34;]):
            opinion[CustomProperties.NAME] = entity[&#34;name&#34;]
        if self.opencti.not_empty(entity[&#34;graph_data&#34;]):
            opinion[CustomProperties.GRAPH_DATA] = entity[&#34;graph_data&#34;]
        opinion[CustomProperties.ID] = entity[&#34;id&#34;]
        return self.opencti.stix2.prepare_export(
            entity, opinion, mode, max_marking_definition_entity
        )
    else:
        self.opencti.log(
            &#34;error&#34;, &#34;[opencti_opinion] Missing parameters: id or entity&#34;
        )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pycti.Report"><code class="flex name class">
<span>class <span class="ident">Report</span></span>
<span>(</span><span>opencti)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Report:
    def __init__(self, opencti):
        self.opencti = opencti
        self.properties = &#34;&#34;&#34;
            id
            stix_id_key
            entity_type
            stix_label
            name
            alias
            description
            report_class
            published
            object_status
            source_confidence_level
            graph_data
            created
            modified
            created_at
            updated_at
            createdByRef {
                node {
                    id
                    entity_type
                    stix_id_key
                    stix_label
                    name
                    alias
                    description
                    created
                    modified
                    ... on Organization {
                        organization_class
                    }
                }
                relation {
                    id
                }
            }
            markingDefinitions {
                edges {
                    node {
                        id
                        entity_type
                        stix_id_key
                        definition_type
                        definition
                        level
                        color
                        created
                        modified
                    }
                    relation {
                        id
                    }
                }
            }
            tags {
                edges {
                    node {
                        id
                        tag_type
                        value
                        color
                    }
                    relation {
                        id
                    }
                }
            }            
            externalReferences {
                edges {
                    node {
                        id
                        entity_type
                        stix_id_key
                        source_name
                        description
                        url
                        hash
                        external_id
                        created
                        modified
                    }
                    relation {
                        id
                    }
                }
            }
            objectRefs {
                edges {
                    node {
                        id
                        stix_id_key
                        entity_type
                    }
                }
            }
            observableRefs {
                edges {
                    node {
                        id
                        stix_id_key
                        entity_type
                        observable_value
                    }
                }
            }
            relationRefs {
                edges {
                    node {
                        id
                        stix_id_key
                    }
                }
            }
        &#34;&#34;&#34;

    &#34;&#34;&#34;
        List Report objects

        :param filters: the filters to apply
        :param search: the search keyword
        :param first: return the first n rows from the after ID (or the beginning if not set)
        :param after: ID of the first row for pagination
        :return List of Report objects
    &#34;&#34;&#34;

    def list(self, **kwargs):
        filters = kwargs.get(&#34;filters&#34;, None)
        search = kwargs.get(&#34;search&#34;, None)
        first = kwargs.get(&#34;first&#34;, 500)
        after = kwargs.get(&#34;after&#34;, None)
        order_by = kwargs.get(&#34;orderBy&#34;, None)
        order_mode = kwargs.get(&#34;orderMode&#34;, None)
        get_all = kwargs.get(&#34;getAll&#34;, False)
        if get_all:
            first = 500

        self.opencti.log(
            &#34;info&#34;, &#34;Listing Reports with filters &#34; + json.dumps(filters) + &#34;.&#34;
        )
        query = (
            &#34;&#34;&#34;
            query Reports($filters: [ReportsFiltering], $search: String, $first: Int, $after: ID, $orderBy: ReportsOrdering, $orderMode: OrderingMode) {
                reports(filters: $filters, search: $search, first: $first, after: $after, orderBy: $orderBy, orderMode: $orderMode) {
                    edges {
                        node {
                            &#34;&#34;&#34;
            + self.properties
            + &#34;&#34;&#34;
                        }
                    }
                    pageInfo {
                        startCursor
                        endCursor
                        hasNextPage
                        hasPreviousPage
                        globalCount
                    }                    
                }
            }
        &#34;&#34;&#34;
        )
        result = self.opencti.query(
            query,
            {
                &#34;filters&#34;: filters,
                &#34;search&#34;: search,
                &#34;first&#34;: first,
                &#34;after&#34;: after,
                &#34;orderBy&#34;: order_by,
                &#34;orderMode&#34;: order_mode,
            },
        )
        return self.opencti.process_multiple(result[&#34;data&#34;][&#34;reports&#34;])

    &#34;&#34;&#34;
        Read a Report object

        :param id: the id of the Report
        :param filters: the filters to apply if no id provided
        :return Report object
    &#34;&#34;&#34;

    def read(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        filters = kwargs.get(&#34;filters&#34;, None)
        custom_attributes = kwargs.get(&#34;customAttributes&#34;, None)
        if id is not None:
            self.opencti.log(&#34;info&#34;, &#34;Reading Report {&#34; + id + &#34;}.&#34;)
            query = (
                &#34;&#34;&#34;
                query Report($id: String!) {
                    report(id: $id) {
                        &#34;&#34;&#34;
                + (
                    custom_attributes
                    if custom_attributes is not None
                    else self.properties
                )
                + &#34;&#34;&#34;
                    }
                }
            &#34;&#34;&#34;
            )
            result = self.opencti.query(query, {&#34;id&#34;: id})
            return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;report&#34;])
        elif filters is not None:
            result = self.list(filters=filters)
            if len(result) &gt; 0:
                return result[0]
            else:
                return None

    &#34;&#34;&#34;
        Read a Report object by stix_id or name

        :param type: the Stix-Domain-Entity type
        :param stix_id_key: the STIX ID of the Stix-Domain-Entity
        :param name: the name of the Stix-Domain-Entity
        :return Stix-Domain-Entity object
    &#34;&#34;&#34;

    def get_by_stix_id_or_name(self, **kwargs):
        stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
        name = kwargs.get(&#34;name&#34;, None)
        published = kwargs.get(&#34;published&#34;, None)
        custom_attributes = kwargs.get(&#34;customAttributes&#34;, None)
        object_result = None
        if stix_id_key is not None:
            object_result = self.read(
                id=stix_id_key, customAttributes=custom_attributes
            )
        if object_result is None and name is not None and published is not None:
            published_final = parse(published).strftime(&#34;%Y-%m-%d&#34;)
            object_result = self.read(
                filters=[
                    {&#34;key&#34;: &#34;name&#34;, &#34;values&#34;: [name]},
                    {&#34;key&#34;: &#34;published_day&#34;, &#34;values&#34;: [published_final]},
                ],
                customAttributes=custom_attributes,
            )
        return object_result

    &#34;&#34;&#34;
        Check if a report already contains a STIX entity
        
        :return Boolean
    &#34;&#34;&#34;

    def contains_stix_entity(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        entity_id = kwargs.get(&#34;entity_id&#34;, None)
        if id is not None and entity_id is not None:
            self.opencti.log(
                &#34;info&#34;,
                &#34;Checking Stix-Entity {&#34; + entity_id + &#34;} in Report {&#34; + id + &#34;}&#34;,
            )
            query = &#34;&#34;&#34;
                query ReportContainsStixDomainEntity($id: String!, $objectId: String!) {
                    reportContainsStixDomainEntity(id: $id, objectId: $objectId)
                }
            &#34;&#34;&#34;
            result = self.opencti.query(query, {&#34;id&#34;: id, &#34;objectId&#34;: entity_id})
            if result[&#34;data&#34;][&#34;reportContainsStixDomainEntity&#34;]:
                return True
            query = &#34;&#34;&#34;
                query ReportContainsStixRelation($id: String!, $objectId: String!) {
                    reportContainsStixRelation(id: $id, objectId: $objectId)
                }
            &#34;&#34;&#34;
            result = self.opencti.query(query, {&#34;id&#34;: id, &#34;objectId&#34;: entity_id})
            return result[&#34;data&#34;][&#34;reportContainsStixRelation&#34;]
        else:
            self.opencti.log(
                &#34;error&#34;, &#34;[opencti_report] Missing parameters: id or entity_id&#34;,
            )

    &#34;&#34;&#34;
        Check if a report already contains a STIX observable

        :return Boolean
    &#34;&#34;&#34;

    def contains_stix_observable(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        stix_observable_id = kwargs.get(&#34;stix_observable_id&#34;, None)
        if id is not None and stix_observable_id is not None:
            self.opencti.log(
                &#34;info&#34;,
                &#34;Checking Stix-Observable {&#34;
                + stix_observable_id
                + &#34;} in Report {&#34;
                + id
                + &#34;}&#34;,
            )
            query = &#34;&#34;&#34;
                query ReportContainsStixObservable($id: String!, $objectId: String!) {
                    reportContainsStixObservable(id: $id, objectId: $objectId)
                }
            &#34;&#34;&#34;
            result = self.opencti.query(
                query, {&#34;id&#34;: id, &#34;objectId&#34;: stix_observable_id}
            )
            return result[&#34;data&#34;][&#34;reportContainsStixObservable&#34;]
        else:
            self.opencti.log(
                &#34;error&#34;,
                &#34;[opencti_report] Missing parameters: id or stix_observable_id&#34;,
            )

    &#34;&#34;&#34;
        Create a Report object

        :param name: the name of the Report
        :return Report object
    &#34;&#34;&#34;

    def create_raw(self, **kwargs):
        name = kwargs.get(&#34;name&#34;, None)
        description = kwargs.get(&#34;description&#34;, None)
        published = kwargs.get(&#34;published&#34;, None)
        report_class = kwargs.get(&#34;report_class&#34;, None)
        object_status = kwargs.get(&#34;object_status&#34;, None)
        source_confidence_level = kwargs.get(&#34;source_confidence_level&#34;, None)
        graph_data = kwargs.get(&#34;graph_data&#34;, None)
        id = kwargs.get(&#34;id&#34;, None)
        stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
        created = kwargs.get(&#34;created&#34;, None)
        modified = kwargs.get(&#34;modified&#34;, None)
        created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
        marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)

        if (
            name is not None
            and description is not None
            and published is not None
            and report_class is not None
        ):
            self.opencti.log(&#34;info&#34;, &#34;Creating Report {&#34; + name + &#34;}.&#34;)
            query = (
                &#34;&#34;&#34;
                mutation ReportAdd($input: ReportAddInput) {
                    reportAdd(input: $input) {
                        &#34;&#34;&#34;
                + self.properties
                + &#34;&#34;&#34;
                    }
                }
            &#34;&#34;&#34;
            )
            result = self.opencti.query(
                query,
                {
                    &#34;input&#34;: {
                        &#34;name&#34;: name,
                        &#34;description&#34;: description,
                        &#34;published&#34;: published,
                        &#34;report_class&#34;: report_class,
                        &#34;object_status&#34;: object_status,
                        &#34;source_confidence_level&#34;: source_confidence_level,
                        &#34;graph_data&#34;: graph_data,
                        &#34;internal_id_key&#34;: id,
                        &#34;stix_id_key&#34;: stix_id_key,
                        &#34;created&#34;: created,
                        &#34;modified&#34;: modified,
                        &#34;createdByRef&#34;: created_by_ref,
                        &#34;markingDefinitions&#34;: marking_definitions,
                    }
                },
            )
            return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;reportAdd&#34;])
        else:
            self.opencti.log(
                &#34;error&#34;,
                &#34;[opencti_report] Missing parameters: name and description and published and report_class&#34;,
            )

    &#34;&#34;&#34;
         Create a Report object only if it not exists, update it on request

         :param name: the name of the Report
         :param description: the description of the Report
         :param published: the publication date of the Report
         :return Report object
     &#34;&#34;&#34;

    def create(self, **kwargs):
        name = kwargs.get(&#34;name&#34;, None)
        external_reference_id = kwargs.get(&#34;external_reference_id&#34;, None)
        description = kwargs.get(&#34;description&#34;, None)
        published = kwargs.get(&#34;published&#34;, None)
        report_class = kwargs.get(&#34;report_class&#34;, None)
        object_status = kwargs.get(&#34;object_status&#34;, None)
        source_confidence_level = kwargs.get(&#34;source_confidence_level&#34;, None)
        graph_data = kwargs.get(&#34;graph_data&#34;, None)
        id = kwargs.get(&#34;id&#34;, None)
        stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
        created = kwargs.get(&#34;created&#34;, None)
        modified = kwargs.get(&#34;modified&#34;, None)
        created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
        marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)
        update = kwargs.get(&#34;update&#34;, False)
        custom_attributes = &#34;&#34;&#34;
            id
            entity_type
            name
            description 
            ... on Report {
                observableRefs {
                    edges {
                        node {
                            id
                            entity_type
                            stix_id_key
                            observable_value
                        }
                        relation {
                            id
                        }
                    }
                }
            }
        &#34;&#34;&#34;
        object_result = None
        if external_reference_id is not None:
            object_result = self.opencti.stix_domain_entity.read(
                types=[&#34;Report&#34;],
                filters=[
                    {&#34;key&#34;: &#34;hasExternalReference&#34;, &#34;values&#34;: [external_reference_id]}
                ],
                customAttributes=custom_attributes,
            )
        if object_result is None and name is not None:
            object_result = self.get_by_stix_id_or_name(
                stix_id_key=stix_id_key,
                name=name,
                published=published,
                custom_attributes=custom_attributes,
            )
        if object_result is not None:
            if update:
                if object_result[&#34;name&#34;] != name:
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;name&#34;, value=name
                    )
                    object_result[&#34;name&#34;] = name
                if object_result[&#34;description&#34;] != description:
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;description&#34;, value=description
                    )
                    object_result[&#34;description&#34;] = description
            if external_reference_id is not None:
                self.opencti.stix_entity.add_external_reference(
                    id=object_result[&#34;id&#34;],
                    entity=object_result,
                    external_reference_id=external_reference_id,
                )
            return object_result
        else:
            report = self.create_raw(
                name=name,
                description=description,
                published=published,
                report_class=report_class,
                object_status=object_status,
                source_confidence_level=source_confidence_level,
                graph_data=graph_data,
                id=id,
                stix_id_key=stix_id_key,
                created=created,
                modified=modified,
                createdByRef=created_by_ref,
                markingDefinitions=marking_definitions,
            )
            if external_reference_id is not None:
                self.opencti.stix_entity.add_external_reference(
                    id=report[&#34;id&#34;],
                    entity=report,
                    external_reference_id=external_reference_id,
                )
            return report

    &#34;&#34;&#34;
        Add a Stix-Entity object to Report object (object_refs)

        :param id: the id of the Report
        :param entity_id: the id of the Stix-Entity
        :return Boolean
    &#34;&#34;&#34;

    def add_stix_entity(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        report = kwargs.get(&#34;report&#34;, None)
        entity_id = kwargs.get(&#34;entity_id&#34;, None)
        if id is not None and entity_id is not None:
            if report is not None:
                if (
                    entity_id in report[&#34;objectRefsIds&#34;]
                    or entity_id in report[&#34;relationRefsIds&#34;]
                ):
                    return True
            else:
                if self.contains_stix_entity(id=id, entity_id=entity_id):
                    return True
            self.opencti.log(
                &#34;info&#34;, &#34;Adding Stix-Entity {&#34; + entity_id + &#34;} to Report {&#34; + id + &#34;}&#34;,
            )
            query = &#34;&#34;&#34;
               mutation ReportEdit($id: ID!, $input: RelationAddInput) {
                   reportEdit(id: $id) {
                        relationAdd(input: $input) {
                            id
                        }
                   }
               }
            &#34;&#34;&#34;
            self.opencti.query(
                query,
                {
                    &#34;id&#34;: id,
                    &#34;input&#34;: {
                        &#34;fromRole&#34;: &#34;knowledge_aggregation&#34;,
                        &#34;toId&#34;: entity_id,
                        &#34;toRole&#34;: &#34;so&#34;,
                        &#34;through&#34;: &#34;object_refs&#34;,
                    },
                },
            )
            return True
        else:
            self.opencti.log(
                &#34;error&#34;, &#34;[opencti_report] Missing parameters: id and entity_id&#34;
            )
            return False

    &#34;&#34;&#34;
        Add a Stix-Observable object to Report object (observable_refs)

        :param id: the id of the Report
        :param entity_id: the id of the Stix-Observable
        :return Boolean
    &#34;&#34;&#34;

    def add_stix_observable(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        report = kwargs.get(&#34;report&#34;, None)
        stix_observable_id = kwargs.get(&#34;stix_observable_id&#34;, None)
        if id is not None and stix_observable_id is not None:
            if report is not None:
                if stix_observable_id in report[&#34;observableRefsIds&#34;]:
                    return True
            else:
                if self.contains_stix_observable(
                    id=id, stix_observable_id=stix_observable_id
                ):
                    return True
            self.opencti.log(
                &#34;info&#34;,
                &#34;Adding Stix-Observable {&#34;
                + stix_observable_id
                + &#34;} to Report {&#34;
                + id
                + &#34;}&#34;,
            )
            query = &#34;&#34;&#34;
               mutation ReportEdit($id: ID!, $input: RelationAddInput) {
                   reportEdit(id: $id) {
                        relationAdd(input: $input) {
                            id
                        }
                   }
               }
            &#34;&#34;&#34;
            self.opencti.query(
                query,
                {
                    &#34;id&#34;: id,
                    &#34;input&#34;: {
                        &#34;fromRole&#34;: &#34;observables_aggregation&#34;,
                        &#34;toId&#34;: stix_observable_id,
                        &#34;toRole&#34;: &#34;soo&#34;,
                        &#34;through&#34;: &#34;observable_refs&#34;,
                    },
                },
            )
            return True
        else:
            self.opencti.log(
                &#34;error&#34;,
                &#34;[opencti_report] Missing parameters: id and stix_observable_id&#34;,
            )
            return False

    &#34;&#34;&#34;
        Import a Report object from a STIX2 object

        :param stixObject: the Stix-Object Report
        :return Report object
    &#34;&#34;&#34;

    def import_from_stix2(self, **kwargs):
        stix_object = kwargs.get(&#34;stixObject&#34;, None)
        extras = kwargs.get(&#34;extras&#34;, {})
        update = kwargs.get(&#34;update&#34;, False)
        if stix_object is not None:
            return self.create(
                name=stix_object[&#34;name&#34;],
                description=self.opencti.stix2.convert_markdown(
                    stix_object[&#34;description&#34;]
                )
                if &#34;description&#34; in stix_object
                else &#34;&#34;,
                published=stix_object[&#34;published&#34;]
                if &#34;published&#34; in stix_object
                else &#34;&#34;,
                report_class=stix_object[CustomProperties.REPORT_CLASS]
                if CustomProperties.REPORT_CLASS in stix_object
                else &#34;Threat Report&#34;,
                object_status=stix_object[CustomProperties.OBJECT_STATUS]
                if CustomProperties.OBJECT_STATUS in stix_object
                else 0,
                source_confidence_level=stix_object[CustomProperties.SRC_CONF_LEVEL]
                if CustomProperties.SRC_CONF_LEVEL in stix_object
                else 1,
                graph_data=stix_object[CustomProperties.GRAPH_DATA]
                if CustomProperties.GRAPH_DATA in stix_object
                else &#34;&#34;,
                id=stix_object[CustomProperties.ID]
                if CustomProperties.ID in stix_object
                else None,
                stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
                created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
                modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
                createdByRef=extras[&#34;created_by_ref_id&#34;]
                if &#34;created_by_ref_id&#34; in extras
                else None,
                markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
                if &#34;marking_definitions_ids&#34; in extras
                else [],
                update=update,
            )
        else:
            self.opencti.log(
                &#34;error&#34;, &#34;[opencti_attack_pattern] Missing parameters: stixObject&#34;
            )

    &#34;&#34;&#34;
        Export an Threat-Actor object in STIX2

        :param id: the id of the Threat-Actor
        :return Threat-Actor object
    &#34;&#34;&#34;

    def to_stix2(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        mode = kwargs.get(&#34;mode&#34;, &#34;simple&#34;)
        max_marking_definition_entity = kwargs.get(
            &#34;max_marking_definition_entity&#34;, None
        )
        entity = kwargs.get(&#34;entity&#34;, None)
        if id is not None and entity is None:
            entity = self.read(id=id)
        if entity is not None:
            report = dict()
            report[&#34;id&#34;] = entity[&#34;stix_id_key&#34;]
            report[&#34;type&#34;] = &#34;report&#34;
            report[&#34;spec_version&#34;] = SPEC_VERSION
            report[&#34;name&#34;] = entity[&#34;name&#34;]
            if self.opencti.not_empty(entity[&#34;stix_label&#34;]):
                report[&#34;labels&#34;] = entity[&#34;stix_label&#34;]
            else:
                report[&#34;labels&#34;] = [&#34;report&#34;]
            if self.opencti.not_empty(entity[&#34;description&#34;]):
                report[&#34;description&#34;] = entity[&#34;description&#34;]
            report[&#34;published&#34;] = self.opencti.stix2.format_date(entity[&#34;published&#34;])
            report[&#34;created&#34;] = self.opencti.stix2.format_date(entity[&#34;created&#34;])
            report[&#34;modified&#34;] = self.opencti.stix2.format_date(entity[&#34;modified&#34;])
            if self.opencti.not_empty(entity[&#34;alias&#34;]):
                report[CustomProperties.ALIASES] = entity[&#34;alias&#34;]
            if self.opencti.not_empty(entity[&#34;report_class&#34;]):
                report[CustomProperties.REPORT_CLASS] = entity[&#34;report_class&#34;]
            if self.opencti.not_empty(entity[&#34;object_status&#34;]):
                report[CustomProperties.OBJECT_STATUS] = entity[&#34;object_status&#34;]
            if self.opencti.not_empty(entity[&#34;source_confidence_level&#34;]):
                report[CustomProperties.SRC_CONF_LEVEL] = entity[
                    &#34;source_confidence_level&#34;
                ]
            if self.opencti.not_empty(entity[&#34;graph_data&#34;]):
                report[CustomProperties.GRAPH_DATA] = entity[&#34;graph_data&#34;]
            report[CustomProperties.ID] = entity[&#34;id&#34;]
            return self.opencti.stix2.prepare_export(
                entity, report, mode, max_marking_definition_entity
            )
        else:
            self.opencti.log(
                &#34;error&#34;, &#34;[opencti_report] Missing parameters: id or entity&#34;
            )</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pycti.Report.add_stix_entity"><code class="name flex">
<span>def <span class="ident">add_stix_entity</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_stix_entity(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    report = kwargs.get(&#34;report&#34;, None)
    entity_id = kwargs.get(&#34;entity_id&#34;, None)
    if id is not None and entity_id is not None:
        if report is not None:
            if (
                entity_id in report[&#34;objectRefsIds&#34;]
                or entity_id in report[&#34;relationRefsIds&#34;]
            ):
                return True
        else:
            if self.contains_stix_entity(id=id, entity_id=entity_id):
                return True
        self.opencti.log(
            &#34;info&#34;, &#34;Adding Stix-Entity {&#34; + entity_id + &#34;} to Report {&#34; + id + &#34;}&#34;,
        )
        query = &#34;&#34;&#34;
           mutation ReportEdit($id: ID!, $input: RelationAddInput) {
               reportEdit(id: $id) {
                    relationAdd(input: $input) {
                        id
                    }
               }
           }
        &#34;&#34;&#34;
        self.opencti.query(
            query,
            {
                &#34;id&#34;: id,
                &#34;input&#34;: {
                    &#34;fromRole&#34;: &#34;knowledge_aggregation&#34;,
                    &#34;toId&#34;: entity_id,
                    &#34;toRole&#34;: &#34;so&#34;,
                    &#34;through&#34;: &#34;object_refs&#34;,
                },
            },
        )
        return True
    else:
        self.opencti.log(
            &#34;error&#34;, &#34;[opencti_report] Missing parameters: id and entity_id&#34;
        )
        return False</code></pre>
</details>
</dd>
<dt id="pycti.Report.add_stix_observable"><code class="name flex">
<span>def <span class="ident">add_stix_observable</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_stix_observable(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    report = kwargs.get(&#34;report&#34;, None)
    stix_observable_id = kwargs.get(&#34;stix_observable_id&#34;, None)
    if id is not None and stix_observable_id is not None:
        if report is not None:
            if stix_observable_id in report[&#34;observableRefsIds&#34;]:
                return True
        else:
            if self.contains_stix_observable(
                id=id, stix_observable_id=stix_observable_id
            ):
                return True
        self.opencti.log(
            &#34;info&#34;,
            &#34;Adding Stix-Observable {&#34;
            + stix_observable_id
            + &#34;} to Report {&#34;
            + id
            + &#34;}&#34;,
        )
        query = &#34;&#34;&#34;
           mutation ReportEdit($id: ID!, $input: RelationAddInput) {
               reportEdit(id: $id) {
                    relationAdd(input: $input) {
                        id
                    }
               }
           }
        &#34;&#34;&#34;
        self.opencti.query(
            query,
            {
                &#34;id&#34;: id,
                &#34;input&#34;: {
                    &#34;fromRole&#34;: &#34;observables_aggregation&#34;,
                    &#34;toId&#34;: stix_observable_id,
                    &#34;toRole&#34;: &#34;soo&#34;,
                    &#34;through&#34;: &#34;observable_refs&#34;,
                },
            },
        )
        return True
    else:
        self.opencti.log(
            &#34;error&#34;,
            &#34;[opencti_report] Missing parameters: id and stix_observable_id&#34;,
        )
        return False</code></pre>
</details>
</dd>
<dt id="pycti.Report.contains_stix_entity"><code class="name flex">
<span>def <span class="ident">contains_stix_entity</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def contains_stix_entity(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    entity_id = kwargs.get(&#34;entity_id&#34;, None)
    if id is not None and entity_id is not None:
        self.opencti.log(
            &#34;info&#34;,
            &#34;Checking Stix-Entity {&#34; + entity_id + &#34;} in Report {&#34; + id + &#34;}&#34;,
        )
        query = &#34;&#34;&#34;
            query ReportContainsStixDomainEntity($id: String!, $objectId: String!) {
                reportContainsStixDomainEntity(id: $id, objectId: $objectId)
            }
        &#34;&#34;&#34;
        result = self.opencti.query(query, {&#34;id&#34;: id, &#34;objectId&#34;: entity_id})
        if result[&#34;data&#34;][&#34;reportContainsStixDomainEntity&#34;]:
            return True
        query = &#34;&#34;&#34;
            query ReportContainsStixRelation($id: String!, $objectId: String!) {
                reportContainsStixRelation(id: $id, objectId: $objectId)
            }
        &#34;&#34;&#34;
        result = self.opencti.query(query, {&#34;id&#34;: id, &#34;objectId&#34;: entity_id})
        return result[&#34;data&#34;][&#34;reportContainsStixRelation&#34;]
    else:
        self.opencti.log(
            &#34;error&#34;, &#34;[opencti_report] Missing parameters: id or entity_id&#34;,
        )</code></pre>
</details>
</dd>
<dt id="pycti.Report.contains_stix_observable"><code class="name flex">
<span>def <span class="ident">contains_stix_observable</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def contains_stix_observable(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    stix_observable_id = kwargs.get(&#34;stix_observable_id&#34;, None)
    if id is not None and stix_observable_id is not None:
        self.opencti.log(
            &#34;info&#34;,
            &#34;Checking Stix-Observable {&#34;
            + stix_observable_id
            + &#34;} in Report {&#34;
            + id
            + &#34;}&#34;,
        )
        query = &#34;&#34;&#34;
            query ReportContainsStixObservable($id: String!, $objectId: String!) {
                reportContainsStixObservable(id: $id, objectId: $objectId)
            }
        &#34;&#34;&#34;
        result = self.opencti.query(
            query, {&#34;id&#34;: id, &#34;objectId&#34;: stix_observable_id}
        )
        return result[&#34;data&#34;][&#34;reportContainsStixObservable&#34;]
    else:
        self.opencti.log(
            &#34;error&#34;,
            &#34;[opencti_report] Missing parameters: id or stix_observable_id&#34;,
        )</code></pre>
</details>
</dd>
<dt id="pycti.Report.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create(self, **kwargs):
    name = kwargs.get(&#34;name&#34;, None)
    external_reference_id = kwargs.get(&#34;external_reference_id&#34;, None)
    description = kwargs.get(&#34;description&#34;, None)
    published = kwargs.get(&#34;published&#34;, None)
    report_class = kwargs.get(&#34;report_class&#34;, None)
    object_status = kwargs.get(&#34;object_status&#34;, None)
    source_confidence_level = kwargs.get(&#34;source_confidence_level&#34;, None)
    graph_data = kwargs.get(&#34;graph_data&#34;, None)
    id = kwargs.get(&#34;id&#34;, None)
    stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
    created = kwargs.get(&#34;created&#34;, None)
    modified = kwargs.get(&#34;modified&#34;, None)
    created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
    marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)
    update = kwargs.get(&#34;update&#34;, False)
    custom_attributes = &#34;&#34;&#34;
        id
        entity_type
        name
        description 
        ... on Report {
            observableRefs {
                edges {
                    node {
                        id
                        entity_type
                        stix_id_key
                        observable_value
                    }
                    relation {
                        id
                    }
                }
            }
        }
    &#34;&#34;&#34;
    object_result = None
    if external_reference_id is not None:
        object_result = self.opencti.stix_domain_entity.read(
            types=[&#34;Report&#34;],
            filters=[
                {&#34;key&#34;: &#34;hasExternalReference&#34;, &#34;values&#34;: [external_reference_id]}
            ],
            customAttributes=custom_attributes,
        )
    if object_result is None and name is not None:
        object_result = self.get_by_stix_id_or_name(
            stix_id_key=stix_id_key,
            name=name,
            published=published,
            custom_attributes=custom_attributes,
        )
    if object_result is not None:
        if update:
            if object_result[&#34;name&#34;] != name:
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;name&#34;, value=name
                )
                object_result[&#34;name&#34;] = name
            if object_result[&#34;description&#34;] != description:
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;description&#34;, value=description
                )
                object_result[&#34;description&#34;] = description
        if external_reference_id is not None:
            self.opencti.stix_entity.add_external_reference(
                id=object_result[&#34;id&#34;],
                entity=object_result,
                external_reference_id=external_reference_id,
            )
        return object_result
    else:
        report = self.create_raw(
            name=name,
            description=description,
            published=published,
            report_class=report_class,
            object_status=object_status,
            source_confidence_level=source_confidence_level,
            graph_data=graph_data,
            id=id,
            stix_id_key=stix_id_key,
            created=created,
            modified=modified,
            createdByRef=created_by_ref,
            markingDefinitions=marking_definitions,
        )
        if external_reference_id is not None:
            self.opencti.stix_entity.add_external_reference(
                id=report[&#34;id&#34;],
                entity=report,
                external_reference_id=external_reference_id,
            )
        return report</code></pre>
</details>
</dd>
<dt id="pycti.Report.create_raw"><code class="name flex">
<span>def <span class="ident">create_raw</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_raw(self, **kwargs):
    name = kwargs.get(&#34;name&#34;, None)
    description = kwargs.get(&#34;description&#34;, None)
    published = kwargs.get(&#34;published&#34;, None)
    report_class = kwargs.get(&#34;report_class&#34;, None)
    object_status = kwargs.get(&#34;object_status&#34;, None)
    source_confidence_level = kwargs.get(&#34;source_confidence_level&#34;, None)
    graph_data = kwargs.get(&#34;graph_data&#34;, None)
    id = kwargs.get(&#34;id&#34;, None)
    stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
    created = kwargs.get(&#34;created&#34;, None)
    modified = kwargs.get(&#34;modified&#34;, None)
    created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
    marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)

    if (
        name is not None
        and description is not None
        and published is not None
        and report_class is not None
    ):
        self.opencti.log(&#34;info&#34;, &#34;Creating Report {&#34; + name + &#34;}.&#34;)
        query = (
            &#34;&#34;&#34;
            mutation ReportAdd($input: ReportAddInput) {
                reportAdd(input: $input) {
                    &#34;&#34;&#34;
            + self.properties
            + &#34;&#34;&#34;
                }
            }
        &#34;&#34;&#34;
        )
        result = self.opencti.query(
            query,
            {
                &#34;input&#34;: {
                    &#34;name&#34;: name,
                    &#34;description&#34;: description,
                    &#34;published&#34;: published,
                    &#34;report_class&#34;: report_class,
                    &#34;object_status&#34;: object_status,
                    &#34;source_confidence_level&#34;: source_confidence_level,
                    &#34;graph_data&#34;: graph_data,
                    &#34;internal_id_key&#34;: id,
                    &#34;stix_id_key&#34;: stix_id_key,
                    &#34;created&#34;: created,
                    &#34;modified&#34;: modified,
                    &#34;createdByRef&#34;: created_by_ref,
                    &#34;markingDefinitions&#34;: marking_definitions,
                }
            },
        )
        return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;reportAdd&#34;])
    else:
        self.opencti.log(
            &#34;error&#34;,
            &#34;[opencti_report] Missing parameters: name and description and published and report_class&#34;,
        )</code></pre>
</details>
</dd>
<dt id="pycti.Report.get_by_stix_id_or_name"><code class="name flex">
<span>def <span class="ident">get_by_stix_id_or_name</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_by_stix_id_or_name(self, **kwargs):
    stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
    name = kwargs.get(&#34;name&#34;, None)
    published = kwargs.get(&#34;published&#34;, None)
    custom_attributes = kwargs.get(&#34;customAttributes&#34;, None)
    object_result = None
    if stix_id_key is not None:
        object_result = self.read(
            id=stix_id_key, customAttributes=custom_attributes
        )
    if object_result is None and name is not None and published is not None:
        published_final = parse(published).strftime(&#34;%Y-%m-%d&#34;)
        object_result = self.read(
            filters=[
                {&#34;key&#34;: &#34;name&#34;, &#34;values&#34;: [name]},
                {&#34;key&#34;: &#34;published_day&#34;, &#34;values&#34;: [published_final]},
            ],
            customAttributes=custom_attributes,
        )
    return object_result</code></pre>
</details>
</dd>
<dt id="pycti.Report.import_from_stix2"><code class="name flex">
<span>def <span class="ident">import_from_stix2</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def import_from_stix2(self, **kwargs):
    stix_object = kwargs.get(&#34;stixObject&#34;, None)
    extras = kwargs.get(&#34;extras&#34;, {})
    update = kwargs.get(&#34;update&#34;, False)
    if stix_object is not None:
        return self.create(
            name=stix_object[&#34;name&#34;],
            description=self.opencti.stix2.convert_markdown(
                stix_object[&#34;description&#34;]
            )
            if &#34;description&#34; in stix_object
            else &#34;&#34;,
            published=stix_object[&#34;published&#34;]
            if &#34;published&#34; in stix_object
            else &#34;&#34;,
            report_class=stix_object[CustomProperties.REPORT_CLASS]
            if CustomProperties.REPORT_CLASS in stix_object
            else &#34;Threat Report&#34;,
            object_status=stix_object[CustomProperties.OBJECT_STATUS]
            if CustomProperties.OBJECT_STATUS in stix_object
            else 0,
            source_confidence_level=stix_object[CustomProperties.SRC_CONF_LEVEL]
            if CustomProperties.SRC_CONF_LEVEL in stix_object
            else 1,
            graph_data=stix_object[CustomProperties.GRAPH_DATA]
            if CustomProperties.GRAPH_DATA in stix_object
            else &#34;&#34;,
            id=stix_object[CustomProperties.ID]
            if CustomProperties.ID in stix_object
            else None,
            stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
            created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
            modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
            createdByRef=extras[&#34;created_by_ref_id&#34;]
            if &#34;created_by_ref_id&#34; in extras
            else None,
            markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
            if &#34;marking_definitions_ids&#34; in extras
            else [],
            update=update,
        )
    else:
        self.opencti.log(
            &#34;error&#34;, &#34;[opencti_attack_pattern] Missing parameters: stixObject&#34;
        )</code></pre>
</details>
</dd>
<dt id="pycti.Report.list"><code class="name flex">
<span>def <span class="ident">list</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list(self, **kwargs):
    filters = kwargs.get(&#34;filters&#34;, None)
    search = kwargs.get(&#34;search&#34;, None)
    first = kwargs.get(&#34;first&#34;, 500)
    after = kwargs.get(&#34;after&#34;, None)
    order_by = kwargs.get(&#34;orderBy&#34;, None)
    order_mode = kwargs.get(&#34;orderMode&#34;, None)
    get_all = kwargs.get(&#34;getAll&#34;, False)
    if get_all:
        first = 500

    self.opencti.log(
        &#34;info&#34;, &#34;Listing Reports with filters &#34; + json.dumps(filters) + &#34;.&#34;
    )
    query = (
        &#34;&#34;&#34;
        query Reports($filters: [ReportsFiltering], $search: String, $first: Int, $after: ID, $orderBy: ReportsOrdering, $orderMode: OrderingMode) {
            reports(filters: $filters, search: $search, first: $first, after: $after, orderBy: $orderBy, orderMode: $orderMode) {
                edges {
                    node {
                        &#34;&#34;&#34;
        + self.properties
        + &#34;&#34;&#34;
                    }
                }
                pageInfo {
                    startCursor
                    endCursor
                    hasNextPage
                    hasPreviousPage
                    globalCount
                }                    
            }
        }
    &#34;&#34;&#34;
    )
    result = self.opencti.query(
        query,
        {
            &#34;filters&#34;: filters,
            &#34;search&#34;: search,
            &#34;first&#34;: first,
            &#34;after&#34;: after,
            &#34;orderBy&#34;: order_by,
            &#34;orderMode&#34;: order_mode,
        },
    )
    return self.opencti.process_multiple(result[&#34;data&#34;][&#34;reports&#34;])</code></pre>
</details>
</dd>
<dt id="pycti.Report.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    filters = kwargs.get(&#34;filters&#34;, None)
    custom_attributes = kwargs.get(&#34;customAttributes&#34;, None)
    if id is not None:
        self.opencti.log(&#34;info&#34;, &#34;Reading Report {&#34; + id + &#34;}.&#34;)
        query = (
            &#34;&#34;&#34;
            query Report($id: String!) {
                report(id: $id) {
                    &#34;&#34;&#34;
            + (
                custom_attributes
                if custom_attributes is not None
                else self.properties
            )
            + &#34;&#34;&#34;
                }
            }
        &#34;&#34;&#34;
        )
        result = self.opencti.query(query, {&#34;id&#34;: id})
        return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;report&#34;])
    elif filters is not None:
        result = self.list(filters=filters)
        if len(result) &gt; 0:
            return result[0]
        else:
            return None</code></pre>
</details>
</dd>
<dt id="pycti.Report.to_stix2"><code class="name flex">
<span>def <span class="ident">to_stix2</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_stix2(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    mode = kwargs.get(&#34;mode&#34;, &#34;simple&#34;)
    max_marking_definition_entity = kwargs.get(
        &#34;max_marking_definition_entity&#34;, None
    )
    entity = kwargs.get(&#34;entity&#34;, None)
    if id is not None and entity is None:
        entity = self.read(id=id)
    if entity is not None:
        report = dict()
        report[&#34;id&#34;] = entity[&#34;stix_id_key&#34;]
        report[&#34;type&#34;] = &#34;report&#34;
        report[&#34;spec_version&#34;] = SPEC_VERSION
        report[&#34;name&#34;] = entity[&#34;name&#34;]
        if self.opencti.not_empty(entity[&#34;stix_label&#34;]):
            report[&#34;labels&#34;] = entity[&#34;stix_label&#34;]
        else:
            report[&#34;labels&#34;] = [&#34;report&#34;]
        if self.opencti.not_empty(entity[&#34;description&#34;]):
            report[&#34;description&#34;] = entity[&#34;description&#34;]
        report[&#34;published&#34;] = self.opencti.stix2.format_date(entity[&#34;published&#34;])
        report[&#34;created&#34;] = self.opencti.stix2.format_date(entity[&#34;created&#34;])
        report[&#34;modified&#34;] = self.opencti.stix2.format_date(entity[&#34;modified&#34;])
        if self.opencti.not_empty(entity[&#34;alias&#34;]):
            report[CustomProperties.ALIASES] = entity[&#34;alias&#34;]
        if self.opencti.not_empty(entity[&#34;report_class&#34;]):
            report[CustomProperties.REPORT_CLASS] = entity[&#34;report_class&#34;]
        if self.opencti.not_empty(entity[&#34;object_status&#34;]):
            report[CustomProperties.OBJECT_STATUS] = entity[&#34;object_status&#34;]
        if self.opencti.not_empty(entity[&#34;source_confidence_level&#34;]):
            report[CustomProperties.SRC_CONF_LEVEL] = entity[
                &#34;source_confidence_level&#34;
            ]
        if self.opencti.not_empty(entity[&#34;graph_data&#34;]):
            report[CustomProperties.GRAPH_DATA] = entity[&#34;graph_data&#34;]
        report[CustomProperties.ID] = entity[&#34;id&#34;]
        return self.opencti.stix2.prepare_export(
            entity, report, mode, max_marking_definition_entity
        )
    else:
        self.opencti.log(
            &#34;error&#34;, &#34;[opencti_report] Missing parameters: id or entity&#34;
        )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pycti.StixDomainEntity"><code class="flex name class">
<span>class <span class="ident">StixDomainEntity</span></span>
<span>(</span><span>opencti, file)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StixDomainEntity:
    def __init__(self, opencti, file):
        self.opencti = opencti
        self.file = file
        self.properties = &#34;&#34;&#34;
            id
            stix_id_key
            entity_type
            parent_types
            name
            alias
            description
            graph_data        
            created_at
            updated_at
            createdByRef {
                node {
                    id
                    entity_type
                    stix_id_key
                    stix_label
                    name
                    alias
                    description
                    created
                    modified
                    ... on Organization {
                        organization_class
                    }
                }
                relation {
                    id
                }
            }            
            markingDefinitions {
                edges {
                    node {
                        id
                        entity_type
                        stix_id_key
                        definition_type
                        definition
                        level
                        color
                        created
                        modified
                    }
                    relation {
                        id
                    }
                }
            }
            tags {
                edges {
                    node {
                        id
                        tag_type
                        value
                        color
                    }
                    relation {
                        id
                    }
                }
            }
            externalReferences {
                edges {
                    node {
                        id
                        entity_type
                        stix_id_key
                        source_name
                        description
                        url
                        hash
                        external_id
                        created
                        modified
                    }
                    relation {
                        id
                    }
                }
            }
            importFiles {
                edges {
                    node {
                        id
                        name
                        size
                    }
                }
            }
            ... on AttackPattern {
                platform
                required_permission
                external_id
            }
            ... on ThreatActor {
                goal
                sophistication
                resource_level
                primary_motivation
                secondary_motivation
                personal_motivation
            }
            ... on IntrusionSet {
                first_seen
                last_seen
                goal
                sophistication
                resource_level
                primary_motivation
                secondary_motivation
            }
            ... on Campaign {
                objective
                first_seen
                last_seen
            }
            ... on Incident {
                objective
                first_seen
                last_seen
                observableRefs {
                    edges {
                        node {
                            id
                            entity_type
                            stix_id_key
                            observable_value
                        }
                        relation {
                            id
                        }
                    }
                }
            }
            ... on Malware {
                killChainPhases {
                    edges {
                        node {
                            id
                            entity_type
                            stix_id_key
                            kill_chain_name
                            phase_name
                            phase_order
                            created
                            modified
                        }
                        relation {
                            id
                        }
                    }
                }
            }
            ... on Tool {
                tool_version
                killChainPhases {
                    edges {
                        node {
                            id
                            entity_type
                            stix_id_key
                            kill_chain_name
                            phase_name
                            phase_order
                            created
                            modified
                        }
                        relation {
                            id
                        }
                    }
                }
            }
            ... on Vulnerability {
                base_score
                base_severity
                attack_vector
                integrity_impact
                availability_impact
            }
            ... on Organization {
                organization_class
            }
            ... on Indicator {
                indicator_pattern
                pattern_type
                observableRefs {
                    edges {
                        node {
                            id
                            stix_id_key
                            entity_type
                            observable_value
                        }
                        relation {
                            id
                        }
                    }
                }
                killChainPhases {
                    edges {
                        node {
                            id
                            entity_type
                            stix_id_key
                            kill_chain_name
                            phase_name
                            phase_order
                            created
                            modified
                        }
                        relation {
                            id
                        }
                    }
                }
            }
            ... on Report {
                report_class
                published
                object_status
                source_confidence_level
                objectRefs {
                    edges {
                        node {
                            id
                            stix_id_key
                            entity_type
                        }
                    }
                }
                observableRefs {
                    edges {
                        node {
                            id
                            stix_id_key
                            entity_type
                            observable_value
                        }
                    }
                }
                relationRefs {
                    edges {
                        node {
                            id
                            stix_id_key
                        }
                    }
                }
            }
        &#34;&#34;&#34;

    &#34;&#34;&#34;
        List Stix-Domain-Entity objects

        :param types: the list of types
        :param filters: the filters to apply
        :param search: the search keyword
        :param first: return the first n rows from the after ID (or the beginning if not set)
        :param after: ID of the first row for pagination
        :return List of Stix-Domain-Entity objects
    &#34;&#34;&#34;

    def list(self, **kwargs):
        types = kwargs.get(&#34;types&#34;, None)
        filters = kwargs.get(&#34;filters&#34;, None)
        search = kwargs.get(&#34;search&#34;, None)
        first = kwargs.get(&#34;first&#34;, 500)
        after = kwargs.get(&#34;after&#34;, None)
        order_by = kwargs.get(&#34;orderBy&#34;, None)
        order_mode = kwargs.get(&#34;orderMode&#34;, None)
        get_all = kwargs.get(&#34;getAll&#34;, False)
        if get_all:
            first = 500

        self.opencti.log(
            &#34;info&#34;,
            &#34;Listing Stix-Domain-Entities with filters &#34; + json.dumps(filters) + &#34;.&#34;,
        )
        query = (
            &#34;&#34;&#34;
                query StixDomainEntities($types: [String], $filters: [StixDomainEntitiesFiltering], $search: String, $first: Int, $after: ID, $orderBy: StixDomainEntitiesOrdering, $orderMode: OrderingMode) {
                    stixDomainEntities(types: $types, filters: $filters, search: $search, first: $first, after: $after, orderBy: $orderBy, orderMode: $orderMode) {
                        edges {
                            node {
                                &#34;&#34;&#34;
            + self.properties
            + &#34;&#34;&#34;
                        }
                    }
                    pageInfo {
                        startCursor
                        endCursor
                        hasNextPage
                        hasPreviousPage
                        globalCount
                    }
                }
            }
        &#34;&#34;&#34;
        )
        result = self.opencti.query(
            query,
            {
                &#34;types&#34;: types,
                &#34;filters&#34;: filters,
                &#34;search&#34;: search,
                &#34;first&#34;: first,
                &#34;after&#34;: after,
                &#34;orderBy&#34;: order_by,
                &#34;orderMode&#34;: order_mode,
            },
        )

        if get_all:
            final_data = []
            data = self.opencti.process_multiple(result[&#34;data&#34;][&#34;stixDomainEntities&#34;])
            final_data = final_data + data
            while result[&#34;data&#34;][&#34;stixDomainEntities&#34;][&#34;pageInfo&#34;][&#34;hasNextPage&#34;]:
                after = result[&#34;data&#34;][&#34;stixDomainEntities&#34;][&#34;pageInfo&#34;][&#34;endCursor&#34;]
                self.opencti.log(&#34;info&#34;, &#34;Listing Stix-Domain-Entities after &#34; + after)
                result = self.opencti.query(
                    query,
                    {
                        &#34;types&#34;: types,
                        &#34;filters&#34;: filters,
                        &#34;search&#34;: search,
                        &#34;first&#34;: first,
                        &#34;after&#34;: after,
                        &#34;orderBy&#34;: order_by,
                        &#34;orderMode&#34;: order_mode,
                    },
                )
                data = self.opencti.process_multiple(
                    result[&#34;data&#34;][&#34;stixDomainEntities&#34;]
                )
                final_data = final_data + data
            return final_data
        else:
            return self.opencti.process_multiple(result[&#34;data&#34;][&#34;stixDomainEntities&#34;])

    &#34;&#34;&#34;
        Read a Stix-Domain-Entity object
        
        :param id: the id of the Stix-Domain-Entity
        :param types: list of Stix Domain Entity types
        :param filters: the filters to apply if no id provided
        :return Stix-Domain-Entity object
    &#34;&#34;&#34;

    def read(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        types = kwargs.get(&#34;types&#34;, None)
        filters = kwargs.get(&#34;filters&#34;, None)
        custom_attributes = kwargs.get(&#34;customAttributes&#34;, None)
        if id is not None:
            self.opencti.log(&#34;info&#34;, &#34;Reading Stix-Domain-Entity {&#34; + id + &#34;}.&#34;)
            query = (
                &#34;&#34;&#34;
                    query StixDomainEntity($id: String!) {
                        stixDomainEntity(id: $id) {
                            &#34;&#34;&#34;
                + (
                    custom_attributes
                    if custom_attributes is not None
                    else self.properties
                )
                + &#34;&#34;&#34;
                    }
                }
             &#34;&#34;&#34;
            )
            result = self.opencti.query(query, {&#34;id&#34;: id})
            return self.opencti.process_multiple_fields(
                result[&#34;data&#34;][&#34;stixDomainEntity&#34;]
            )
        elif filters is not None:
            result = self.list(types=types, filters=filters)
            if len(result) &gt; 0:
                return result[0]
            else:
                return None
        else:
            self.opencti.log(
                &#34;error&#34;,
                &#34;[opencti_stix_domain_entity] Missing parameters: id or filters&#34;,
            )
            return None

    &#34;&#34;&#34;
        Get a Stix-Domain-Entity object by stix_id or name

        :param types: a list of Stix-Domain-Entity types
        :param stix_id_key: the STIX ID of the Stix-Domain-Entity
        :param name: the name of the Stix-Domain-Entity
        :return Stix-Domain-Entity object
    &#34;&#34;&#34;

    def get_by_stix_id_or_name(self, **kwargs):
        types = kwargs.get(&#34;types&#34;, None)
        stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
        name = kwargs.get(&#34;name&#34;, None)
        custom_attributes = kwargs.get(&#34;customAttributes&#34;, None)
        object_result = None
        if stix_id_key is not None:
            object_result = self.read(
                id=stix_id_key, customAttributes=custom_attributes
            )
        if object_result is None and name is not None:
            object_result = self.read(
                types=types,
                filters=[{&#34;key&#34;: &#34;name&#34;, &#34;values&#34;: [name]}],
                customAttributes=custom_attributes,
            )
            if object_result is None:
                object_result = self.read(
                    types=types,
                    filters=[{&#34;key&#34;: &#34;alias&#34;, &#34;values&#34;: [name]}],
                    customAttributes=custom_attributes,
                )
        return object_result

    &#34;&#34;&#34;
        Update a Stix-Domain-Entity object field

        :param id: the Stix-Domain-Entity id
        :param key: the key of the field
        :param value: the value of the field
        :return The updated Stix-Domain-Entity object
    &#34;&#34;&#34;

    def update_field(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        key = kwargs.get(&#34;key&#34;, None)
        value = kwargs.get(&#34;value&#34;, None)
        if id is not None and key is not None and value is not None:
            self.opencti.log(
                &#34;info&#34;, &#34;Updating Stix-Domain-Entity {&#34; + id + &#34;} field {&#34; + key + &#34;}.&#34;
            )
            query = &#34;&#34;&#34;
                    mutation StixDomainEntityEdit($id: ID!, $input: EditInput!) {
                        stixDomainEntityEdit(id: $id) {
                            fieldPatch(input: $input) {
                                id
                            }
                        }
                    }
                &#34;&#34;&#34;
            result = self.opencti.query(
                query, {&#34;id&#34;: id, &#34;input&#34;: {&#34;key&#34;: key, &#34;value&#34;: value}}
            )
            return self.opencti.process_multiple_fields(
                result[&#34;data&#34;][&#34;stixDomainEntityEdit&#34;][&#34;fieldPatch&#34;]
            )
        else:
            self.opencti.log(
                &#34;error&#34;,
                &#34;[opencti_stix_domain_entity] Missing parameters: id and key and value&#34;,
            )
            return None

    &#34;&#34;&#34;
        Delete a Stix-Domain-Entity

        :param id: the Stix-Domain-Entity id
        :return void
    &#34;&#34;&#34;

    def delete(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        if id is not None:
            self.opencti.log(&#34;info&#34;, &#34;Deleting Stix-Domain-Entity {&#34; + id + &#34;}.&#34;)
            query = &#34;&#34;&#34;
                 mutation StixDomainEntityEdit($id: ID!) {
                     stixDomainEntityEdit(id: $id) {
                         delete
                     }
                 }
             &#34;&#34;&#34;
            self.opencti.query(query, {&#34;id&#34;: id})
        else:
            self.opencti.log(
                &#34;error&#34;, &#34;[opencti_stix_domain_entity] Missing parameters: id&#34;
            )
            return None

    &#34;&#34;&#34;
        Upload a file in this Stix-Domain-Entity 

        :param id: the Stix-Domain-Entity id
        :param file_name
        :param data
        :return void
    &#34;&#34;&#34;

    def add_file(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        file_name = kwargs.get(&#34;file_name&#34;, None)
        data = kwargs.get(&#34;data&#34;, None)
        mime_type = kwargs.get(&#34;mime_type&#34;, &#34;text/plain&#34;)
        if id is not None and file_name is not None:
            stix_domain_entity = self.read(id=id)
            if stix_domain_entity is None:
                self.opencti.log(&#34;error&#34;, &#34;Cannot add File, entity not found&#34;)
                return False
            final_file_name = os.path.basename(file_name)
            current_files = {}
            for file in stix_domain_entity[&#34;importFiles&#34;]:
                current_files[file[&#34;name&#34;]] = file
            if final_file_name in current_files:
                return current_files[final_file_name]
            else:
                self.opencti.log(
                    &#34;info&#34;, &#34;Uploading a file in Stix-Domain-Entity {&#34; + id + &#34;}.&#34;
                )
                query = &#34;&#34;&#34;
                    mutation StixDomainEntityEdit($id: ID!, $file: Upload!) {
                        stixDomainEntityEdit(id: $id) {
                            importPush(file: $file) {
                                id
                                name
                            }
                        }
                    }
                 &#34;&#34;&#34;
                if data is None:
                    data = open(file_name, &#34;rb&#34;)
                    mime_type = magic.from_file(file_name, mime=True)

                return self.opencti.query(
                    query,
                    {&#34;id&#34;: id, &#34;file&#34;: (self.file(final_file_name, data, mime_type))},
                )
        else:
            self.opencti.log(
                &#34;error&#34;,
                &#34;[opencti_stix_domain_entity] Missing parameters: id or file_name&#34;,
            )
            return None

    def push_list_export(self, entity_type, file_name, data, context=&#34;&#34;, list_args=&#34;&#34;):
        query = &#34;&#34;&#34;
            mutation StixDomainEntitiesExportPush($type: String!, $file: Upload!, $context: String, $listArgs: String) {
                stixDomainEntitiesExportPush(type: $type, file: $file, context: $context, listArgs: $listArgs)
            } 
        &#34;&#34;&#34;
        self.opencti.query(
            query,
            {
                &#34;type&#34;: entity_type,
                &#34;file&#34;: (self.file(file_name, data)),
                &#34;context&#34;: context,
                &#34;listArgs&#34;: list_args,
            },
        )

    def push_entity_export(self, entity_id, file_name, data):
        query = &#34;&#34;&#34;
            mutation StixDomainEntityEdit($id: ID!, $file: Upload!) {
                stixDomainEntityEdit(id: $id) {
                    exportPush(file: $file)
                }
            } 
        &#34;&#34;&#34;
        self.opencti.query(
            query, {&#34;id&#34;: entity_id, &#34;file&#34;: (self.file(file_name, data))}
        )</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pycti.StixDomainEntity.add_file"><code class="name flex">
<span>def <span class="ident">add_file</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_file(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    file_name = kwargs.get(&#34;file_name&#34;, None)
    data = kwargs.get(&#34;data&#34;, None)
    mime_type = kwargs.get(&#34;mime_type&#34;, &#34;text/plain&#34;)
    if id is not None and file_name is not None:
        stix_domain_entity = self.read(id=id)
        if stix_domain_entity is None:
            self.opencti.log(&#34;error&#34;, &#34;Cannot add File, entity not found&#34;)
            return False
        final_file_name = os.path.basename(file_name)
        current_files = {}
        for file in stix_domain_entity[&#34;importFiles&#34;]:
            current_files[file[&#34;name&#34;]] = file
        if final_file_name in current_files:
            return current_files[final_file_name]
        else:
            self.opencti.log(
                &#34;info&#34;, &#34;Uploading a file in Stix-Domain-Entity {&#34; + id + &#34;}.&#34;
            )
            query = &#34;&#34;&#34;
                mutation StixDomainEntityEdit($id: ID!, $file: Upload!) {
                    stixDomainEntityEdit(id: $id) {
                        importPush(file: $file) {
                            id
                            name
                        }
                    }
                }
             &#34;&#34;&#34;
            if data is None:
                data = open(file_name, &#34;rb&#34;)
                mime_type = magic.from_file(file_name, mime=True)

            return self.opencti.query(
                query,
                {&#34;id&#34;: id, &#34;file&#34;: (self.file(final_file_name, data, mime_type))},
            )
    else:
        self.opencti.log(
            &#34;error&#34;,
            &#34;[opencti_stix_domain_entity] Missing parameters: id or file_name&#34;,
        )
        return None</code></pre>
</details>
</dd>
<dt id="pycti.StixDomainEntity.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    if id is not None:
        self.opencti.log(&#34;info&#34;, &#34;Deleting Stix-Domain-Entity {&#34; + id + &#34;}.&#34;)
        query = &#34;&#34;&#34;
             mutation StixDomainEntityEdit($id: ID!) {
                 stixDomainEntityEdit(id: $id) {
                     delete
                 }
             }
         &#34;&#34;&#34;
        self.opencti.query(query, {&#34;id&#34;: id})
    else:
        self.opencti.log(
            &#34;error&#34;, &#34;[opencti_stix_domain_entity] Missing parameters: id&#34;
        )
        return None</code></pre>
</details>
</dd>
<dt id="pycti.StixDomainEntity.get_by_stix_id_or_name"><code class="name flex">
<span>def <span class="ident">get_by_stix_id_or_name</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_by_stix_id_or_name(self, **kwargs):
    types = kwargs.get(&#34;types&#34;, None)
    stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
    name = kwargs.get(&#34;name&#34;, None)
    custom_attributes = kwargs.get(&#34;customAttributes&#34;, None)
    object_result = None
    if stix_id_key is not None:
        object_result = self.read(
            id=stix_id_key, customAttributes=custom_attributes
        )
    if object_result is None and name is not None:
        object_result = self.read(
            types=types,
            filters=[{&#34;key&#34;: &#34;name&#34;, &#34;values&#34;: [name]}],
            customAttributes=custom_attributes,
        )
        if object_result is None:
            object_result = self.read(
                types=types,
                filters=[{&#34;key&#34;: &#34;alias&#34;, &#34;values&#34;: [name]}],
                customAttributes=custom_attributes,
            )
    return object_result</code></pre>
</details>
</dd>
<dt id="pycti.StixDomainEntity.list"><code class="name flex">
<span>def <span class="ident">list</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list(self, **kwargs):
    types = kwargs.get(&#34;types&#34;, None)
    filters = kwargs.get(&#34;filters&#34;, None)
    search = kwargs.get(&#34;search&#34;, None)
    first = kwargs.get(&#34;first&#34;, 500)
    after = kwargs.get(&#34;after&#34;, None)
    order_by = kwargs.get(&#34;orderBy&#34;, None)
    order_mode = kwargs.get(&#34;orderMode&#34;, None)
    get_all = kwargs.get(&#34;getAll&#34;, False)
    if get_all:
        first = 500

    self.opencti.log(
        &#34;info&#34;,
        &#34;Listing Stix-Domain-Entities with filters &#34; + json.dumps(filters) + &#34;.&#34;,
    )
    query = (
        &#34;&#34;&#34;
            query StixDomainEntities($types: [String], $filters: [StixDomainEntitiesFiltering], $search: String, $first: Int, $after: ID, $orderBy: StixDomainEntitiesOrdering, $orderMode: OrderingMode) {
                stixDomainEntities(types: $types, filters: $filters, search: $search, first: $first, after: $after, orderBy: $orderBy, orderMode: $orderMode) {
                    edges {
                        node {
                            &#34;&#34;&#34;
        + self.properties
        + &#34;&#34;&#34;
                    }
                }
                pageInfo {
                    startCursor
                    endCursor
                    hasNextPage
                    hasPreviousPage
                    globalCount
                }
            }
        }
    &#34;&#34;&#34;
    )
    result = self.opencti.query(
        query,
        {
            &#34;types&#34;: types,
            &#34;filters&#34;: filters,
            &#34;search&#34;: search,
            &#34;first&#34;: first,
            &#34;after&#34;: after,
            &#34;orderBy&#34;: order_by,
            &#34;orderMode&#34;: order_mode,
        },
    )

    if get_all:
        final_data = []
        data = self.opencti.process_multiple(result[&#34;data&#34;][&#34;stixDomainEntities&#34;])
        final_data = final_data + data
        while result[&#34;data&#34;][&#34;stixDomainEntities&#34;][&#34;pageInfo&#34;][&#34;hasNextPage&#34;]:
            after = result[&#34;data&#34;][&#34;stixDomainEntities&#34;][&#34;pageInfo&#34;][&#34;endCursor&#34;]
            self.opencti.log(&#34;info&#34;, &#34;Listing Stix-Domain-Entities after &#34; + after)
            result = self.opencti.query(
                query,
                {
                    &#34;types&#34;: types,
                    &#34;filters&#34;: filters,
                    &#34;search&#34;: search,
                    &#34;first&#34;: first,
                    &#34;after&#34;: after,
                    &#34;orderBy&#34;: order_by,
                    &#34;orderMode&#34;: order_mode,
                },
            )
            data = self.opencti.process_multiple(
                result[&#34;data&#34;][&#34;stixDomainEntities&#34;]
            )
            final_data = final_data + data
        return final_data
    else:
        return self.opencti.process_multiple(result[&#34;data&#34;][&#34;stixDomainEntities&#34;])</code></pre>
</details>
</dd>
<dt id="pycti.StixDomainEntity.push_entity_export"><code class="name flex">
<span>def <span class="ident">push_entity_export</span></span>(<span>self, entity_id, file_name, data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def push_entity_export(self, entity_id, file_name, data):
    query = &#34;&#34;&#34;
        mutation StixDomainEntityEdit($id: ID!, $file: Upload!) {
            stixDomainEntityEdit(id: $id) {
                exportPush(file: $file)
            }
        } 
    &#34;&#34;&#34;
    self.opencti.query(
        query, {&#34;id&#34;: entity_id, &#34;file&#34;: (self.file(file_name, data))}
    )</code></pre>
</details>
</dd>
<dt id="pycti.StixDomainEntity.push_list_export"><code class="name flex">
<span>def <span class="ident">push_list_export</span></span>(<span>self, entity_type, file_name, data, context='', list_args='')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def push_list_export(self, entity_type, file_name, data, context=&#34;&#34;, list_args=&#34;&#34;):
    query = &#34;&#34;&#34;
        mutation StixDomainEntitiesExportPush($type: String!, $file: Upload!, $context: String, $listArgs: String) {
            stixDomainEntitiesExportPush(type: $type, file: $file, context: $context, listArgs: $listArgs)
        } 
    &#34;&#34;&#34;
    self.opencti.query(
        query,
        {
            &#34;type&#34;: entity_type,
            &#34;file&#34;: (self.file(file_name, data)),
            &#34;context&#34;: context,
            &#34;listArgs&#34;: list_args,
        },
    )</code></pre>
</details>
</dd>
<dt id="pycti.StixDomainEntity.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    types = kwargs.get(&#34;types&#34;, None)
    filters = kwargs.get(&#34;filters&#34;, None)
    custom_attributes = kwargs.get(&#34;customAttributes&#34;, None)
    if id is not None:
        self.opencti.log(&#34;info&#34;, &#34;Reading Stix-Domain-Entity {&#34; + id + &#34;}.&#34;)
        query = (
            &#34;&#34;&#34;
                query StixDomainEntity($id: String!) {
                    stixDomainEntity(id: $id) {
                        &#34;&#34;&#34;
            + (
                custom_attributes
                if custom_attributes is not None
                else self.properties
            )
            + &#34;&#34;&#34;
                }
            }
         &#34;&#34;&#34;
        )
        result = self.opencti.query(query, {&#34;id&#34;: id})
        return self.opencti.process_multiple_fields(
            result[&#34;data&#34;][&#34;stixDomainEntity&#34;]
        )
    elif filters is not None:
        result = self.list(types=types, filters=filters)
        if len(result) &gt; 0:
            return result[0]
        else:
            return None
    else:
        self.opencti.log(
            &#34;error&#34;,
            &#34;[opencti_stix_domain_entity] Missing parameters: id or filters&#34;,
        )
        return None</code></pre>
</details>
</dd>
<dt id="pycti.StixDomainEntity.update_field"><code class="name flex">
<span>def <span class="ident">update_field</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_field(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    key = kwargs.get(&#34;key&#34;, None)
    value = kwargs.get(&#34;value&#34;, None)
    if id is not None and key is not None and value is not None:
        self.opencti.log(
            &#34;info&#34;, &#34;Updating Stix-Domain-Entity {&#34; + id + &#34;} field {&#34; + key + &#34;}.&#34;
        )
        query = &#34;&#34;&#34;
                mutation StixDomainEntityEdit($id: ID!, $input: EditInput!) {
                    stixDomainEntityEdit(id: $id) {
                        fieldPatch(input: $input) {
                            id
                        }
                    }
                }
            &#34;&#34;&#34;
        result = self.opencti.query(
            query, {&#34;id&#34;: id, &#34;input&#34;: {&#34;key&#34;: key, &#34;value&#34;: value}}
        )
        return self.opencti.process_multiple_fields(
            result[&#34;data&#34;][&#34;stixDomainEntityEdit&#34;][&#34;fieldPatch&#34;]
        )
    else:
        self.opencti.log(
            &#34;error&#34;,
            &#34;[opencti_stix_domain_entity] Missing parameters: id and key and value&#34;,
        )
        return None</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pycti.StixEntity"><code class="flex name class">
<span>class <span class="ident">StixEntity</span></span>
<span>(</span><span>opencti)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StixEntity:
    def __init__(self, opencti):
        self.opencti = opencti
        self.properties = &#34;&#34;&#34;
            id
            stix_id_key
            entity_type
            parent_types
            name
            description
            created_at
            updated_at
            createdByRef {
                node {
                    id
                    entity_type
                    stix_id_key
                    stix_label
                    name
                    alias
                    description
                    created
                    modified
                    ... on Organization {
                        organization_class
                    }
                }
                relation {
                    id
                }
            }            
            markingDefinitions {
                edges {
                    node {
                        id
                        entity_type
                        stix_id_key
                        definition_type
                        definition
                        level
                        color
                        created
                        modified
                    }
                    relation {
                        id
                    }
                }
            }
            tags {
                edges {
                    node {
                        id
                        tag_type
                        value
                        color
                    }
                    relation {
                        id
                    }
                }
            }
            externalReferences {
                edges {
                    node {
                        id
                        entity_type
                        stix_id_key
                        source_name
                        description
                        url
                        hash
                        external_id
                        created
                        modified
                    }
                    relation {
                        id
                    }
                }
            }
            ... on AttackPattern {
                platform
                required_permission
                external_id
                killChainPhases {
                    edges {
                        node {
                            id
                            entity_type
                            stix_id_key
                            kill_chain_name
                            phase_name
                            phase_order
                            created
                            modified
                        }
                        relation {
                            id
                        }
                    }
                }
            }
            ... on ThreatActor {
                goal
                sophistication
                resource_level
                primary_motivation
                secondary_motivation
                personal_motivation
            }
            ... on IntrusionSet {
                first_seen
                last_seen
                goal
                sophistication
                resource_level
                primary_motivation
                secondary_motivation
            }
            ... on Campaign {
                objective
                first_seen
                last_seen
            }
            ... on Incident {
                objective
                first_seen
                last_seen
            }
            ... on Organization {
                organization_class
            }
            ... on Malware {
                killChainPhases {
                    edges {
                        node {
                            id
                            entity_type
                            stix_id_key
                            kill_chain_name
                            phase_name
                            phase_order
                            created
                            modified
                        }
                        relation {
                            id
                        }
                    }
                }                
            }
            ... on Tool {
                tool_version
                killChainPhases {
                    edges {
                        node {
                            id
                            entity_type
                            stix_id_key
                            kill_chain_name
                            phase_name
                            phase_order
                            created
                            modified
                        }
                        relation {
                            id
                        }
                    }
                }
            }
            ... on Vulnerability {
                base_score
                base_severity
                attack_vector
                integrity_impact
                availability_impact
            }            
            ... on Organization {
                organization_class
            }
            ... on Indicator {
                indicator_pattern
                pattern_type
                observableRefs {
                    edges {
                        node {
                            id
                            stix_id_key
                            entity_type
                            observable_value
                        }
                        relation {
                            id
                        }
                    }
                }
                killChainPhases {
                    edges {
                        node {
                            id
                            entity_type
                            stix_id_key
                            kill_chain_name
                            phase_name
                            phase_order
                            created
                            modified
                        }
                        relation {
                            id
                        }
                    }
                }
            }            
            ... on Report {
                report_class
                published
                object_status
                source_confidence_level
                objectRefs {
                    edges {
                        node {
                            id
                            stix_id_key
                            entity_type
                        }
                        relation {
                            id
                        }
                    }
                }
                observableRefs {
                    edges {
                        node {
                            id
                            stix_id_key
                            entity_type
                            observable_value
                        }
                        relation {
                            id
                        }
                    }
                }
                relationRefs {
                    edges {
                        node {
                            id
                            stix_id_key
                        }
                        relation {
                            id
                        }
                    }
                }
            }            
            ... on StixRelation {
                first_seen
                last_seen
                killChainPhases {
                    edges {
                        node {
                            id
                            entity_type
                            stix_id_key
                            kill_chain_name
                            phase_name
                            phase_order
                            created
                            modified
                        }
                        relation {
                            id
                        }
                    }
                }                
            } 
        &#34;&#34;&#34;

    &#34;&#34;&#34;
        Read a Stix-Entity object

        :param id: the id of the Stix-Entity
        :return Stix-Entity object
    &#34;&#34;&#34;

    def read(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        custom_attributes = kwargs.get(&#34;customAttributes&#34;, None)
        if id is not None:
            self.opencti.log(&#34;info&#34;, &#34;Reading Stix-Entity {&#34; + id + &#34;}.&#34;)
            query = (
                &#34;&#34;&#34;
                query StixEntity($id: String!) {
                    stixEntity(id: $id) {
                        &#34;&#34;&#34;
                + (
                    custom_attributes
                    if custom_attributes is not None
                    else self.properties
                )
                + &#34;&#34;&#34;
                    }
                }
             &#34;&#34;&#34;
            )
            result = self.opencti.query(query, {&#34;id&#34;: id})
            return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;stixEntity&#34;])
        else:
            self.opencti.log(&#34;error&#34;, &#34;Missing parameters: id&#34;)
            return None

    &#34;&#34;&#34;
        Update the Identity author of a Stix-Entity object (created_by_ref)

        :param id: the id of the Stix-Entity
        :param identity_id: the id of the Identity
        :return Boolean
    &#34;&#34;&#34;

    def update_created_by_ref(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        stix_entity = kwargs.get(&#34;entity&#34;, None)
        identity_id = kwargs.get(&#34;identity_id&#34;, None)
        if id is not None and identity_id is not None:
            if stix_entity is None:
                custom_attributes = &#34;&#34;&#34;
                    id
                    createdByRef {
                        node {
                            id
                            entity_type
                            stix_id_key
                            stix_label
                            name
                            alias
                            description
                            created
                            modified
                            ... on Organization {
                                organization_class
                            }
                        }
                        relation {
                            id
                        }
                    }    
                &#34;&#34;&#34;
                stix_entity = self.read(id=id, customAttributes=custom_attributes)
            if stix_entity is None:
                self.opencti.log(
                    &#34;error&#34;, &#34;Cannot update created_by_ref, entity not found&#34;
                )
                return False
            current_identity_id = None
            current_relation_id = None
            if stix_entity[&#34;createdByRef&#34;] is not None:
                current_identity_id = stix_entity[&#34;createdByRef&#34;][&#34;id&#34;]
                current_relation_id = stix_entity[&#34;createdByRef&#34;][&#34;remote_relation_id&#34;]
            # Current identity is the same
            if current_identity_id == identity_id:
                return True
            else:
                self.opencti.log(
                    &#34;info&#34;,
                    &#34;Updating author of Stix-Entity {&#34;
                    + id
                    + &#34;} with Identity {&#34;
                    + identity_id
                    + &#34;}&#34;,
                )
                # Current identity is different, delete the old relation
                if current_relation_id is not None:
                    query = &#34;&#34;&#34;
                        mutation StixEntityEdit($id: ID!, $relationId: ID!) {
                            stixEntityEdit(id: $id) {
                                relationDelete(relationId: $relationId) {
                                    id
                                }
                            }
                        }
                    &#34;&#34;&#34;
                    self.opencti.query(
                        query, {&#34;id&#34;: id, &#34;relationId&#34;: current_relation_id}
                    )
                # Add the new relation
                query = &#34;&#34;&#34;
                   mutation StixEntityEdit($id: ID!, $input: RelationAddInput) {
                       stixEntityEdit(id: $id) {
                            relationAdd(input: $input) {
                                id
                            }
                       }
                   }
                &#34;&#34;&#34;
                variables = {
                    &#34;id&#34;: id,
                    &#34;input&#34;: {
                        &#34;fromRole&#34;: &#34;so&#34;,
                        &#34;toId&#34;: identity_id,
                        &#34;toRole&#34;: &#34;creator&#34;,
                        &#34;through&#34;: &#34;created_by_ref&#34;,
                    },
                }
                self.opencti.query(query, variables)

        else:
            self.opencti.log(&#34;error&#34;, &#34;Missing parameters: id and identity_id&#34;)
            return False

    &#34;&#34;&#34;
        Add a Marking-Definition object to Stix-Entity object (object_marking_refs)

        :param id: the id of the Stix-Entity
        :param marking_definition_id: the id of the Marking-Definition
        :return Boolean
    &#34;&#34;&#34;

    def add_marking_definition(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        stix_entity = kwargs.get(&#34;entity&#34;, None)
        marking_definition_id = kwargs.get(&#34;marking_definition_id&#34;, None)
        if id is not None and marking_definition_id is not None:
            if stix_entity is None:
                custom_attributes = &#34;&#34;&#34;
                    id
                    markingDefinitions {
                        edges {
                            node {
                                id
                                entity_type
                                stix_id_key
                                definition_type
                                definition
                                level
                                color
                                created
                                modified
                            }
                            relation {
                                id
                            }
                        }
                    }
                &#34;&#34;&#34;
                stix_entity = self.read(id=id, customAttributes=custom_attributes)
            if stix_entity is None:
                self.opencti.log(
                    &#34;error&#34;, &#34;Cannot add Marking-Definition, entity not found&#34;
                )
                return False
            if marking_definition_id in stix_entity[&#34;markingDefinitionsIds&#34;]:
                return True
            else:
                self.opencti.log(
                    &#34;info&#34;,
                    &#34;Adding Marking-Definition {&#34;
                    + marking_definition_id
                    + &#34;} to Stix-Entity {&#34;
                    + id
                    + &#34;}&#34;,
                )
                query = &#34;&#34;&#34;
                   mutation StixEntityAddRelation($id: ID!, $input: RelationAddInput) {
                       stixEntityEdit(id: $id) {
                            relationAdd(input: $input) {
                                id
                            }
                       }
                   }
                &#34;&#34;&#34;
                self.opencti.query(
                    query,
                    {
                        &#34;id&#34;: id,
                        &#34;input&#34;: {
                            &#34;fromRole&#34;: &#34;so&#34;,
                            &#34;toId&#34;: marking_definition_id,
                            &#34;toRole&#34;: &#34;marking&#34;,
                            &#34;through&#34;: &#34;object_marking_refs&#34;,
                        },
                    },
                )
                return True
        else:
            self.opencti.log(
                &#34;error&#34;, &#34;Missing parameters: id and marking_definition_id&#34;
            )
            return False

    &#34;&#34;&#34;
        Add a Tag object to Stix-Entity object (tagging)

        :param id: the id of the Stix-Entity
        :param tag_id: the id of the Tag
        :return Boolean
    &#34;&#34;&#34;

    def add_tag(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        stix_entity = kwargs.get(&#34;entity&#34;, None)
        tag_id = kwargs.get(&#34;tag_id&#34;, None)
        if id is not None and tag_id is not None:
            if stix_entity is None:
                custom_attributes = &#34;&#34;&#34;
                    id
                    tags {
                        edges {
                            node {
                                id
                                tag_type
                                value
                                color
                            }
                            relation {
                                id
                            }
                        }
                    }
                &#34;&#34;&#34;
                stix_entity = self.read(id=id, customAttributes=custom_attributes)
            if stix_entity is None:
                self.opencti.log(&#34;error&#34;, &#34;Cannot add Tag, entity not found&#34;)
                return False
            if tag_id in stix_entity[&#34;tagsIds&#34;]:
                return True
            else:
                self.opencti.log(
                    &#34;info&#34;, &#34;Adding Tag {&#34; + tag_id + &#34;} to Stix-Entity {&#34; + id + &#34;}&#34;
                )
                query = &#34;&#34;&#34;
                   mutation StixEntityAddRelation($id: ID!, $input: RelationAddInput) {
                       stixEntityEdit(id: $id) {
                            relationAdd(input: $input) {
                                id
                            }
                       }
                   }
                &#34;&#34;&#34;
                self.opencti.query(
                    query,
                    {
                        &#34;id&#34;: id,
                        &#34;input&#34;: {
                            &#34;fromRole&#34;: &#34;so&#34;,
                            &#34;toId&#34;: tag_id,
                            &#34;toRole&#34;: &#34;tagging&#34;,
                            &#34;through&#34;: &#34;tagged&#34;,
                        },
                    },
                )
                return True
        else:
            self.opencti.log(&#34;error&#34;, &#34;Missing parameters: id and tag_id&#34;)
            return False

    &#34;&#34;&#34;
        Add a External-Reference object to Stix-Entity object (object_marking_refs)

        :param id: the id of the Stix-Entity
        :param marking_definition_id: the id of the Marking-Definition
        :return Boolean
    &#34;&#34;&#34;

    def add_external_reference(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        stix_entity = kwargs.get(&#34;entity&#34;, None)
        external_reference_id = kwargs.get(&#34;external_reference_id&#34;, None)
        if id is not None and external_reference_id is not None:
            if stix_entity is None:
                custom_attributes = &#34;&#34;&#34;
                    id
                    externalReferences {
                        edges {
                            node {
                                id
                                entity_type
                                stix_id_key
                                source_name
                                description
                                url
                                hash
                                external_id
                                created
                                modified
                            }
                            relation {
                                id
                            }
                        }
                    }
                &#34;&#34;&#34;
                stix_entity = self.read(id=id, customAttributes=custom_attributes)
            if stix_entity is None:
                self.opencti.log(
                    &#34;error&#34;, &#34;Cannot add External-Reference, entity not found&#34;
                )
                return False
            if external_reference_id in stix_entity[&#34;externalReferencesIds&#34;]:
                return True
            else:
                self.opencti.log(
                    &#34;info&#34;,
                    &#34;Adding External-Reference {&#34;
                    + external_reference_id
                    + &#34;} to Stix-Entity {&#34;
                    + id
                    + &#34;}&#34;,
                )
                query = &#34;&#34;&#34;
                   mutation StixEntityAddRelation($id: ID!, $input: RelationAddInput) {
                       stixEntityEdit(id: $id) {
                            relationAdd(input: $input) {
                                id
                            }
                       }
                   }
                &#34;&#34;&#34;
                self.opencti.query(
                    query,
                    {
                        &#34;id&#34;: id,
                        &#34;input&#34;: {
                            &#34;fromRole&#34;: &#34;so&#34;,
                            &#34;toId&#34;: external_reference_id,
                            &#34;toRole&#34;: &#34;external_reference&#34;,
                            &#34;through&#34;: &#34;external_references&#34;,
                        },
                    },
                )
                return True
        else:
            self.opencti.log(
                &#34;error&#34;, &#34;Missing parameters: id and external_reference_id&#34;
            )
            return False

    &#34;&#34;&#34;
        Add a Kill-Chain-Phase object to Stix-Entity object (kill_chain_phases)

        :param id: the id of the Stix-Entity
        :param kill_chain_phase_id: the id of the Kill-Chain-Phase
        :return Boolean
    &#34;&#34;&#34;

    def add_kill_chain_phase(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        stix_entity = kwargs.get(&#34;entity&#34;, None)
        kill_chain_phase_id = kwargs.get(&#34;kill_chain_phase_id&#34;, None)
        if id is not None and kill_chain_phase_id is not None:
            if stix_entity is None:
                stix_entity = self.read(id=id)
            if stix_entity is None:
                self.opencti.log(
                    &#34;error&#34;, &#34;Cannot add Kill-Chain-Phase, entity not found&#34;
                )
                return False
            if kill_chain_phase_id in stix_entity[&#34;killChainPhasesIds&#34;]:
                return True
            else:
                self.opencti.log(
                    &#34;info&#34;,
                    &#34;Adding Kill-Chain-Phase {&#34;
                    + kill_chain_phase_id
                    + &#34;} to Stix-Entity {&#34;
                    + id
                    + &#34;}&#34;,
                )
                query = &#34;&#34;&#34;
                   mutation StixEntityAddRelation($id: ID!, $input: RelationAddInput) {
                       stixEntityEdit(id: $id) {
                            relationAdd(input: $input) {
                                id
                            }
                       }
                   }
                &#34;&#34;&#34;
                self.opencti.query(
                    query,
                    {
                        &#34;id&#34;: id,
                        &#34;input&#34;: {
                            &#34;fromRole&#34;: &#34;phase_belonging&#34;,
                            &#34;toId&#34;: kill_chain_phase_id,
                            &#34;toRole&#34;: &#34;kill_chain_phase&#34;,
                            &#34;through&#34;: &#34;kill_chain_phases&#34;,
                        },
                    },
                )
                return True
        else:
            self.opencti.log(&#34;error&#34;, &#34;Missing parameters: id and kill_chain_phase_id&#34;)
            return False

    &#34;&#34;&#34;
        Get the reports about a Stix-Entity object

        :param id: the id of the Stix-Entity
        :return Stix-Entity object
    &#34;&#34;&#34;

    def reports(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        if id is not None:
            self.opencti.log(&#34;info&#34;, &#34;Getting reports of the Stix-Entity {&#34; + id + &#34;}.&#34;)
            query = &#34;&#34;&#34;
                query StixEntity($id: String!) {
                    stixEntity(id: $id) {
                        reports {
                            edges {
                                node {
                                    id
                                    stix_id_key
                                    entity_type
                                    stix_label
                                    name
                                    alias
                                    description
                                    report_class
                                    published
                                    object_status
                                    source_confidence_level
                                    graph_data
                                    created
                                    modified
                                    created_at
                                    updated_at
                                    createdByRef {
                                        node {
                                            id
                                            entity_type
                                            stix_id_key
                                            stix_label
                                            name
                                            alias
                                            description
                                            created
                                            modified
                                        }
                                        relation {
                                            id
                                        }
                                    }
                                    markingDefinitions {
                                        edges {
                                            node {
                                                id
                                                entity_type
                                                stix_id_key
                                                definition_type
                                                definition
                                                level
                                                color
                                                created
                                                modified
                                            }
                                            relation {
                                                id
                                            }
                                        }
                                    }
                                    tags {
                                        edges {
                                            node {
                                                id
                                                tag_type
                                                value
                                                color
                                            }
                                            relation {
                                                id
                                            }
                                        }
                                    }            
                                    externalReferences {
                                        edges {
                                            node {
                                                id
                                                entity_type
                                                stix_id_key
                                                source_name
                                                description
                                                url
                                                hash
                                                external_id
                                                created
                                                modified
                                            }
                                            relation {
                                                id
                                            }
                                        }
                                    }
                                    objectRefs {
                                        edges {
                                            node {
                                                id
                                                stix_id_key
                                                entity_type
                                            }
                                            relation {
                                                id
                                            }
                                        }
                                    }
                                    observableRefs {
                                        edges {
                                            node {
                                                id
                                                stix_id_key
                                                entity_type
                                                observable_value
                                            }
                                            relation {
                                                id
                                            }
                                        }
                                    }
                                    relationRefs {
                                        edges {
                                            node {
                                                id
                                                stix_id_key
                                            }
                                            relation {
                                                id
                                            }
                                        }
                                    }
                                }
                                relation {
                                    id
                                }
                            }
                        }
                    }
                }
             &#34;&#34;&#34;
            result = self.opencti.query(query, {&#34;id&#34;: id})
            processed_result = self.opencti.process_multiple_fields(
                result[&#34;data&#34;][&#34;stixEntity&#34;]
            )
            return processed_result[&#34;reports&#34;]
        else:
            self.opencti.log(&#34;error&#34;, &#34;Missing parameters: id&#34;)
            return None</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pycti.StixEntity.add_external_reference"><code class="name flex">
<span>def <span class="ident">add_external_reference</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_external_reference(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    stix_entity = kwargs.get(&#34;entity&#34;, None)
    external_reference_id = kwargs.get(&#34;external_reference_id&#34;, None)
    if id is not None and external_reference_id is not None:
        if stix_entity is None:
            custom_attributes = &#34;&#34;&#34;
                id
                externalReferences {
                    edges {
                        node {
                            id
                            entity_type
                            stix_id_key
                            source_name
                            description
                            url
                            hash
                            external_id
                            created
                            modified
                        }
                        relation {
                            id
                        }
                    }
                }
            &#34;&#34;&#34;
            stix_entity = self.read(id=id, customAttributes=custom_attributes)
        if stix_entity is None:
            self.opencti.log(
                &#34;error&#34;, &#34;Cannot add External-Reference, entity not found&#34;
            )
            return False
        if external_reference_id in stix_entity[&#34;externalReferencesIds&#34;]:
            return True
        else:
            self.opencti.log(
                &#34;info&#34;,
                &#34;Adding External-Reference {&#34;
                + external_reference_id
                + &#34;} to Stix-Entity {&#34;
                + id
                + &#34;}&#34;,
            )
            query = &#34;&#34;&#34;
               mutation StixEntityAddRelation($id: ID!, $input: RelationAddInput) {
                   stixEntityEdit(id: $id) {
                        relationAdd(input: $input) {
                            id
                        }
                   }
               }
            &#34;&#34;&#34;
            self.opencti.query(
                query,
                {
                    &#34;id&#34;: id,
                    &#34;input&#34;: {
                        &#34;fromRole&#34;: &#34;so&#34;,
                        &#34;toId&#34;: external_reference_id,
                        &#34;toRole&#34;: &#34;external_reference&#34;,
                        &#34;through&#34;: &#34;external_references&#34;,
                    },
                },
            )
            return True
    else:
        self.opencti.log(
            &#34;error&#34;, &#34;Missing parameters: id and external_reference_id&#34;
        )
        return False</code></pre>
</details>
</dd>
<dt id="pycti.StixEntity.add_kill_chain_phase"><code class="name flex">
<span>def <span class="ident">add_kill_chain_phase</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_kill_chain_phase(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    stix_entity = kwargs.get(&#34;entity&#34;, None)
    kill_chain_phase_id = kwargs.get(&#34;kill_chain_phase_id&#34;, None)
    if id is not None and kill_chain_phase_id is not None:
        if stix_entity is None:
            stix_entity = self.read(id=id)
        if stix_entity is None:
            self.opencti.log(
                &#34;error&#34;, &#34;Cannot add Kill-Chain-Phase, entity not found&#34;
            )
            return False
        if kill_chain_phase_id in stix_entity[&#34;killChainPhasesIds&#34;]:
            return True
        else:
            self.opencti.log(
                &#34;info&#34;,
                &#34;Adding Kill-Chain-Phase {&#34;
                + kill_chain_phase_id
                + &#34;} to Stix-Entity {&#34;
                + id
                + &#34;}&#34;,
            )
            query = &#34;&#34;&#34;
               mutation StixEntityAddRelation($id: ID!, $input: RelationAddInput) {
                   stixEntityEdit(id: $id) {
                        relationAdd(input: $input) {
                            id
                        }
                   }
               }
            &#34;&#34;&#34;
            self.opencti.query(
                query,
                {
                    &#34;id&#34;: id,
                    &#34;input&#34;: {
                        &#34;fromRole&#34;: &#34;phase_belonging&#34;,
                        &#34;toId&#34;: kill_chain_phase_id,
                        &#34;toRole&#34;: &#34;kill_chain_phase&#34;,
                        &#34;through&#34;: &#34;kill_chain_phases&#34;,
                    },
                },
            )
            return True
    else:
        self.opencti.log(&#34;error&#34;, &#34;Missing parameters: id and kill_chain_phase_id&#34;)
        return False</code></pre>
</details>
</dd>
<dt id="pycti.StixEntity.add_marking_definition"><code class="name flex">
<span>def <span class="ident">add_marking_definition</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_marking_definition(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    stix_entity = kwargs.get(&#34;entity&#34;, None)
    marking_definition_id = kwargs.get(&#34;marking_definition_id&#34;, None)
    if id is not None and marking_definition_id is not None:
        if stix_entity is None:
            custom_attributes = &#34;&#34;&#34;
                id
                markingDefinitions {
                    edges {
                        node {
                            id
                            entity_type
                            stix_id_key
                            definition_type
                            definition
                            level
                            color
                            created
                            modified
                        }
                        relation {
                            id
                        }
                    }
                }
            &#34;&#34;&#34;
            stix_entity = self.read(id=id, customAttributes=custom_attributes)
        if stix_entity is None:
            self.opencti.log(
                &#34;error&#34;, &#34;Cannot add Marking-Definition, entity not found&#34;
            )
            return False
        if marking_definition_id in stix_entity[&#34;markingDefinitionsIds&#34;]:
            return True
        else:
            self.opencti.log(
                &#34;info&#34;,
                &#34;Adding Marking-Definition {&#34;
                + marking_definition_id
                + &#34;} to Stix-Entity {&#34;
                + id
                + &#34;}&#34;,
            )
            query = &#34;&#34;&#34;
               mutation StixEntityAddRelation($id: ID!, $input: RelationAddInput) {
                   stixEntityEdit(id: $id) {
                        relationAdd(input: $input) {
                            id
                        }
                   }
               }
            &#34;&#34;&#34;
            self.opencti.query(
                query,
                {
                    &#34;id&#34;: id,
                    &#34;input&#34;: {
                        &#34;fromRole&#34;: &#34;so&#34;,
                        &#34;toId&#34;: marking_definition_id,
                        &#34;toRole&#34;: &#34;marking&#34;,
                        &#34;through&#34;: &#34;object_marking_refs&#34;,
                    },
                },
            )
            return True
    else:
        self.opencti.log(
            &#34;error&#34;, &#34;Missing parameters: id and marking_definition_id&#34;
        )
        return False</code></pre>
</details>
</dd>
<dt id="pycti.StixEntity.add_tag"><code class="name flex">
<span>def <span class="ident">add_tag</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_tag(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    stix_entity = kwargs.get(&#34;entity&#34;, None)
    tag_id = kwargs.get(&#34;tag_id&#34;, None)
    if id is not None and tag_id is not None:
        if stix_entity is None:
            custom_attributes = &#34;&#34;&#34;
                id
                tags {
                    edges {
                        node {
                            id
                            tag_type
                            value
                            color
                        }
                        relation {
                            id
                        }
                    }
                }
            &#34;&#34;&#34;
            stix_entity = self.read(id=id, customAttributes=custom_attributes)
        if stix_entity is None:
            self.opencti.log(&#34;error&#34;, &#34;Cannot add Tag, entity not found&#34;)
            return False
        if tag_id in stix_entity[&#34;tagsIds&#34;]:
            return True
        else:
            self.opencti.log(
                &#34;info&#34;, &#34;Adding Tag {&#34; + tag_id + &#34;} to Stix-Entity {&#34; + id + &#34;}&#34;
            )
            query = &#34;&#34;&#34;
               mutation StixEntityAddRelation($id: ID!, $input: RelationAddInput) {
                   stixEntityEdit(id: $id) {
                        relationAdd(input: $input) {
                            id
                        }
                   }
               }
            &#34;&#34;&#34;
            self.opencti.query(
                query,
                {
                    &#34;id&#34;: id,
                    &#34;input&#34;: {
                        &#34;fromRole&#34;: &#34;so&#34;,
                        &#34;toId&#34;: tag_id,
                        &#34;toRole&#34;: &#34;tagging&#34;,
                        &#34;through&#34;: &#34;tagged&#34;,
                    },
                },
            )
            return True
    else:
        self.opencti.log(&#34;error&#34;, &#34;Missing parameters: id and tag_id&#34;)
        return False</code></pre>
</details>
</dd>
<dt id="pycti.StixEntity.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    custom_attributes = kwargs.get(&#34;customAttributes&#34;, None)
    if id is not None:
        self.opencti.log(&#34;info&#34;, &#34;Reading Stix-Entity {&#34; + id + &#34;}.&#34;)
        query = (
            &#34;&#34;&#34;
            query StixEntity($id: String!) {
                stixEntity(id: $id) {
                    &#34;&#34;&#34;
            + (
                custom_attributes
                if custom_attributes is not None
                else self.properties
            )
            + &#34;&#34;&#34;
                }
            }
         &#34;&#34;&#34;
        )
        result = self.opencti.query(query, {&#34;id&#34;: id})
        return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;stixEntity&#34;])
    else:
        self.opencti.log(&#34;error&#34;, &#34;Missing parameters: id&#34;)
        return None</code></pre>
</details>
</dd>
<dt id="pycti.StixEntity.reports"><code class="name flex">
<span>def <span class="ident">reports</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reports(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    if id is not None:
        self.opencti.log(&#34;info&#34;, &#34;Getting reports of the Stix-Entity {&#34; + id + &#34;}.&#34;)
        query = &#34;&#34;&#34;
            query StixEntity($id: String!) {
                stixEntity(id: $id) {
                    reports {
                        edges {
                            node {
                                id
                                stix_id_key
                                entity_type
                                stix_label
                                name
                                alias
                                description
                                report_class
                                published
                                object_status
                                source_confidence_level
                                graph_data
                                created
                                modified
                                created_at
                                updated_at
                                createdByRef {
                                    node {
                                        id
                                        entity_type
                                        stix_id_key
                                        stix_label
                                        name
                                        alias
                                        description
                                        created
                                        modified
                                    }
                                    relation {
                                        id
                                    }
                                }
                                markingDefinitions {
                                    edges {
                                        node {
                                            id
                                            entity_type
                                            stix_id_key
                                            definition_type
                                            definition
                                            level
                                            color
                                            created
                                            modified
                                        }
                                        relation {
                                            id
                                        }
                                    }
                                }
                                tags {
                                    edges {
                                        node {
                                            id
                                            tag_type
                                            value
                                            color
                                        }
                                        relation {
                                            id
                                        }
                                    }
                                }            
                                externalReferences {
                                    edges {
                                        node {
                                            id
                                            entity_type
                                            stix_id_key
                                            source_name
                                            description
                                            url
                                            hash
                                            external_id
                                            created
                                            modified
                                        }
                                        relation {
                                            id
                                        }
                                    }
                                }
                                objectRefs {
                                    edges {
                                        node {
                                            id
                                            stix_id_key
                                            entity_type
                                        }
                                        relation {
                                            id
                                        }
                                    }
                                }
                                observableRefs {
                                    edges {
                                        node {
                                            id
                                            stix_id_key
                                            entity_type
                                            observable_value
                                        }
                                        relation {
                                            id
                                        }
                                    }
                                }
                                relationRefs {
                                    edges {
                                        node {
                                            id
                                            stix_id_key
                                        }
                                        relation {
                                            id
                                        }
                                    }
                                }
                            }
                            relation {
                                id
                            }
                        }
                    }
                }
            }
         &#34;&#34;&#34;
        result = self.opencti.query(query, {&#34;id&#34;: id})
        processed_result = self.opencti.process_multiple_fields(
            result[&#34;data&#34;][&#34;stixEntity&#34;]
        )
        return processed_result[&#34;reports&#34;]
    else:
        self.opencti.log(&#34;error&#34;, &#34;Missing parameters: id&#34;)
        return None</code></pre>
</details>
</dd>
<dt id="pycti.StixEntity.update_created_by_ref"><code class="name flex">
<span>def <span class="ident">update_created_by_ref</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_created_by_ref(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    stix_entity = kwargs.get(&#34;entity&#34;, None)
    identity_id = kwargs.get(&#34;identity_id&#34;, None)
    if id is not None and identity_id is not None:
        if stix_entity is None:
            custom_attributes = &#34;&#34;&#34;
                id
                createdByRef {
                    node {
                        id
                        entity_type
                        stix_id_key
                        stix_label
                        name
                        alias
                        description
                        created
                        modified
                        ... on Organization {
                            organization_class
                        }
                    }
                    relation {
                        id
                    }
                }    
            &#34;&#34;&#34;
            stix_entity = self.read(id=id, customAttributes=custom_attributes)
        if stix_entity is None:
            self.opencti.log(
                &#34;error&#34;, &#34;Cannot update created_by_ref, entity not found&#34;
            )
            return False
        current_identity_id = None
        current_relation_id = None
        if stix_entity[&#34;createdByRef&#34;] is not None:
            current_identity_id = stix_entity[&#34;createdByRef&#34;][&#34;id&#34;]
            current_relation_id = stix_entity[&#34;createdByRef&#34;][&#34;remote_relation_id&#34;]
        # Current identity is the same
        if current_identity_id == identity_id:
            return True
        else:
            self.opencti.log(
                &#34;info&#34;,
                &#34;Updating author of Stix-Entity {&#34;
                + id
                + &#34;} with Identity {&#34;
                + identity_id
                + &#34;}&#34;,
            )
            # Current identity is different, delete the old relation
            if current_relation_id is not None:
                query = &#34;&#34;&#34;
                    mutation StixEntityEdit($id: ID!, $relationId: ID!) {
                        stixEntityEdit(id: $id) {
                            relationDelete(relationId: $relationId) {
                                id
                            }
                        }
                    }
                &#34;&#34;&#34;
                self.opencti.query(
                    query, {&#34;id&#34;: id, &#34;relationId&#34;: current_relation_id}
                )
            # Add the new relation
            query = &#34;&#34;&#34;
               mutation StixEntityEdit($id: ID!, $input: RelationAddInput) {
                   stixEntityEdit(id: $id) {
                        relationAdd(input: $input) {
                            id
                        }
                   }
               }
            &#34;&#34;&#34;
            variables = {
                &#34;id&#34;: id,
                &#34;input&#34;: {
                    &#34;fromRole&#34;: &#34;so&#34;,
                    &#34;toId&#34;: identity_id,
                    &#34;toRole&#34;: &#34;creator&#34;,
                    &#34;through&#34;: &#34;created_by_ref&#34;,
                },
            }
            self.opencti.query(query, variables)

    else:
        self.opencti.log(&#34;error&#34;, &#34;Missing parameters: id and identity_id&#34;)
        return False</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pycti.StixObservable"><code class="flex name class">
<span>class <span class="ident">StixObservable</span></span>
<span>(</span><span>opencti)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StixObservable:
    def __init__(self, opencti):
        self.opencti = opencti
        self.properties = &#34;&#34;&#34;
            id
            stix_id_key
            entity_type
            name
            description
            observable_value
            created_at
            updated_at
            createdByRef {
                node {
                    id
                    entity_type
                    stix_id_key
                    stix_label
                    name
                    alias
                    description
                    created
                    modified
                    ... on Organization {
                        organization_class
                    }
                }
                relation {
                    id
                }
            }
            tags {
                edges {
                    node {
                        id
                        tag_type
                        value
                        color
                    }
                    relation {
                        id
                    }
                }
            }            
            markingDefinitions {
                edges {
                    node {
                        id
                        entity_type
                        stix_id_key
                        definition_type
                        definition
                        level
                        color
                        created
                        modified
                    }
                    relation {
                       id
                    }
                }
            }
            externalReferences {
                edges {
                    node {
                        id
                        entity_type
                        stix_id_key
                        source_name
                        description
                        url
                        hash
                        external_id
                        created
                        modified
                    }
                    relation {
                        id
                    }
                }
            }            
            indicators {
                edges {
                    node {
                        id
                        entity_type
                        stix_id_key
                        valid_from
                        valid_until
                        score
                        pattern_type
                        indicator_pattern
                        created
                        modified
                    }
                    relation {
                        id
                    }
                }
            }
        &#34;&#34;&#34;

    &#34;&#34;&#34;
        List StixObservable objects

        :param types: the array of types
        :param filters: the filters to apply
        :param search: the search keyword
        :param first: return the first n rows from the after ID (or the beginning if not set)
        :param after: ID of the first row
        :return List of StixObservable objects
    &#34;&#34;&#34;

    def list(self, **kwargs):
        types = kwargs.get(&#34;types&#34;, None)
        filters = kwargs.get(&#34;filters&#34;, None)
        search = kwargs.get(&#34;search&#34;, None)
        first = kwargs.get(&#34;first&#34;, 500)
        after = kwargs.get(&#34;after&#34;, None)
        order_by = kwargs.get(&#34;orderBy&#34;, None)
        order_mode = kwargs.get(&#34;orderMode&#34;, None)
        get_all = kwargs.get(&#34;getAll&#34;, False)
        if get_all:
            first = 500

        self.opencti.log(
            &#34;info&#34;, &#34;Listing StixObservables with filters &#34; + json.dumps(filters) + &#34;.&#34;
        )
        query = (
            &#34;&#34;&#34;
            query StixObservables($types: [String], $filters: [StixObservablesFiltering], $search: String, $first: Int, $after: ID, $orderBy: StixObservablesOrdering, $orderMode: OrderingMode) {
                stixObservables(types: $types, filters: $filters, search: $search, first: $first, after: $after, orderBy: $orderBy, orderMode: $orderMode) {
                    edges {
                        node {
                            &#34;&#34;&#34;
            + self.properties
            + &#34;&#34;&#34;
                        }
                    }
                    pageInfo {
                        startCursor
                        endCursor
                        hasNextPage
                        hasPreviousPage
                        globalCount
                    }                    
                }
            }
        &#34;&#34;&#34;
        )
        result = self.opencti.query(
            query,
            {
                &#34;types&#34;: types,
                &#34;filters&#34;: filters,
                &#34;search&#34;: search,
                &#34;first&#34;: first,
                &#34;after&#34;: after,
                &#34;orderBy&#34;: order_by,
                &#34;orderMode&#34;: order_mode,
            },
        )

        if get_all:
            final_data = []
            data = self.opencti.process_multiple(result[&#34;data&#34;][&#34;stixObservables&#34;])
            final_data = final_data + data
            while result[&#34;data&#34;][&#34;stixObservables&#34;][&#34;pageInfo&#34;][&#34;hasNextPage&#34;]:
                after = result[&#34;data&#34;][&#34;stixObservables&#34;][&#34;pageInfo&#34;][&#34;endCursor&#34;]
                self.opencti.log(&#34;info&#34;, &#34;Listing StixObservables after &#34; + after)
                result = self.opencti.query(
                    query,
                    {
                        &#34;types&#34;: types,
                        &#34;filters&#34;: filters,
                        &#34;search&#34;: search,
                        &#34;first&#34;: first,
                        &#34;after&#34;: after,
                        &#34;orderBy&#34;: order_by,
                        &#34;orderMode&#34;: order_mode,
                    },
                )
                data = self.opencti.process_multiple(result[&#34;data&#34;][&#34;stixObservables&#34;])
                final_data = final_data + data
            return final_data
        else:
            return self.opencti.process_multiple(result[&#34;data&#34;][&#34;stixObservables&#34;])

    &#34;&#34;&#34;
        Read a StixObservable object

        :param id: the id of the StixObservable
        :param filters: the filters to apply if no id provided
        :return StixObservable object
    &#34;&#34;&#34;

    def read(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        filters = kwargs.get(&#34;filters&#34;, None)
        custom_attributes = kwargs.get(&#34;customAttributes&#34;, None)
        if id is not None:
            self.opencti.log(&#34;info&#34;, &#34;Reading StixObservable {&#34; + id + &#34;}.&#34;)
            query = (
                &#34;&#34;&#34;
                query StixObservable($id: String!) {
                    stixObservable(id: $id) {
                        &#34;&#34;&#34;
                + (
                    custom_attributes
                    if custom_attributes is not None
                    else self.properties
                )
                + &#34;&#34;&#34;
                    }
                }
             &#34;&#34;&#34;
            )
            result = self.opencti.query(query, {&#34;id&#34;: id})
            return self.opencti.process_multiple_fields(
                result[&#34;data&#34;][&#34;stixObservable&#34;]
            )
        elif filters is not None:
            result = self.list(filters=filters)
            if len(result) &gt; 0:
                return result[0]
            else:
                return None
        else:
            self.opencti.log(
                &#34;error&#34;, &#34;[opencti_stix_observable] Missing parameters: id or filters&#34;
            )
            return None

    &#34;&#34;&#34;
        Create a Stix-Observable object

        :param type: the type of the Observable
        :return Stix-Observable object
    &#34;&#34;&#34;

    def create_raw(self, **kwargs):
        type = kwargs.get(&#34;type&#34;, None)
        observable_value = kwargs.get(&#34;observable_value&#34;, None)
        description = kwargs.get(&#34;description&#34;, None)
        id = kwargs.get(&#34;id&#34;, None)
        stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
        created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
        marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)
        create_indicator = kwargs.get(&#34;createIndicator&#34;, False)

        if type is not None and observable_value is not None:
            self.opencti.log(
                &#34;info&#34;,
                &#34;Creating Stix-Observable {&#34;
                + observable_value
                + &#34;} with indicator at &#34;
                + str(create_indicator)
                + &#34;.&#34;,
            )
            query = (
                &#34;&#34;&#34;
               mutation StixObservableAdd($input: StixObservableAddInput) {
                   stixObservableAdd(input: $input) {
                       &#34;&#34;&#34;
                + self.properties
                + &#34;&#34;&#34;
                   }
               }
            &#34;&#34;&#34;
            )
            result = self.opencti.query(
                query,
                {
                    &#34;input&#34;: {
                        &#34;type&#34;: type,
                        &#34;observable_value&#34;: observable_value,
                        &#34;description&#34;: description,
                        &#34;internal_id_key&#34;: id,
                        &#34;stix_id_key&#34;: stix_id_key,
                        &#34;createdByRef&#34;: created_by_ref,
                        &#34;markingDefinitions&#34;: marking_definitions,
                        &#34;createIndicator&#34;: create_indicator,
                    }
                },
            )
            return self.opencti.process_multiple_fields(
                result[&#34;data&#34;][&#34;stixObservableAdd&#34;]
            )
        else:
            self.opencti.log(&#34;error&#34;, &#34;Missing parameters: type and observable_value&#34;)

    &#34;&#34;&#34;
        Create a Stix-Observable object only if it not exists, update it on request

        :param name: the name of the Stix-Observable
        :return Stix-Observable object
    &#34;&#34;&#34;

    def create(self, **kwargs):
        type = kwargs.get(&#34;type&#34;, None)
        observable_value = kwargs.get(&#34;observable_value&#34;, None)
        description = kwargs.get(&#34;description&#34;, None)
        id = kwargs.get(&#34;id&#34;, None)
        stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
        created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
        marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)
        create_indicator = kwargs.get(&#34;createIndicator&#34;, False)
        update = kwargs.get(&#34;update&#34;, False)
        custom_attributes = &#34;&#34;&#34;
            id
            entity_type
            description 
        &#34;&#34;&#34;
        object_result = self.read(
            filters=[{&#34;key&#34;: &#34;observable_value&#34;, &#34;values&#34;: [observable_value]}],
            customAttributes=custom_attributes,
        )
        if object_result is not None:
            if update:
                if (
                    description is not None
                    and object_result[&#34;description&#34;] != &#34;description&#34;
                ):
                    self.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;description&#34;, value=description
                    )
                    object_result[&#34;description&#34;] = description
            return object_result
        else:
            return self.create_raw(
                type=type,
                observable_value=observable_value,
                description=description,
                id=id,
                stix_id_key=stix_id_key,
                createdByRef=created_by_ref,
                markingDefinitions=marking_definitions,
                createIndicator=create_indicator,
            )

    &#34;&#34;&#34;
        Update a Stix-Observable object field

        :param id: the Stix-Observable id
        :param key: the key of the field
        :param value: the value of the field
        :return The updated Stix-Observable object
    &#34;&#34;&#34;

    def update_field(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        key = kwargs.get(&#34;key&#34;, None)
        value = kwargs.get(&#34;value&#34;, None)
        if id is not None and key is not None and value is not None:
            self.opencti.log(
                &#34;info&#34;, &#34;Updating Stix-Observable {&#34; + id + &#34;} field {&#34; + key + &#34;}.&#34;
            )
            query = &#34;&#34;&#34;
                mutation StixObservableEdit($id: ID!, $input: EditInput!) {
                    stixObservableEdit(id: $id) {
                        fieldPatch(input: $input) {
                            id
                        }
                    }
                }
            &#34;&#34;&#34;
            result = self.opencti.query(
                query, {&#34;id&#34;: id, &#34;input&#34;: {&#34;key&#34;: key, &#34;value&#34;: value}}
            )
            return self.opencti.process_multiple_fields(
                result[&#34;data&#34;][&#34;stixObservableEdit&#34;][&#34;fieldPatch&#34;]
            )
        else:
            self.opencti.log(
                &#34;error&#34;,
                &#34;[opencti_stix_observable_update_field] Missing parameters: id and key and value&#34;,
            )
            return None

    &#34;&#34;&#34;
        Delete a Stix-Observable

        :param id: the Stix-Observable id
        :return void
    &#34;&#34;&#34;

    def delete(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        if id is not None:
            self.opencti.log(&#34;info&#34;, &#34;Deleting Stix-Observable {&#34; + id + &#34;}.&#34;)
            query = &#34;&#34;&#34;
                 mutation StixObservableEdit($id: ID!) {
                     stixObservableEdit(id: $id) {
                         delete
                     }
                 }
             &#34;&#34;&#34;
            self.opencti.query(query, {&#34;id&#34;: id})
        else:
            self.opencti.log(
                &#34;error&#34;, &#34;[opencti_stix_observable_delete] Missing parameters: id&#34;
            )
            return None

    &#34;&#34;&#34;
        Update the Identity author of a Stix-Observable object (created_by_ref)

        :param id: the id of the Stix-Observable
        :param identity_id: the id of the Identity
        :return Boolean
    &#34;&#34;&#34;

    def update_created_by_ref(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        stix_entity = kwargs.get(&#34;entity&#34;, None)
        identity_id = kwargs.get(&#34;identity_id&#34;, None)
        if id is not None and identity_id is not None:
            if stix_entity is None:
                custom_attributes = &#34;&#34;&#34;
                    id
                    createdByRef {
                        node {
                            id
                            entity_type
                            stix_id_key
                            stix_label
                            name
                            alias
                            description
                            created
                            modified
                            ... on Organization {
                                organization_class
                            }
                        }
                        relation {
                            id
                        }
                    }    
                &#34;&#34;&#34;
                stix_entity = self.read(id=id, customAttributes=custom_attributes)
            if stix_entity is None:
                self.opencti.log(
                    &#34;error&#34;, &#34;Cannot update created_by_ref, entity not found&#34;
                )
                return False
            current_identity_id = None
            current_relation_id = None
            if stix_entity[&#34;createdByRef&#34;] is not None:
                current_identity_id = stix_entity[&#34;createdByRef&#34;][&#34;id&#34;]
                current_relation_id = stix_entity[&#34;createdByRef&#34;][&#34;remote_relation_id&#34;]
            # Current identity is the same
            if current_identity_id == identity_id:
                return True
            else:
                self.opencti.log(
                    &#34;info&#34;,
                    &#34;Updating author of Stix-Entity {&#34;
                    + id
                    + &#34;} with Identity {&#34;
                    + identity_id
                    + &#34;}&#34;,
                )
                # Current identity is different, delete the old relation
                if current_relation_id is not None:
                    query = &#34;&#34;&#34;
                        mutation StixObservableEdit($id: ID!, $relationId: ID!) {
                            stixObservableEdit(id: $id) {
                                relationDelete(relationId: $relationId) {
                                    id
                                }
                            }
                        }
                    &#34;&#34;&#34;
                    self.opencti.query(
                        query, {&#34;id&#34;: id, &#34;relationId&#34;: current_relation_id}
                    )
                # Add the new relation
                query = &#34;&#34;&#34;
                   mutation StixObservableEdit($id: ID!, $input: RelationAddInput) {
                       stixObservableEdit(id: $id) {
                            relationAdd(input: $input) {
                                id
                            }
                       }
                   }
                &#34;&#34;&#34;
                variables = {
                    &#34;id&#34;: id,
                    &#34;input&#34;: {
                        &#34;fromRole&#34;: &#34;so&#34;,
                        &#34;toId&#34;: identity_id,
                        &#34;toRole&#34;: &#34;creator&#34;,
                        &#34;through&#34;: &#34;created_by_ref&#34;,
                    },
                }
                self.opencti.query(query, variables)

        else:
            self.opencti.log(&#34;error&#34;, &#34;Missing parameters: id and identity_id&#34;)
            return False</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pycti.StixObservable.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create(self, **kwargs):
    type = kwargs.get(&#34;type&#34;, None)
    observable_value = kwargs.get(&#34;observable_value&#34;, None)
    description = kwargs.get(&#34;description&#34;, None)
    id = kwargs.get(&#34;id&#34;, None)
    stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
    created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
    marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)
    create_indicator = kwargs.get(&#34;createIndicator&#34;, False)
    update = kwargs.get(&#34;update&#34;, False)
    custom_attributes = &#34;&#34;&#34;
        id
        entity_type
        description 
    &#34;&#34;&#34;
    object_result = self.read(
        filters=[{&#34;key&#34;: &#34;observable_value&#34;, &#34;values&#34;: [observable_value]}],
        customAttributes=custom_attributes,
    )
    if object_result is not None:
        if update:
            if (
                description is not None
                and object_result[&#34;description&#34;] != &#34;description&#34;
            ):
                self.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;description&#34;, value=description
                )
                object_result[&#34;description&#34;] = description
        return object_result
    else:
        return self.create_raw(
            type=type,
            observable_value=observable_value,
            description=description,
            id=id,
            stix_id_key=stix_id_key,
            createdByRef=created_by_ref,
            markingDefinitions=marking_definitions,
            createIndicator=create_indicator,
        )</code></pre>
</details>
</dd>
<dt id="pycti.StixObservable.create_raw"><code class="name flex">
<span>def <span class="ident">create_raw</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_raw(self, **kwargs):
    type = kwargs.get(&#34;type&#34;, None)
    observable_value = kwargs.get(&#34;observable_value&#34;, None)
    description = kwargs.get(&#34;description&#34;, None)
    id = kwargs.get(&#34;id&#34;, None)
    stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
    created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
    marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)
    create_indicator = kwargs.get(&#34;createIndicator&#34;, False)

    if type is not None and observable_value is not None:
        self.opencti.log(
            &#34;info&#34;,
            &#34;Creating Stix-Observable {&#34;
            + observable_value
            + &#34;} with indicator at &#34;
            + str(create_indicator)
            + &#34;.&#34;,
        )
        query = (
            &#34;&#34;&#34;
           mutation StixObservableAdd($input: StixObservableAddInput) {
               stixObservableAdd(input: $input) {
                   &#34;&#34;&#34;
            + self.properties
            + &#34;&#34;&#34;
               }
           }
        &#34;&#34;&#34;
        )
        result = self.opencti.query(
            query,
            {
                &#34;input&#34;: {
                    &#34;type&#34;: type,
                    &#34;observable_value&#34;: observable_value,
                    &#34;description&#34;: description,
                    &#34;internal_id_key&#34;: id,
                    &#34;stix_id_key&#34;: stix_id_key,
                    &#34;createdByRef&#34;: created_by_ref,
                    &#34;markingDefinitions&#34;: marking_definitions,
                    &#34;createIndicator&#34;: create_indicator,
                }
            },
        )
        return self.opencti.process_multiple_fields(
            result[&#34;data&#34;][&#34;stixObservableAdd&#34;]
        )
    else:
        self.opencti.log(&#34;error&#34;, &#34;Missing parameters: type and observable_value&#34;)</code></pre>
</details>
</dd>
<dt id="pycti.StixObservable.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    if id is not None:
        self.opencti.log(&#34;info&#34;, &#34;Deleting Stix-Observable {&#34; + id + &#34;}.&#34;)
        query = &#34;&#34;&#34;
             mutation StixObservableEdit($id: ID!) {
                 stixObservableEdit(id: $id) {
                     delete
                 }
             }
         &#34;&#34;&#34;
        self.opencti.query(query, {&#34;id&#34;: id})
    else:
        self.opencti.log(
            &#34;error&#34;, &#34;[opencti_stix_observable_delete] Missing parameters: id&#34;
        )
        return None</code></pre>
</details>
</dd>
<dt id="pycti.StixObservable.list"><code class="name flex">
<span>def <span class="ident">list</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list(self, **kwargs):
    types = kwargs.get(&#34;types&#34;, None)
    filters = kwargs.get(&#34;filters&#34;, None)
    search = kwargs.get(&#34;search&#34;, None)
    first = kwargs.get(&#34;first&#34;, 500)
    after = kwargs.get(&#34;after&#34;, None)
    order_by = kwargs.get(&#34;orderBy&#34;, None)
    order_mode = kwargs.get(&#34;orderMode&#34;, None)
    get_all = kwargs.get(&#34;getAll&#34;, False)
    if get_all:
        first = 500

    self.opencti.log(
        &#34;info&#34;, &#34;Listing StixObservables with filters &#34; + json.dumps(filters) + &#34;.&#34;
    )
    query = (
        &#34;&#34;&#34;
        query StixObservables($types: [String], $filters: [StixObservablesFiltering], $search: String, $first: Int, $after: ID, $orderBy: StixObservablesOrdering, $orderMode: OrderingMode) {
            stixObservables(types: $types, filters: $filters, search: $search, first: $first, after: $after, orderBy: $orderBy, orderMode: $orderMode) {
                edges {
                    node {
                        &#34;&#34;&#34;
        + self.properties
        + &#34;&#34;&#34;
                    }
                }
                pageInfo {
                    startCursor
                    endCursor
                    hasNextPage
                    hasPreviousPage
                    globalCount
                }                    
            }
        }
    &#34;&#34;&#34;
    )
    result = self.opencti.query(
        query,
        {
            &#34;types&#34;: types,
            &#34;filters&#34;: filters,
            &#34;search&#34;: search,
            &#34;first&#34;: first,
            &#34;after&#34;: after,
            &#34;orderBy&#34;: order_by,
            &#34;orderMode&#34;: order_mode,
        },
    )

    if get_all:
        final_data = []
        data = self.opencti.process_multiple(result[&#34;data&#34;][&#34;stixObservables&#34;])
        final_data = final_data + data
        while result[&#34;data&#34;][&#34;stixObservables&#34;][&#34;pageInfo&#34;][&#34;hasNextPage&#34;]:
            after = result[&#34;data&#34;][&#34;stixObservables&#34;][&#34;pageInfo&#34;][&#34;endCursor&#34;]
            self.opencti.log(&#34;info&#34;, &#34;Listing StixObservables after &#34; + after)
            result = self.opencti.query(
                query,
                {
                    &#34;types&#34;: types,
                    &#34;filters&#34;: filters,
                    &#34;search&#34;: search,
                    &#34;first&#34;: first,
                    &#34;after&#34;: after,
                    &#34;orderBy&#34;: order_by,
                    &#34;orderMode&#34;: order_mode,
                },
            )
            data = self.opencti.process_multiple(result[&#34;data&#34;][&#34;stixObservables&#34;])
            final_data = final_data + data
        return final_data
    else:
        return self.opencti.process_multiple(result[&#34;data&#34;][&#34;stixObservables&#34;])</code></pre>
</details>
</dd>
<dt id="pycti.StixObservable.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    filters = kwargs.get(&#34;filters&#34;, None)
    custom_attributes = kwargs.get(&#34;customAttributes&#34;, None)
    if id is not None:
        self.opencti.log(&#34;info&#34;, &#34;Reading StixObservable {&#34; + id + &#34;}.&#34;)
        query = (
            &#34;&#34;&#34;
            query StixObservable($id: String!) {
                stixObservable(id: $id) {
                    &#34;&#34;&#34;
            + (
                custom_attributes
                if custom_attributes is not None
                else self.properties
            )
            + &#34;&#34;&#34;
                }
            }
         &#34;&#34;&#34;
        )
        result = self.opencti.query(query, {&#34;id&#34;: id})
        return self.opencti.process_multiple_fields(
            result[&#34;data&#34;][&#34;stixObservable&#34;]
        )
    elif filters is not None:
        result = self.list(filters=filters)
        if len(result) &gt; 0:
            return result[0]
        else:
            return None
    else:
        self.opencti.log(
            &#34;error&#34;, &#34;[opencti_stix_observable] Missing parameters: id or filters&#34;
        )
        return None</code></pre>
</details>
</dd>
<dt id="pycti.StixObservable.update_created_by_ref"><code class="name flex">
<span>def <span class="ident">update_created_by_ref</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_created_by_ref(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    stix_entity = kwargs.get(&#34;entity&#34;, None)
    identity_id = kwargs.get(&#34;identity_id&#34;, None)
    if id is not None and identity_id is not None:
        if stix_entity is None:
            custom_attributes = &#34;&#34;&#34;
                id
                createdByRef {
                    node {
                        id
                        entity_type
                        stix_id_key
                        stix_label
                        name
                        alias
                        description
                        created
                        modified
                        ... on Organization {
                            organization_class
                        }
                    }
                    relation {
                        id
                    }
                }    
            &#34;&#34;&#34;
            stix_entity = self.read(id=id, customAttributes=custom_attributes)
        if stix_entity is None:
            self.opencti.log(
                &#34;error&#34;, &#34;Cannot update created_by_ref, entity not found&#34;
            )
            return False
        current_identity_id = None
        current_relation_id = None
        if stix_entity[&#34;createdByRef&#34;] is not None:
            current_identity_id = stix_entity[&#34;createdByRef&#34;][&#34;id&#34;]
            current_relation_id = stix_entity[&#34;createdByRef&#34;][&#34;remote_relation_id&#34;]
        # Current identity is the same
        if current_identity_id == identity_id:
            return True
        else:
            self.opencti.log(
                &#34;info&#34;,
                &#34;Updating author of Stix-Entity {&#34;
                + id
                + &#34;} with Identity {&#34;
                + identity_id
                + &#34;}&#34;,
            )
            # Current identity is different, delete the old relation
            if current_relation_id is not None:
                query = &#34;&#34;&#34;
                    mutation StixObservableEdit($id: ID!, $relationId: ID!) {
                        stixObservableEdit(id: $id) {
                            relationDelete(relationId: $relationId) {
                                id
                            }
                        }
                    }
                &#34;&#34;&#34;
                self.opencti.query(
                    query, {&#34;id&#34;: id, &#34;relationId&#34;: current_relation_id}
                )
            # Add the new relation
            query = &#34;&#34;&#34;
               mutation StixObservableEdit($id: ID!, $input: RelationAddInput) {
                   stixObservableEdit(id: $id) {
                        relationAdd(input: $input) {
                            id
                        }
                   }
               }
            &#34;&#34;&#34;
            variables = {
                &#34;id&#34;: id,
                &#34;input&#34;: {
                    &#34;fromRole&#34;: &#34;so&#34;,
                    &#34;toId&#34;: identity_id,
                    &#34;toRole&#34;: &#34;creator&#34;,
                    &#34;through&#34;: &#34;created_by_ref&#34;,
                },
            }
            self.opencti.query(query, variables)

    else:
        self.opencti.log(&#34;error&#34;, &#34;Missing parameters: id and identity_id&#34;)
        return False</code></pre>
</details>
</dd>
<dt id="pycti.StixObservable.update_field"><code class="name flex">
<span>def <span class="ident">update_field</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_field(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    key = kwargs.get(&#34;key&#34;, None)
    value = kwargs.get(&#34;value&#34;, None)
    if id is not None and key is not None and value is not None:
        self.opencti.log(
            &#34;info&#34;, &#34;Updating Stix-Observable {&#34; + id + &#34;} field {&#34; + key + &#34;}.&#34;
        )
        query = &#34;&#34;&#34;
            mutation StixObservableEdit($id: ID!, $input: EditInput!) {
                stixObservableEdit(id: $id) {
                    fieldPatch(input: $input) {
                        id
                    }
                }
            }
        &#34;&#34;&#34;
        result = self.opencti.query(
            query, {&#34;id&#34;: id, &#34;input&#34;: {&#34;key&#34;: key, &#34;value&#34;: value}}
        )
        return self.opencti.process_multiple_fields(
            result[&#34;data&#34;][&#34;stixObservableEdit&#34;][&#34;fieldPatch&#34;]
        )
    else:
        self.opencti.log(
            &#34;error&#34;,
            &#34;[opencti_stix_observable_update_field] Missing parameters: id and key and value&#34;,
        )
        return None</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pycti.StixObservableRelation"><code class="flex name class">
<span>class <span class="ident">StixObservableRelation</span></span>
<span>(</span><span>opencti)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StixObservableRelation:
    def __init__(self, opencti):
        self.opencti = opencti
        self.properties = &#34;&#34;&#34;
            id
            stix_id_key
            entity_type
            relationship_type
            description
            weight
            role_played
            first_seen
            last_seen
            created
            modified
            created_at
            updated_at
            from {
                id
                stix_id_key
                entity_type
                observable_value
            }
            to {
                id
                stix_id_key
                entity_type
                observable_value
            }
            createdByRef {
                node {
                    id
                    entity_type
                    stix_id_key
                    stix_label
                    name
                    alias
                    description
                    created
                    modified
                }
                relation {
                    id
                }
            }
            markingDefinitions {
                edges {
                    node {
                        id
                        entity_type
                        stix_id_key
                        definition_type
                        definition
                        level
                        color
                        created
                        modified
                    }
                    relation {
                       id
                    }
                }
            }
            externalReferences {
                edges {
                    node {
                        id
                        entity_type
                        stix_id_key
                        source_name
                        description
                        url
                        hash
                        external_id
                        created
                        modified
                    }
                    relation {
                        id
                    }
                }
            }
        &#34;&#34;&#34;

    &#34;&#34;&#34;
        List stix_observable_relation objects

        :param fromId: the id of the source entity of the relation
        :param toId: the id of the target entity of the relation
        :param relationType: the relation type
        :param firstSeenStart: the first_seen date start filter
        :param firstSeenStop: the first_seen date stop filter
        :param lastSeenStart: the last_seen date start filter
        :param lastSeenStop: the last_seen date stop filter
        :param inferred: includes inferred relations
        :param first: return the first n rows from the after ID (or the beginning if not set)
        :param after: ID of the first row for pagination
        :return List of stix_observable_relation objects
    &#34;&#34;&#34;

    def list(self, **kwargs):
        from_id = kwargs.get(&#34;fromId&#34;, None)
        from_types = kwargs.get(&#34;fromTypes&#34;, None)
        to_id = kwargs.get(&#34;toId&#34;, None)
        to_types = kwargs.get(&#34;toTypes&#34;, None)
        relation_type = kwargs.get(&#34;relationType&#34;, None)
        first_seen_start = kwargs.get(&#34;firstSeenStart&#34;, None)
        first_seen_stop = kwargs.get(&#34;firstSeenStop&#34;, None)
        last_seen_start = kwargs.get(&#34;lastSeenStart&#34;, None)
        last_seen_stop = kwargs.get(&#34;lastSeenStop&#34;, None)
        inferred = kwargs.get(&#34;inferred&#34;, None)
        first = kwargs.get(&#34;first&#34;, 500)
        after = kwargs.get(&#34;after&#34;, None)
        order_by = kwargs.get(&#34;orderBy&#34;, None)
        order_mode = kwargs.get(&#34;orderMode&#34;, None)
        get_all = kwargs.get(&#34;getAll&#34;, False)
        force_natural = kwargs.get(&#34;forceNatural&#34;, False)

        if get_all:
            first = 500

        self.opencti.log(
            &#34;info&#34;,
            &#34;Listing stix_observable_relations with {type: &#34;
            + str(relation_type)
            + &#34;, from_id: &#34;
            + str(from_id)
            + &#34;, to_id: &#34;
            + str(to_id)
            + &#34;}&#34;,
        )
        query = (
            &#34;&#34;&#34;
            query StixObservableRelations($fromId: String, $fromTypes: [String], $toId: String, $toTypes: [String], $relationType: String, $firstSeenStart: DateTime, $firstSeenStop: DateTime, $lastSeenStart: DateTime, $lastSeenStop: DateTime, $inferred: Boolean, $first: Int, $after: ID, $orderBy: StixObservableRelationsOrdering, $orderMode: OrderingMode, $forceNatural: Boolean) {
                stixObservableRelations(fromId: $fromId, fromTypes: $fromTypes, toId: $toId, toTypes: $toTypes, relationType: $relationType, firstSeenStart: $firstSeenStart, firstSeenStop: $firstSeenStop, lastSeenStart: $lastSeenStart, lastSeenStop: $lastSeenStop, inferred: $inferred, first: $first, after: $after, orderBy: $orderBy, orderMode: $orderMode, forceNatural: $forceNatural) {
                    edges {
                        node {
                            &#34;&#34;&#34;
            + self.properties
            + &#34;&#34;&#34;
                        }
                    }
                    pageInfo {
                        startCursor
                        endCursor
                        hasNextPage
                        hasPreviousPage
                        globalCount
                    }
                }
            }
         &#34;&#34;&#34;
        )

        result = self.opencti.query(
            query,
            {
                &#34;fromId&#34;: from_id,
                &#34;fromTypes&#34;: from_types,
                &#34;toId&#34;: to_id,
                &#34;toTypes&#34;: to_types,
                &#34;relationType&#34;: relation_type,
                &#34;firstSeenStart&#34;: first_seen_start,
                &#34;firstSeenStop&#34;: first_seen_stop,
                &#34;lastSeenStart&#34;: last_seen_start,
                &#34;lastSeenStop&#34;: last_seen_stop,
                &#34;inferred&#34;: inferred,
                &#34;first&#34;: first,
                &#34;after&#34;: after,
                &#34;orderBy&#34;: order_by,
                &#34;orderMode&#34;: order_mode,
                &#34;forceNatural&#34;: force_natural,
            },
        )
        return self.opencti.process_multiple(result[&#34;data&#34;][&#34;stixObservableRelations&#34;])

    &#34;&#34;&#34;
        Read a stix_observable_relation object

        :param id: the id of the stix_observable_relation
        :param stix_id_key: the STIX id of the stix_observable_relation
        :param fromId: the id of the source entity of the relation
        :param toId: the id of the target entity of the relation
        :param relationType: the relation type
        :param firstSeenStart: the first_seen date start filter
        :param firstSeenStop: the first_seen date stop filter
        :param lastSeenStart: the last_seen date start filter
        :param lastSeenStop: the last_seen date stop filter
        :param inferred: includes inferred relations
        :return stix_observable_relation object
    &#34;&#34;&#34;

    def read(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        from_id = kwargs.get(&#34;fromId&#34;, None)
        to_id = kwargs.get(&#34;toId&#34;, None)
        relation_type = kwargs.get(&#34;relationType&#34;, None)
        first_seen_start = kwargs.get(&#34;firstSeenStart&#34;, None)
        first_seen_stop = kwargs.get(&#34;firstSeenStop&#34;, None)
        last_seen_start = kwargs.get(&#34;lastSeenStart&#34;, None)
        last_seen_stop = kwargs.get(&#34;lastSeenStop&#34;, None)
        inferred = kwargs.get(&#34;inferred&#34;, None)
        custom_attributes = kwargs.get(&#34;customAttributes&#34;, None)
        if id is not None:
            self.opencti.log(&#34;info&#34;, &#34;Reading stix_observable_relation {&#34; + id + &#34;}.&#34;)
            query = (
                &#34;&#34;&#34;
                query StixObservableRelation($id: String!) {
                    stixObservableRelation(id: $id) {
                        &#34;&#34;&#34;
                + (
                    custom_attributes
                    if custom_attributes is not None
                    else self.properties
                )
                + &#34;&#34;&#34;
                    }
                }
             &#34;&#34;&#34;
            )
            result = self.opencti.query(query, {&#34;id&#34;: id})
            return self.opencti.process_multiple_fields(
                result[&#34;data&#34;][&#34;stixObservableRelation&#34;]
            )
        else:
            result = self.list(
                fromId=from_id,
                toId=to_id,
                relationType=relation_type,
                firstSeenStart=first_seen_start,
                firstSeenStop=first_seen_stop,
                lastSeenStart=last_seen_start,
                lastSeenStop=last_seen_stop,
                inferred=inferred,
            )
            if len(result) &gt; 0:
                return result[0]
            else:
                return None

    &#34;&#34;&#34;
        Create a stix_observable_relation object

        :param from_id: id of the source entity
        :return stix_observable_relation object
    &#34;&#34;&#34;

    def create_raw(self, **kwargs):
        from_id = kwargs.get(&#34;fromId&#34;, None)
        from_role = kwargs.get(&#34;fromRole&#34;, None)
        to_id = kwargs.get(&#34;toId&#34;, None)
        to_role = kwargs.get(&#34;toRole&#34;, None)
        relationship_type = kwargs.get(&#34;relationship_type&#34;, None)
        description = kwargs.get(&#34;description&#34;, None)
        role_played = kwargs.get(&#34;role_played&#34;, None)
        first_seen = kwargs.get(&#34;first_seen&#34;, None)
        last_seen = kwargs.get(&#34;last_seen&#34;, None)
        weight = kwargs.get(&#34;weight&#34;, None)
        id = kwargs.get(&#34;id&#34;, None)
        stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
        created = kwargs.get(&#34;created&#34;, None)
        modified = kwargs.get(&#34;modified&#34;, None)
        created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
        marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)

        self.opencti.log(
            &#34;info&#34;,
            &#34;Creating stix_observable_relation {&#34;
            + from_role
            + &#34;: &#34;
            + from_id
            + &#34;, &#34;
            + to_role
            + &#34;: &#34;
            + to_id
            + &#34;}.&#34;,
        )
        query = (
            &#34;&#34;&#34;
                mutation StixObservableRelationAdd($input: StixObservableRelationAddInput!) {
                    stixObservableRelationAdd(input: $input) {
            &#34;&#34;&#34;
            + self.properties
            + &#34;&#34;&#34;
                        }
                    }
                &#34;&#34;&#34;
        )
        result = self.opencti.query(
            query,
            {
                &#34;input&#34;: {
                    &#34;fromId&#34;: from_id,
                    &#34;fromRole&#34;: from_role,
                    &#34;toId&#34;: to_id,
                    &#34;toRole&#34;: to_role,
                    &#34;relationship_type&#34;: relationship_type,
                    &#34;description&#34;: description,
                    &#34;role_played&#34;: role_played,
                    &#34;first_seen&#34;: first_seen,
                    &#34;last_seen&#34;: last_seen,
                    &#34;weight&#34;: weight,
                    &#34;internal_id_key&#34;: id,
                    &#34;stix_id_key&#34;: stix_id_key,
                    &#34;created&#34;: created,
                    &#34;modified&#34;: modified,
                    &#34;createdByRef&#34;: created_by_ref,
                    &#34;markingDefinitions&#34;: marking_definitions,
                }
            },
        )
        return self.opencti.process_multiple_fields(
            result[&#34;data&#34;][&#34;stixObservableRelationAdd&#34;]
        )

    &#34;&#34;&#34;
        Create a stix_observable_relation object only if it not exists, update it on request

        :param name: the name of the stix_observable_relation
        :return stix_observable_relation object
    &#34;&#34;&#34;

    def create(self, **kwargs):
        from_id = kwargs.get(&#34;fromId&#34;, None)
        from_type = kwargs.get(&#34;fromType&#34;, None)
        to_type = kwargs.get(&#34;toType&#34;, None)
        to_id = kwargs.get(&#34;toId&#34;, None)
        relationship_type = kwargs.get(&#34;relationship_type&#34;, None)
        description = kwargs.get(&#34;description&#34;, None)
        role_played = kwargs.get(&#34;role_played&#34;, None)
        first_seen = kwargs.get(&#34;first_seen&#34;, None)
        last_seen = kwargs.get(&#34;last_seen&#34;, None)
        weight = kwargs.get(&#34;weight&#34;, None)
        id = kwargs.get(&#34;id&#34;, None)
        stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
        created = kwargs.get(&#34;created&#34;, None)
        modified = kwargs.get(&#34;modified&#34;, None)
        created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
        marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)
        update = kwargs.get(&#34;update&#34;, False)
        ignore_dates = kwargs.get(&#34;ignore_dates&#34;, False)
        custom_attributes = &#34;&#34;&#34;
            id
            entity_type
            name
            description
            weight
            first_seen
            last_seen
        &#34;&#34;&#34;
        stix_relation_result = None
        if stix_id_key is not None:
            stix_relation_result = self.read(
                id=stix_id_key, customAttributes=custom_attributes
            )
        if stix_relation_result is None:
            if (
                ignore_dates is False
                and first_seen is not None
                and last_seen is not None
            ):
                first_seen = dateutil.parser.parse(first_seen)
                first_seen_start = (first_seen + datetime.timedelta(days=-1)).strftime(
                    &#34;%Y-%m-%dT%H:%M:%S+00:00&#34;
                )
                first_seen_stop = (first_seen + datetime.timedelta(days=1)).strftime(
                    &#34;%Y-%m-%dT%H:%M:%S+00:00&#34;
                )
                last_seen = dateutil.parser.parse(last_seen)
                last_seen_start = (last_seen + datetime.timedelta(days=-1)).strftime(
                    &#34;%Y-%m-%dT%H:%M:%S+00:00&#34;
                )
                last_seen_stop = (last_seen + datetime.timedelta(days=1)).strftime(
                    &#34;%Y-%m-%dT%H:%M:%S+00:00&#34;
                )
            else:
                first_seen_start = None
                first_seen_stop = None
                last_seen_start = None
                last_seen_stop = None
            stix_relation_result = self.read(
                fromId=from_id,
                toId=to_id,
                relationType=relationship_type,
                firstSeenStart=first_seen_start,
                firstSeenStop=first_seen_stop,
                lastSeenStart=last_seen_start,
                lastSeenStop=last_seen_stop,
                customAttributes=custom_attributes,
            )
        if stix_relation_result is not None:
            if update:
                if description is not None:
                    self.update_field(
                        id=stix_relation_result[&#34;id&#34;],
                        key=&#34;description&#34;,
                        value=description,
                    )
                    stix_relation_result[&#34;description&#34;] = description
                if weight is not None:
                    self.update_field(
                        id=stix_relation_result[&#34;id&#34;], key=&#34;weight&#34;, value=str(weight)
                    )
                    stix_relation_result[&#34;weight&#34;] = weight
                if first_seen is not None:
                    new_first_seen = dateutil.parser.parse(first_seen)
                    old_first_seen = dateutil.parser.parse(
                        stix_relation_result[&#34;first_seen&#34;]
                    )
                    if new_first_seen &lt; old_first_seen:
                        self.update_field(
                            id=stix_relation_result[&#34;id&#34;],
                            key=&#34;first_seen&#34;,
                            value=first_seen,
                        )
                        stix_relation_result[&#34;first_seen&#34;] = first_seen
                if last_seen is not None:
                    new_last_seen = dateutil.parser.parse(last_seen)
                    old_last_seen = dateutil.parser.parse(
                        stix_relation_result[&#34;last_seen&#34;]
                    )
                    if new_last_seen &gt; old_last_seen:
                        self.update_field(
                            id=stix_relation_result[&#34;id&#34;],
                            key=&#34;last_seen&#34;,
                            value=last_seen,
                        )
                        stix_relation_result[&#34;last_seen&#34;] = last_seen
            return stix_relation_result
        else:
            roles = self.opencti.resolve_role(relationship_type, from_type, to_type)
            if roles is not None:
                final_from_id = from_id
                final_to_id = to_id
            else:
                roles = self.opencti.resolve_role(relationship_type, to_type, from_type)
                if roles is not None:
                    final_from_id = to_id
                    final_to_id = from_id
                else:
                    self.opencti.log(
                        &#34;error&#34;,
                        &#34;Relation creation failed, cannot resolve roles: {&#34;
                        + relationship_type
                        + &#34;: &#34;
                        + from_type
                        + &#34;, &#34;
                        + to_type
                        + &#34;}&#34;,
                    )
                    return None

            return self.create_raw(
                fromId=final_from_id,
                fromRole=roles[&#34;from_role&#34;],
                toId=final_to_id,
                toRole=roles[&#34;to_role&#34;],
                relationship_type=relationship_type,
                description=description,
                first_seen=first_seen,
                last_seen=last_seen,
                weight=weight,
                role_played=role_played,
                id=id,
                stix_id_key=stix_id_key,
                created=created,
                modified=modified,
                createdByRef=created_by_ref,
                markingDefinitions=marking_definitions,
            )

    &#34;&#34;&#34;
        Update a stix_observable_relation object field

        :param id: the stix_observable_relation id
        :param key: the key of the field
        :param value: the value of the field
        :return The updated stix_observable_relation object
    &#34;&#34;&#34;

    def update_field(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        key = kwargs.get(&#34;key&#34;, None)
        value = kwargs.get(&#34;value&#34;, None)
        if id is not None and key is not None and value is not None:
            self.opencti.log(
                &#34;info&#34;,
                &#34;Updating stix_observable_relation {&#34; + id + &#34;} field {&#34; + key + &#34;}.&#34;,
            )
            query = (
                &#34;&#34;&#34;
                mutation StixObservableRelationEdit($id: ID!, $input: EditInput!) {
                    stixObservableRelationEdit(id: $id) {
                        fieldPatch(input: $input) {
                            &#34;&#34;&#34;
                + self.properties
                + &#34;&#34;&#34;
                        }
                    }
                }
            &#34;&#34;&#34;
            )
            result = self.opencti.query(
                query, {&#34;id&#34;: id, &#34;input&#34;: {&#34;key&#34;: key, &#34;value&#34;: value}}
            )
            return self.opencti.process_multiple_fields(
                result[&#34;data&#34;][&#34;stixObservableRelationEdit&#34;][&#34;fieldPatch&#34;]
            )
        else:
            self.opencti.log(&#34;error&#34;, &#34;Missing parameters: id and key and value&#34;)
            return None</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pycti.StixObservableRelation.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create(self, **kwargs):
    from_id = kwargs.get(&#34;fromId&#34;, None)
    from_type = kwargs.get(&#34;fromType&#34;, None)
    to_type = kwargs.get(&#34;toType&#34;, None)
    to_id = kwargs.get(&#34;toId&#34;, None)
    relationship_type = kwargs.get(&#34;relationship_type&#34;, None)
    description = kwargs.get(&#34;description&#34;, None)
    role_played = kwargs.get(&#34;role_played&#34;, None)
    first_seen = kwargs.get(&#34;first_seen&#34;, None)
    last_seen = kwargs.get(&#34;last_seen&#34;, None)
    weight = kwargs.get(&#34;weight&#34;, None)
    id = kwargs.get(&#34;id&#34;, None)
    stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
    created = kwargs.get(&#34;created&#34;, None)
    modified = kwargs.get(&#34;modified&#34;, None)
    created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
    marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)
    update = kwargs.get(&#34;update&#34;, False)
    ignore_dates = kwargs.get(&#34;ignore_dates&#34;, False)
    custom_attributes = &#34;&#34;&#34;
        id
        entity_type
        name
        description
        weight
        first_seen
        last_seen
    &#34;&#34;&#34;
    stix_relation_result = None
    if stix_id_key is not None:
        stix_relation_result = self.read(
            id=stix_id_key, customAttributes=custom_attributes
        )
    if stix_relation_result is None:
        if (
            ignore_dates is False
            and first_seen is not None
            and last_seen is not None
        ):
            first_seen = dateutil.parser.parse(first_seen)
            first_seen_start = (first_seen + datetime.timedelta(days=-1)).strftime(
                &#34;%Y-%m-%dT%H:%M:%S+00:00&#34;
            )
            first_seen_stop = (first_seen + datetime.timedelta(days=1)).strftime(
                &#34;%Y-%m-%dT%H:%M:%S+00:00&#34;
            )
            last_seen = dateutil.parser.parse(last_seen)
            last_seen_start = (last_seen + datetime.timedelta(days=-1)).strftime(
                &#34;%Y-%m-%dT%H:%M:%S+00:00&#34;
            )
            last_seen_stop = (last_seen + datetime.timedelta(days=1)).strftime(
                &#34;%Y-%m-%dT%H:%M:%S+00:00&#34;
            )
        else:
            first_seen_start = None
            first_seen_stop = None
            last_seen_start = None
            last_seen_stop = None
        stix_relation_result = self.read(
            fromId=from_id,
            toId=to_id,
            relationType=relationship_type,
            firstSeenStart=first_seen_start,
            firstSeenStop=first_seen_stop,
            lastSeenStart=last_seen_start,
            lastSeenStop=last_seen_stop,
            customAttributes=custom_attributes,
        )
    if stix_relation_result is not None:
        if update:
            if description is not None:
                self.update_field(
                    id=stix_relation_result[&#34;id&#34;],
                    key=&#34;description&#34;,
                    value=description,
                )
                stix_relation_result[&#34;description&#34;] = description
            if weight is not None:
                self.update_field(
                    id=stix_relation_result[&#34;id&#34;], key=&#34;weight&#34;, value=str(weight)
                )
                stix_relation_result[&#34;weight&#34;] = weight
            if first_seen is not None:
                new_first_seen = dateutil.parser.parse(first_seen)
                old_first_seen = dateutil.parser.parse(
                    stix_relation_result[&#34;first_seen&#34;]
                )
                if new_first_seen &lt; old_first_seen:
                    self.update_field(
                        id=stix_relation_result[&#34;id&#34;],
                        key=&#34;first_seen&#34;,
                        value=first_seen,
                    )
                    stix_relation_result[&#34;first_seen&#34;] = first_seen
            if last_seen is not None:
                new_last_seen = dateutil.parser.parse(last_seen)
                old_last_seen = dateutil.parser.parse(
                    stix_relation_result[&#34;last_seen&#34;]
                )
                if new_last_seen &gt; old_last_seen:
                    self.update_field(
                        id=stix_relation_result[&#34;id&#34;],
                        key=&#34;last_seen&#34;,
                        value=last_seen,
                    )
                    stix_relation_result[&#34;last_seen&#34;] = last_seen
        return stix_relation_result
    else:
        roles = self.opencti.resolve_role(relationship_type, from_type, to_type)
        if roles is not None:
            final_from_id = from_id
            final_to_id = to_id
        else:
            roles = self.opencti.resolve_role(relationship_type, to_type, from_type)
            if roles is not None:
                final_from_id = to_id
                final_to_id = from_id
            else:
                self.opencti.log(
                    &#34;error&#34;,
                    &#34;Relation creation failed, cannot resolve roles: {&#34;
                    + relationship_type
                    + &#34;: &#34;
                    + from_type
                    + &#34;, &#34;
                    + to_type
                    + &#34;}&#34;,
                )
                return None

        return self.create_raw(
            fromId=final_from_id,
            fromRole=roles[&#34;from_role&#34;],
            toId=final_to_id,
            toRole=roles[&#34;to_role&#34;],
            relationship_type=relationship_type,
            description=description,
            first_seen=first_seen,
            last_seen=last_seen,
            weight=weight,
            role_played=role_played,
            id=id,
            stix_id_key=stix_id_key,
            created=created,
            modified=modified,
            createdByRef=created_by_ref,
            markingDefinitions=marking_definitions,
        )</code></pre>
</details>
</dd>
<dt id="pycti.StixObservableRelation.create_raw"><code class="name flex">
<span>def <span class="ident">create_raw</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_raw(self, **kwargs):
    from_id = kwargs.get(&#34;fromId&#34;, None)
    from_role = kwargs.get(&#34;fromRole&#34;, None)
    to_id = kwargs.get(&#34;toId&#34;, None)
    to_role = kwargs.get(&#34;toRole&#34;, None)
    relationship_type = kwargs.get(&#34;relationship_type&#34;, None)
    description = kwargs.get(&#34;description&#34;, None)
    role_played = kwargs.get(&#34;role_played&#34;, None)
    first_seen = kwargs.get(&#34;first_seen&#34;, None)
    last_seen = kwargs.get(&#34;last_seen&#34;, None)
    weight = kwargs.get(&#34;weight&#34;, None)
    id = kwargs.get(&#34;id&#34;, None)
    stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
    created = kwargs.get(&#34;created&#34;, None)
    modified = kwargs.get(&#34;modified&#34;, None)
    created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
    marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)

    self.opencti.log(
        &#34;info&#34;,
        &#34;Creating stix_observable_relation {&#34;
        + from_role
        + &#34;: &#34;
        + from_id
        + &#34;, &#34;
        + to_role
        + &#34;: &#34;
        + to_id
        + &#34;}.&#34;,
    )
    query = (
        &#34;&#34;&#34;
            mutation StixObservableRelationAdd($input: StixObservableRelationAddInput!) {
                stixObservableRelationAdd(input: $input) {
        &#34;&#34;&#34;
        + self.properties
        + &#34;&#34;&#34;
                    }
                }
            &#34;&#34;&#34;
    )
    result = self.opencti.query(
        query,
        {
            &#34;input&#34;: {
                &#34;fromId&#34;: from_id,
                &#34;fromRole&#34;: from_role,
                &#34;toId&#34;: to_id,
                &#34;toRole&#34;: to_role,
                &#34;relationship_type&#34;: relationship_type,
                &#34;description&#34;: description,
                &#34;role_played&#34;: role_played,
                &#34;first_seen&#34;: first_seen,
                &#34;last_seen&#34;: last_seen,
                &#34;weight&#34;: weight,
                &#34;internal_id_key&#34;: id,
                &#34;stix_id_key&#34;: stix_id_key,
                &#34;created&#34;: created,
                &#34;modified&#34;: modified,
                &#34;createdByRef&#34;: created_by_ref,
                &#34;markingDefinitions&#34;: marking_definitions,
            }
        },
    )
    return self.opencti.process_multiple_fields(
        result[&#34;data&#34;][&#34;stixObservableRelationAdd&#34;]
    )</code></pre>
</details>
</dd>
<dt id="pycti.StixObservableRelation.list"><code class="name flex">
<span>def <span class="ident">list</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list(self, **kwargs):
    from_id = kwargs.get(&#34;fromId&#34;, None)
    from_types = kwargs.get(&#34;fromTypes&#34;, None)
    to_id = kwargs.get(&#34;toId&#34;, None)
    to_types = kwargs.get(&#34;toTypes&#34;, None)
    relation_type = kwargs.get(&#34;relationType&#34;, None)
    first_seen_start = kwargs.get(&#34;firstSeenStart&#34;, None)
    first_seen_stop = kwargs.get(&#34;firstSeenStop&#34;, None)
    last_seen_start = kwargs.get(&#34;lastSeenStart&#34;, None)
    last_seen_stop = kwargs.get(&#34;lastSeenStop&#34;, None)
    inferred = kwargs.get(&#34;inferred&#34;, None)
    first = kwargs.get(&#34;first&#34;, 500)
    after = kwargs.get(&#34;after&#34;, None)
    order_by = kwargs.get(&#34;orderBy&#34;, None)
    order_mode = kwargs.get(&#34;orderMode&#34;, None)
    get_all = kwargs.get(&#34;getAll&#34;, False)
    force_natural = kwargs.get(&#34;forceNatural&#34;, False)

    if get_all:
        first = 500

    self.opencti.log(
        &#34;info&#34;,
        &#34;Listing stix_observable_relations with {type: &#34;
        + str(relation_type)
        + &#34;, from_id: &#34;
        + str(from_id)
        + &#34;, to_id: &#34;
        + str(to_id)
        + &#34;}&#34;,
    )
    query = (
        &#34;&#34;&#34;
        query StixObservableRelations($fromId: String, $fromTypes: [String], $toId: String, $toTypes: [String], $relationType: String, $firstSeenStart: DateTime, $firstSeenStop: DateTime, $lastSeenStart: DateTime, $lastSeenStop: DateTime, $inferred: Boolean, $first: Int, $after: ID, $orderBy: StixObservableRelationsOrdering, $orderMode: OrderingMode, $forceNatural: Boolean) {
            stixObservableRelations(fromId: $fromId, fromTypes: $fromTypes, toId: $toId, toTypes: $toTypes, relationType: $relationType, firstSeenStart: $firstSeenStart, firstSeenStop: $firstSeenStop, lastSeenStart: $lastSeenStart, lastSeenStop: $lastSeenStop, inferred: $inferred, first: $first, after: $after, orderBy: $orderBy, orderMode: $orderMode, forceNatural: $forceNatural) {
                edges {
                    node {
                        &#34;&#34;&#34;
        + self.properties
        + &#34;&#34;&#34;
                    }
                }
                pageInfo {
                    startCursor
                    endCursor
                    hasNextPage
                    hasPreviousPage
                    globalCount
                }
            }
        }
     &#34;&#34;&#34;
    )

    result = self.opencti.query(
        query,
        {
            &#34;fromId&#34;: from_id,
            &#34;fromTypes&#34;: from_types,
            &#34;toId&#34;: to_id,
            &#34;toTypes&#34;: to_types,
            &#34;relationType&#34;: relation_type,
            &#34;firstSeenStart&#34;: first_seen_start,
            &#34;firstSeenStop&#34;: first_seen_stop,
            &#34;lastSeenStart&#34;: last_seen_start,
            &#34;lastSeenStop&#34;: last_seen_stop,
            &#34;inferred&#34;: inferred,
            &#34;first&#34;: first,
            &#34;after&#34;: after,
            &#34;orderBy&#34;: order_by,
            &#34;orderMode&#34;: order_mode,
            &#34;forceNatural&#34;: force_natural,
        },
    )
    return self.opencti.process_multiple(result[&#34;data&#34;][&#34;stixObservableRelations&#34;])</code></pre>
</details>
</dd>
<dt id="pycti.StixObservableRelation.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    from_id = kwargs.get(&#34;fromId&#34;, None)
    to_id = kwargs.get(&#34;toId&#34;, None)
    relation_type = kwargs.get(&#34;relationType&#34;, None)
    first_seen_start = kwargs.get(&#34;firstSeenStart&#34;, None)
    first_seen_stop = kwargs.get(&#34;firstSeenStop&#34;, None)
    last_seen_start = kwargs.get(&#34;lastSeenStart&#34;, None)
    last_seen_stop = kwargs.get(&#34;lastSeenStop&#34;, None)
    inferred = kwargs.get(&#34;inferred&#34;, None)
    custom_attributes = kwargs.get(&#34;customAttributes&#34;, None)
    if id is not None:
        self.opencti.log(&#34;info&#34;, &#34;Reading stix_observable_relation {&#34; + id + &#34;}.&#34;)
        query = (
            &#34;&#34;&#34;
            query StixObservableRelation($id: String!) {
                stixObservableRelation(id: $id) {
                    &#34;&#34;&#34;
            + (
                custom_attributes
                if custom_attributes is not None
                else self.properties
            )
            + &#34;&#34;&#34;
                }
            }
         &#34;&#34;&#34;
        )
        result = self.opencti.query(query, {&#34;id&#34;: id})
        return self.opencti.process_multiple_fields(
            result[&#34;data&#34;][&#34;stixObservableRelation&#34;]
        )
    else:
        result = self.list(
            fromId=from_id,
            toId=to_id,
            relationType=relation_type,
            firstSeenStart=first_seen_start,
            firstSeenStop=first_seen_stop,
            lastSeenStart=last_seen_start,
            lastSeenStop=last_seen_stop,
            inferred=inferred,
        )
        if len(result) &gt; 0:
            return result[0]
        else:
            return None</code></pre>
</details>
</dd>
<dt id="pycti.StixObservableRelation.update_field"><code class="name flex">
<span>def <span class="ident">update_field</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_field(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    key = kwargs.get(&#34;key&#34;, None)
    value = kwargs.get(&#34;value&#34;, None)
    if id is not None and key is not None and value is not None:
        self.opencti.log(
            &#34;info&#34;,
            &#34;Updating stix_observable_relation {&#34; + id + &#34;} field {&#34; + key + &#34;}.&#34;,
        )
        query = (
            &#34;&#34;&#34;
            mutation StixObservableRelationEdit($id: ID!, $input: EditInput!) {
                stixObservableRelationEdit(id: $id) {
                    fieldPatch(input: $input) {
                        &#34;&#34;&#34;
            + self.properties
            + &#34;&#34;&#34;
                    }
                }
            }
        &#34;&#34;&#34;
        )
        result = self.opencti.query(
            query, {&#34;id&#34;: id, &#34;input&#34;: {&#34;key&#34;: key, &#34;value&#34;: value}}
        )
        return self.opencti.process_multiple_fields(
            result[&#34;data&#34;][&#34;stixObservableRelationEdit&#34;][&#34;fieldPatch&#34;]
        )
    else:
        self.opencti.log(&#34;error&#34;, &#34;Missing parameters: id and key and value&#34;)
        return None</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pycti.StixRelation"><code class="flex name class">
<span>class <span class="ident">StixRelation</span></span>
<span>(</span><span>opencti)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StixRelation:
    def __init__(self, opencti):
        self.opencti = opencti
        self.properties = &#34;&#34;&#34;
            id
            stix_id_key
            entity_type
            relationship_type
            description
            weight
            role_played
            first_seen
            last_seen
            created
            modified
            created_at
            updated_at
            fromRole
            from {
                id
                stix_id_key
                entity_type
                ...on StixDomainEntity {
                    name
                    description
                }
            }
            toRole
            to {
                id
                stix_id_key
                entity_type
                ...on StixDomainEntity {
                    name
                    description
                }
            }
            createdByRef {
                node {
                    id
                    entity_type
                    stix_id_key
                    stix_label
                    name
                    alias
                    description
                    created
                    modified
                    ... on Organization {
                        organization_class
                    }
                }
                relation {
                    id
                }
            }
            markingDefinitions {
                edges {
                    node {
                        id
                        entity_type
                        stix_id_key
                        definition_type
                        definition
                        level
                        color
                        created
                        modified
                    }
                    relation {
                       id
                    }
                }
            }
            killChainPhases {
                edges {
                    node {
                        id
                        entity_type
                        stix_id_key
                        kill_chain_name
                        phase_name
                        phase_order
                        created
                        modified
                    }
                    relation {
                       id
                    }
                }
            }
            externalReferences {
                edges {
                    node {
                        id
                        entity_type
                        stix_id_key
                        source_name
                        description
                        url
                        hash
                        external_id
                        created
                        modified
                    }
                    relation {
                        id
                    }
                }
            }
        &#34;&#34;&#34;

    &#34;&#34;&#34;
        List stix_relation objects

        :param fromId: the id of the source entity of the relation
        :param toId: the id of the target entity of the relation
        :param relationType: the relation type
        :param firstSeenStart: the first_seen date start filter
        :param firstSeenStop: the first_seen date stop filter
        :param lastSeenStart: the last_seen date start filter
        :param lastSeenStop: the last_seen date stop filter
        :param inferred: includes inferred relations
        :param first: return the first n rows from the after ID (or the beginning if not set)
        :param after: ID of the first row for pagination
        :return List of stix_relation objects
    &#34;&#34;&#34;

    def list(self, **kwargs):
        from_id = kwargs.get(&#34;fromId&#34;, None)
        from_types = kwargs.get(&#34;fromTypes&#34;, None)
        to_id = kwargs.get(&#34;toId&#34;, None)
        to_types = kwargs.get(&#34;toTypes&#34;, None)
        relation_type = kwargs.get(&#34;relationType&#34;, None)
        first_seen_start = kwargs.get(&#34;firstSeenStart&#34;, None)
        first_seen_stop = kwargs.get(&#34;firstSeenStop&#34;, None)
        last_seen_start = kwargs.get(&#34;lastSeenStart&#34;, None)
        last_seen_stop = kwargs.get(&#34;lastSeenStop&#34;, None)
        filters = kwargs.get(&#34;filters&#34;, [])
        inferred = kwargs.get(&#34;inferred&#34;, None)
        first = kwargs.get(&#34;first&#34;, 500)
        after = kwargs.get(&#34;after&#34;, None)
        order_by = kwargs.get(&#34;orderBy&#34;, None)
        order_mode = kwargs.get(&#34;orderMode&#34;, None)
        get_all = kwargs.get(&#34;getAll&#34;, False)
        force_natural = kwargs.get(&#34;forceNatural&#34;, False)
        if get_all:
            first = 500

        self.opencti.log(
            &#34;info&#34;,
            &#34;Listing stix_relations with {type: &#34;
            + str(relation_type)
            + &#34;, from_id: &#34;
            + str(from_id)
            + &#34;, to_id: &#34;
            + str(to_id)
            + &#34;}&#34;,
        )
        query = (
            &#34;&#34;&#34;
                query StixRelations($fromId: String, $fromTypes: [String], $toId: String, $toTypes: [String], $relationType: String, $firstSeenStart: DateTime, $firstSeenStop: DateTime, $lastSeenStart: DateTime, $lastSeenStop: DateTime, $inferred: Boolean, $filters: [StixRelationsFiltering], $first: Int, $after: ID, $orderBy: StixRelationsOrdering, $orderMode: OrderingMode, $forceNatural: Boolean) {
                    stixRelations(fromId: $fromId, fromTypes: $fromTypes, toId: $toId, toTypes: $toTypes, relationType: $relationType, firstSeenStart: $firstSeenStart, firstSeenStop: $firstSeenStop, lastSeenStart: $lastSeenStart, lastSeenStop: $lastSeenStop, inferred: $inferred, filters: $filters, first: $first, after: $after, orderBy: $orderBy, orderMode: $orderMode, forceNatural: $forceNatural) {
                        edges {
                            node {
                                &#34;&#34;&#34;
            + self.properties
            + &#34;&#34;&#34;
                        }
                    }
                    pageInfo {
                        startCursor
                        endCursor
                        hasNextPage
                        hasPreviousPage
                        globalCount
                    }
                }
            }
         &#34;&#34;&#34;
        )
        result = self.opencti.query(
            query,
            {
                &#34;fromId&#34;: from_id,
                &#34;fromTypes&#34;: from_types,
                &#34;toId&#34;: to_id,
                &#34;toTypes&#34;: to_types,
                &#34;relationType&#34;: relation_type,
                &#34;firstSeenStart&#34;: first_seen_start,
                &#34;firstSeenStop&#34;: first_seen_stop,
                &#34;lastSeenStart&#34;: last_seen_start,
                &#34;lastSeenStop&#34;: last_seen_stop,
                &#34;filters&#34;: filters,
                &#34;inferred&#34;: inferred,
                &#34;first&#34;: first,
                &#34;after&#34;: after,
                &#34;orderBy&#34;: order_by,
                &#34;orderMode&#34;: order_mode,
                &#34;forceNatural&#34;: force_natural,
            },
        )
        return self.opencti.process_multiple(result[&#34;data&#34;][&#34;stixRelations&#34;])

    &#34;&#34;&#34;
        Read a stix_relation object

        :param id: the id of the stix_relation
        :param fromId: the id of the source entity of the relation
        :param toId: the id of the target entity of the relation
        :param relationType: the relation type
        :param firstSeenStart: the first_seen date start filter
        :param firstSeenStop: the first_seen date stop filter
        :param lastSeenStart: the last_seen date start filter
        :param lastSeenStop: the last_seen date stop filter
        :param inferred: includes inferred relations
        :return stix_relation object
    &#34;&#34;&#34;

    def read(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        from_id = kwargs.get(&#34;fromId&#34;, None)
        to_id = kwargs.get(&#34;toId&#34;, None)
        relation_type = kwargs.get(&#34;relationType&#34;, None)
        first_seen_start = kwargs.get(&#34;firstSeenStart&#34;, None)
        first_seen_stop = kwargs.get(&#34;firstSeenStop&#34;, None)
        last_seen_start = kwargs.get(&#34;lastSeenStart&#34;, None)
        last_seen_stop = kwargs.get(&#34;lastSeenStop&#34;, None)
        inferred = kwargs.get(&#34;inferred&#34;, None)
        custom_attributes = kwargs.get(&#34;customAttributes&#34;, None)
        if id is not None:
            self.opencti.log(&#34;info&#34;, &#34;Reading stix_relation {&#34; + id + &#34;}.&#34;)
            query = (
                &#34;&#34;&#34;
                    query StixRelation($id: String!) {
                        stixRelation(id: $id) {
                            &#34;&#34;&#34;
                + (
                    custom_attributes
                    if custom_attributes is not None
                    else self.properties
                )
                + &#34;&#34;&#34;
                    }
                }
             &#34;&#34;&#34;
            )
            result = self.opencti.query(query, {&#34;id&#34;: id})
            return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;stixRelation&#34;])
        elif from_id is not None and to_id is not None:
            result = self.list(
                fromId=from_id,
                toId=to_id,
                relationType=relation_type,
                firstSeenStart=first_seen_start,
                firstSeenStop=first_seen_stop,
                lastSeenStart=last_seen_start,
                lastSeenStop=last_seen_stop,
                inferred=inferred,
            )
            if len(result) &gt; 0:
                return result[0]
            else:
                return None
        else:
            self.opencti.log(&#34;error&#34;, &#34;Missing parameters: id or from_id and to_id&#34;)
            return None

    &#34;&#34;&#34;
        Create a stix_relation object

        :param name: the name of the Attack Pattern
        :return stix_relation object
    &#34;&#34;&#34;

    def create_raw(self, **kwargs):
        from_id = kwargs.get(&#34;fromId&#34;, None)
        from_role = kwargs.get(&#34;fromRole&#34;, None)
        to_id = kwargs.get(&#34;toId&#34;, None)
        to_role = kwargs.get(&#34;toRole&#34;, None)
        relationship_type = kwargs.get(&#34;relationship_type&#34;, None)
        description = kwargs.get(&#34;description&#34;, None)
        role_played = kwargs.get(&#34;role_played&#34;, None)
        first_seen = kwargs.get(&#34;first_seen&#34;, None)
        last_seen = kwargs.get(&#34;last_seen&#34;, None)
        weight = kwargs.get(&#34;weight&#34;, None)
        id = kwargs.get(&#34;id&#34;, None)
        stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
        created = kwargs.get(&#34;created&#34;, None)
        modified = kwargs.get(&#34;modified&#34;, None)
        created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
        marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)
        kill_chain_phases = kwargs.get(&#34;killChainPhases&#34;, None)

        self.opencti.log(
            &#34;info&#34;,
            &#34;Creating stix_relation {&#34;
            + from_role
            + &#34;: &#34;
            + from_id
            + &#34;, &#34;
            + to_role
            + &#34;: &#34;
            + to_id
            + &#34;}.&#34;,
        )
        query = (
            &#34;&#34;&#34;
                        mutation StixRelationAdd($input: StixRelationAddInput!) {
                            stixRelationAdd(input: $input) {
                               &#34;&#34;&#34;
            + self.properties
            + &#34;&#34;&#34;
                        }
                    }
                &#34;&#34;&#34;
        )
        result = self.opencti.query(
            query,
            {
                &#34;input&#34;: {
                    &#34;fromId&#34;: from_id,
                    &#34;fromRole&#34;: from_role,
                    &#34;toId&#34;: to_id,
                    &#34;toRole&#34;: to_role,
                    &#34;relationship_type&#34;: relationship_type,
                    &#34;description&#34;: description,
                    &#34;role_played&#34;: role_played,
                    &#34;first_seen&#34;: first_seen,
                    &#34;last_seen&#34;: last_seen,
                    &#34;weight&#34;: weight,
                    &#34;internal_id_key&#34;: id,
                    &#34;stix_id_key&#34;: stix_id_key,
                    &#34;created&#34;: created,
                    &#34;modified&#34;: modified,
                    &#34;createdByRef&#34;: created_by_ref,
                    &#34;markingDefinitions&#34;: marking_definitions,
                    &#34;killChainPhases&#34;: kill_chain_phases,
                }
            },
        )
        return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;stixRelationAdd&#34;])

    &#34;&#34;&#34;
        Create a stix_relation object only if it not exists, update it on request

        :param name: the name of the stix_relation
        :return stix_relation object
    &#34;&#34;&#34;

    def create(self, **kwargs):
        from_id = kwargs.get(&#34;fromId&#34;, None)
        from_type = kwargs.get(&#34;fromType&#34;, None)
        to_type = kwargs.get(&#34;toType&#34;, None)
        to_id = kwargs.get(&#34;toId&#34;, None)
        relationship_type = kwargs.get(&#34;relationship_type&#34;, None)
        description = kwargs.get(&#34;description&#34;, None)
        role_played = kwargs.get(&#34;role_played&#34;, None)
        first_seen = kwargs.get(&#34;first_seen&#34;, None)
        last_seen = kwargs.get(&#34;last_seen&#34;, None)
        weight = kwargs.get(&#34;weight&#34;, None)
        id = kwargs.get(&#34;id&#34;, None)
        stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
        created = kwargs.get(&#34;created&#34;, None)
        modified = kwargs.get(&#34;modified&#34;, None)
        created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
        marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)
        kill_chain_phases = kwargs.get(&#34;killChainPhases&#34;, None)
        update = kwargs.get(&#34;update&#34;, False)
        ignore_dates = kwargs.get(&#34;ignore_dates&#34;, False)
        custom_attributes = &#34;&#34;&#34;
            id
            entity_type
            name
            description
            weight
            first_seen
            last_seen
        &#34;&#34;&#34;
        stix_relation_result = None
        if id is not None:
            stix_relation_result = self.read(id=id, customAttributes=custom_attributes)
        if stix_relation_result is None and stix_id_key is not None:
            stix_relation_result = self.read(
                id=stix_id_key, customAttributes=custom_attributes
            )
        if stix_relation_result is None:
            if (
                ignore_dates is False
                and first_seen is not None
                and last_seen is not None
            ):
                first_seen_parsed = dateutil.parser.parse(first_seen)
                first_seen_start = (
                    first_seen_parsed + datetime.timedelta(days=-1)
                ).strftime(&#34;%Y-%m-%dT%H:%M:%S+00:00&#34;)
                first_seen_stop = (
                    first_seen_parsed + datetime.timedelta(days=1)
                ).strftime(&#34;%Y-%m-%dT%H:%M:%S+00:00&#34;)
                last_seen_parsed = dateutil.parser.parse(last_seen)
                last_seen_start = (
                    last_seen_parsed + datetime.timedelta(days=-1)
                ).strftime(&#34;%Y-%m-%dT%H:%M:%S+00:00&#34;)
                last_seen_stop = (
                    last_seen_parsed + datetime.timedelta(days=1)
                ).strftime(&#34;%Y-%m-%dT%H:%M:%S+00:00&#34;)
            else:
                first_seen_start = None
                first_seen_stop = None
                last_seen_start = None
                last_seen_stop = None
            stix_relation_result = self.read(
                fromId=from_id,
                toId=to_id,
                relationType=relationship_type,
                firstSeenStart=first_seen_start,
                firstSeenStop=first_seen_stop,
                lastSeenStart=last_seen_start,
                lastSeenStop=last_seen_stop,
                customAttributes=custom_attributes,
            )
        if stix_relation_result is not None:
            if update:
                if (
                    description is not None
                    and stix_relation_result[&#34;description&#34;] != description
                ):
                    self.update_field(
                        id=stix_relation_result[&#34;id&#34;],
                        key=&#34;description&#34;,
                        value=description,
                    )
                    stix_relation_result[&#34;description&#34;] = description
                if weight is not None and stix_relation_result[&#34;weight&#34;] != weight:
                    self.update_field(
                        id=stix_relation_result[&#34;id&#34;], key=&#34;weight&#34;, value=str(weight)
                    )
                    stix_relation_result[&#34;weight&#34;] = weight
                if first_seen is not None:
                    new_first_seen = dateutil.parser.parse(first_seen)
                    old_first_seen = dateutil.parser.parse(
                        stix_relation_result[&#34;first_seen&#34;]
                    )
                    if new_first_seen &lt; old_first_seen:
                        self.update_field(
                            id=stix_relation_result[&#34;id&#34;],
                            key=&#34;first_seen&#34;,
                            value=first_seen,
                        )
                        stix_relation_result[&#34;first_seen&#34;] = first_seen
                if last_seen is not None:
                    new_last_seen = dateutil.parser.parse(last_seen)
                    old_last_seen = dateutil.parser.parse(
                        stix_relation_result[&#34;last_seen&#34;]
                    )
                    if new_last_seen &gt; old_last_seen:
                        self.update_field(
                            id=stix_relation_result[&#34;id&#34;],
                            key=&#34;last_seen&#34;,
                            value=last_seen,
                        )
                        stix_relation_result[&#34;last_seen&#34;] = last_seen
            return stix_relation_result
        else:
            roles = self.opencti.resolve_role(relationship_type, from_type, to_type)
            if roles is not None:
                final_from_id = from_id
                final_to_id = to_id
            else:
                roles = self.opencti.resolve_role(relationship_type, to_type, from_type)
                if roles is not None:
                    final_from_id = to_id
                    final_to_id = from_id
                else:
                    self.opencti.log(
                        &#34;error&#34;,
                        &#34;Relation creation failed, cannot resolve roles: {&#34;
                        + relationship_type
                        + &#34;: &#34;
                        + from_type
                        + &#34;, &#34;
                        + to_type
                        + &#34;}&#34;,
                    )
                    return None

            return self.create_raw(
                fromId=final_from_id,
                fromRole=roles[&#34;from_role&#34;],
                toId=final_to_id,
                toRole=roles[&#34;to_role&#34;],
                relationship_type=relationship_type,
                description=description,
                first_seen=first_seen,
                last_seen=last_seen,
                weight=weight,
                role_played=role_played,
                id=id,
                stix_id_key=stix_id_key,
                created=created,
                modified=modified,
                createdByRef=created_by_ref,
                markingDefinitions=marking_definitions,
                killChainPhases=kill_chain_phases,
            )

    &#34;&#34;&#34;
        Update a stix_relation object field

        :param id: the stix_relation id
        :param key: the key of the field
        :param value: the value of the field
        :return The updated stix_relation object
    &#34;&#34;&#34;

    def update_field(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        key = kwargs.get(&#34;key&#34;, None)
        value = kwargs.get(&#34;value&#34;, None)
        if id is not None and key is not None and value is not None:
            self.opencti.log(
                &#34;info&#34;, &#34;Updating stix_relation {&#34; + id + &#34;} field {&#34; + key + &#34;}.&#34;
            )
            query = &#34;&#34;&#34;
                    mutation StixRelationEdit($id: ID!, $input: EditInput!) {
                        stixRelationEdit(id: $id) {
                            fieldPatch(input: $input) {
                                id
                            }
                        }
                    }
                &#34;&#34;&#34;
            result = self.opencti.query(
                query, {&#34;id&#34;: id, &#34;input&#34;: {&#34;key&#34;: key, &#34;value&#34;: value}}
            )
            return self.opencti.process_multiple_fields(
                result[&#34;data&#34;][&#34;stixRelationEdit&#34;][&#34;fieldPatch&#34;]
            )
        else:
            self.opencti.log(
                &#34;error&#34;,
                &#34;[opencti_stix_relation] Missing parameters: id and key and value&#34;,
            )
            return None

    &#34;&#34;&#34;
        Delete a stix_relation

        :param id: the stix_relation id
        :return void
    &#34;&#34;&#34;

    def delete(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        if id is not None:
            self.opencti.log(&#34;info&#34;, &#34;Deleting stix_relation {&#34; + id + &#34;}.&#34;)
            query = &#34;&#34;&#34;
                mutation StixRelationEdit($id: ID!) {
                    stixRelationEdit(id: $id) {
                        delete
                    }
                }
            &#34;&#34;&#34;
            self.opencti.query(query, {&#34;id&#34;: id})
        else:
            self.opencti.log(&#34;error&#34;, &#34;[opencti_stix_relation] Missing parameters: id&#34;)
            return None

    &#34;&#34;&#34;
        Add a Kill-Chain-Phase object to stix_relation object (kill_chain_phases)

        :param id: the id of the stix_relation
        :param kill_chain_phase_id: the id of the Kill-Chain-Phase
        :return Boolean
    &#34;&#34;&#34;

    def add_kill_chain_phase(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        kill_chain_phase_id = kwargs.get(&#34;kill_chain_phase_id&#34;, None)
        if id is not None and kill_chain_phase_id is not None:
            stix_entity = self.read(id=id)
            kill_chain_phases_ids = []
            for marking in stix_entity[&#34;killChainPhases&#34;]:
                kill_chain_phases_ids.append(marking[&#34;id&#34;])
            if kill_chain_phase_id in kill_chain_phases_ids:
                return True
            else:
                self.opencti.log(
                    &#34;info&#34;,
                    &#34;Adding Kill-Chain-Phase {&#34;
                    + kill_chain_phase_id
                    + &#34;} to Stix-Entity {&#34;
                    + id
                    + &#34;}&#34;,
                )
                query = &#34;&#34;&#34;
                   mutation StixRelationAddRelation($id: ID!, $input: RelationAddInput) {
                       stixRelationEdit(id: $id) {
                            relationAdd(input: $input) {
                                id
                            }
                       }
                   }
                &#34;&#34;&#34;
                self.opencti.query(
                    query,
                    {
                        &#34;id&#34;: id,
                        &#34;input&#34;: {
                            &#34;fromRole&#34;: &#34;phase_belonging&#34;,
                            &#34;toId&#34;: kill_chain_phase_id,
                            &#34;toRole&#34;: &#34;kill_chain_phase&#34;,
                            &#34;through&#34;: &#34;kill_chain_phases&#34;,
                        },
                    },
                )
                return True
        else:
            self.opencti.log(
                &#34;error&#34;,
                &#34;[opencti_stix_relation] Missing parameters: id and kill_chain_phase_id&#34;,
            )
            return False

    &#34;&#34;&#34;
        Export an stix_relation object in STIX2

        :param id: the id of the stix_relation
        :return stix_relation object
    &#34;&#34;&#34;

    def to_stix2(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        mode = kwargs.get(&#34;mode&#34;, &#34;simple&#34;)
        max_marking_definition_entity = kwargs.get(
            &#34;max_marking_definition_entity&#34;, None
        )
        entity = kwargs.get(&#34;entity&#34;, None)
        if id is not None and entity is None:
            entity = self.read(id=id)
        if entity is not None:
            roles = self.opencti.resolve_role(
                entity[&#34;relationship_type&#34;],
                entity[&#34;from&#34;][&#34;entity_type&#34;],
                entity[&#34;to&#34;][&#34;entity_type&#34;],
            )
            if roles is not None:
                final_from_id = entity[&#34;from&#34;][&#34;stix_id_key&#34;]
                final_to_id = entity[&#34;to&#34;][&#34;stix_id_key&#34;]
            else:
                roles = self.opencti.resolve_role(
                    entity[&#34;relationship_type&#34;],
                    entity[&#34;to&#34;][&#34;entity_type&#34;],
                    entity[&#34;from&#34;][&#34;entity_type&#34;],
                )
                if roles is not None:
                    final_from_id = entity[&#34;to&#34;][&#34;stix_id_key&#34;]
                    final_to_id = entity[&#34;from&#34;][&#34;stix_id_key&#34;]

            stix_relation = dict()
            stix_relation[&#34;id&#34;] = entity[&#34;stix_id_key&#34;]
            stix_relation[&#34;type&#34;] = &#34;relationship&#34;
            stix_relation[&#34;relationship_type&#34;] = entity[&#34;relationship_type&#34;]
            if self.opencti.not_empty(entity[&#34;description&#34;]):
                stix_relation[&#34;description&#34;] = entity[&#34;description&#34;]
            stix_relation[&#34;source_ref&#34;] = final_from_id
            stix_relation[&#34;target_ref&#34;] = final_to_id
            stix_relation[CustomProperties.SOURCE_REF] = final_from_id
            stix_relation[CustomProperties.TARGET_REF] = final_to_id
            stix_relation[&#34;created&#34;] = self.opencti.stix2.format_date(entity[&#34;created&#34;])
            stix_relation[&#34;modified&#34;] = self.opencti.stix2.format_date(
                entity[&#34;modified&#34;]
            )
            if self.opencti.not_empty(entity[&#34;first_seen&#34;]):
                stix_relation[
                    CustomProperties.FIRST_SEEN
                ] = self.opencti.stix2.format_date(entity[&#34;first_seen&#34;])
            if self.opencti.not_empty(entity[&#34;last_seen&#34;]):
                stix_relation[
                    CustomProperties.LAST_SEEN
                ] = self.opencti.stix2.format_date(entity[&#34;last_seen&#34;])
            if self.opencti.not_empty(entity[&#34;weight&#34;]):
                stix_relation[CustomProperties.WEIGHT] = entity[&#34;weight&#34;]
            if self.opencti.not_empty(entity[&#34;role_played&#34;]):
                stix_relation[CustomProperties.ROLE_PLAYED] = entity[&#34;role_played&#34;]
            stix_relation[CustomProperties.ID] = entity[&#34;id&#34;]
            return self.opencti.stix2.prepare_export(
                entity, stix_relation, mode, max_marking_definition_entity
            )
        else:
            self.opencti.log(
                &#34;error&#34;, &#34;[opencti_stix_relation] Missing parameters: id or entity&#34;
            )</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pycti.StixRelation.add_kill_chain_phase"><code class="name flex">
<span>def <span class="ident">add_kill_chain_phase</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_kill_chain_phase(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    kill_chain_phase_id = kwargs.get(&#34;kill_chain_phase_id&#34;, None)
    if id is not None and kill_chain_phase_id is not None:
        stix_entity = self.read(id=id)
        kill_chain_phases_ids = []
        for marking in stix_entity[&#34;killChainPhases&#34;]:
            kill_chain_phases_ids.append(marking[&#34;id&#34;])
        if kill_chain_phase_id in kill_chain_phases_ids:
            return True
        else:
            self.opencti.log(
                &#34;info&#34;,
                &#34;Adding Kill-Chain-Phase {&#34;
                + kill_chain_phase_id
                + &#34;} to Stix-Entity {&#34;
                + id
                + &#34;}&#34;,
            )
            query = &#34;&#34;&#34;
               mutation StixRelationAddRelation($id: ID!, $input: RelationAddInput) {
                   stixRelationEdit(id: $id) {
                        relationAdd(input: $input) {
                            id
                        }
                   }
               }
            &#34;&#34;&#34;
            self.opencti.query(
                query,
                {
                    &#34;id&#34;: id,
                    &#34;input&#34;: {
                        &#34;fromRole&#34;: &#34;phase_belonging&#34;,
                        &#34;toId&#34;: kill_chain_phase_id,
                        &#34;toRole&#34;: &#34;kill_chain_phase&#34;,
                        &#34;through&#34;: &#34;kill_chain_phases&#34;,
                    },
                },
            )
            return True
    else:
        self.opencti.log(
            &#34;error&#34;,
            &#34;[opencti_stix_relation] Missing parameters: id and kill_chain_phase_id&#34;,
        )
        return False</code></pre>
</details>
</dd>
<dt id="pycti.StixRelation.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create(self, **kwargs):
    from_id = kwargs.get(&#34;fromId&#34;, None)
    from_type = kwargs.get(&#34;fromType&#34;, None)
    to_type = kwargs.get(&#34;toType&#34;, None)
    to_id = kwargs.get(&#34;toId&#34;, None)
    relationship_type = kwargs.get(&#34;relationship_type&#34;, None)
    description = kwargs.get(&#34;description&#34;, None)
    role_played = kwargs.get(&#34;role_played&#34;, None)
    first_seen = kwargs.get(&#34;first_seen&#34;, None)
    last_seen = kwargs.get(&#34;last_seen&#34;, None)
    weight = kwargs.get(&#34;weight&#34;, None)
    id = kwargs.get(&#34;id&#34;, None)
    stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
    created = kwargs.get(&#34;created&#34;, None)
    modified = kwargs.get(&#34;modified&#34;, None)
    created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
    marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)
    kill_chain_phases = kwargs.get(&#34;killChainPhases&#34;, None)
    update = kwargs.get(&#34;update&#34;, False)
    ignore_dates = kwargs.get(&#34;ignore_dates&#34;, False)
    custom_attributes = &#34;&#34;&#34;
        id
        entity_type
        name
        description
        weight
        first_seen
        last_seen
    &#34;&#34;&#34;
    stix_relation_result = None
    if id is not None:
        stix_relation_result = self.read(id=id, customAttributes=custom_attributes)
    if stix_relation_result is None and stix_id_key is not None:
        stix_relation_result = self.read(
            id=stix_id_key, customAttributes=custom_attributes
        )
    if stix_relation_result is None:
        if (
            ignore_dates is False
            and first_seen is not None
            and last_seen is not None
        ):
            first_seen_parsed = dateutil.parser.parse(first_seen)
            first_seen_start = (
                first_seen_parsed + datetime.timedelta(days=-1)
            ).strftime(&#34;%Y-%m-%dT%H:%M:%S+00:00&#34;)
            first_seen_stop = (
                first_seen_parsed + datetime.timedelta(days=1)
            ).strftime(&#34;%Y-%m-%dT%H:%M:%S+00:00&#34;)
            last_seen_parsed = dateutil.parser.parse(last_seen)
            last_seen_start = (
                last_seen_parsed + datetime.timedelta(days=-1)
            ).strftime(&#34;%Y-%m-%dT%H:%M:%S+00:00&#34;)
            last_seen_stop = (
                last_seen_parsed + datetime.timedelta(days=1)
            ).strftime(&#34;%Y-%m-%dT%H:%M:%S+00:00&#34;)
        else:
            first_seen_start = None
            first_seen_stop = None
            last_seen_start = None
            last_seen_stop = None
        stix_relation_result = self.read(
            fromId=from_id,
            toId=to_id,
            relationType=relationship_type,
            firstSeenStart=first_seen_start,
            firstSeenStop=first_seen_stop,
            lastSeenStart=last_seen_start,
            lastSeenStop=last_seen_stop,
            customAttributes=custom_attributes,
        )
    if stix_relation_result is not None:
        if update:
            if (
                description is not None
                and stix_relation_result[&#34;description&#34;] != description
            ):
                self.update_field(
                    id=stix_relation_result[&#34;id&#34;],
                    key=&#34;description&#34;,
                    value=description,
                )
                stix_relation_result[&#34;description&#34;] = description
            if weight is not None and stix_relation_result[&#34;weight&#34;] != weight:
                self.update_field(
                    id=stix_relation_result[&#34;id&#34;], key=&#34;weight&#34;, value=str(weight)
                )
                stix_relation_result[&#34;weight&#34;] = weight
            if first_seen is not None:
                new_first_seen = dateutil.parser.parse(first_seen)
                old_first_seen = dateutil.parser.parse(
                    stix_relation_result[&#34;first_seen&#34;]
                )
                if new_first_seen &lt; old_first_seen:
                    self.update_field(
                        id=stix_relation_result[&#34;id&#34;],
                        key=&#34;first_seen&#34;,
                        value=first_seen,
                    )
                    stix_relation_result[&#34;first_seen&#34;] = first_seen
            if last_seen is not None:
                new_last_seen = dateutil.parser.parse(last_seen)
                old_last_seen = dateutil.parser.parse(
                    stix_relation_result[&#34;last_seen&#34;]
                )
                if new_last_seen &gt; old_last_seen:
                    self.update_field(
                        id=stix_relation_result[&#34;id&#34;],
                        key=&#34;last_seen&#34;,
                        value=last_seen,
                    )
                    stix_relation_result[&#34;last_seen&#34;] = last_seen
        return stix_relation_result
    else:
        roles = self.opencti.resolve_role(relationship_type, from_type, to_type)
        if roles is not None:
            final_from_id = from_id
            final_to_id = to_id
        else:
            roles = self.opencti.resolve_role(relationship_type, to_type, from_type)
            if roles is not None:
                final_from_id = to_id
                final_to_id = from_id
            else:
                self.opencti.log(
                    &#34;error&#34;,
                    &#34;Relation creation failed, cannot resolve roles: {&#34;
                    + relationship_type
                    + &#34;: &#34;
                    + from_type
                    + &#34;, &#34;
                    + to_type
                    + &#34;}&#34;,
                )
                return None

        return self.create_raw(
            fromId=final_from_id,
            fromRole=roles[&#34;from_role&#34;],
            toId=final_to_id,
            toRole=roles[&#34;to_role&#34;],
            relationship_type=relationship_type,
            description=description,
            first_seen=first_seen,
            last_seen=last_seen,
            weight=weight,
            role_played=role_played,
            id=id,
            stix_id_key=stix_id_key,
            created=created,
            modified=modified,
            createdByRef=created_by_ref,
            markingDefinitions=marking_definitions,
            killChainPhases=kill_chain_phases,
        )</code></pre>
</details>
</dd>
<dt id="pycti.StixRelation.create_raw"><code class="name flex">
<span>def <span class="ident">create_raw</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_raw(self, **kwargs):
    from_id = kwargs.get(&#34;fromId&#34;, None)
    from_role = kwargs.get(&#34;fromRole&#34;, None)
    to_id = kwargs.get(&#34;toId&#34;, None)
    to_role = kwargs.get(&#34;toRole&#34;, None)
    relationship_type = kwargs.get(&#34;relationship_type&#34;, None)
    description = kwargs.get(&#34;description&#34;, None)
    role_played = kwargs.get(&#34;role_played&#34;, None)
    first_seen = kwargs.get(&#34;first_seen&#34;, None)
    last_seen = kwargs.get(&#34;last_seen&#34;, None)
    weight = kwargs.get(&#34;weight&#34;, None)
    id = kwargs.get(&#34;id&#34;, None)
    stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
    created = kwargs.get(&#34;created&#34;, None)
    modified = kwargs.get(&#34;modified&#34;, None)
    created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
    marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)
    kill_chain_phases = kwargs.get(&#34;killChainPhases&#34;, None)

    self.opencti.log(
        &#34;info&#34;,
        &#34;Creating stix_relation {&#34;
        + from_role
        + &#34;: &#34;
        + from_id
        + &#34;, &#34;
        + to_role
        + &#34;: &#34;
        + to_id
        + &#34;}.&#34;,
    )
    query = (
        &#34;&#34;&#34;
                    mutation StixRelationAdd($input: StixRelationAddInput!) {
                        stixRelationAdd(input: $input) {
                           &#34;&#34;&#34;
        + self.properties
        + &#34;&#34;&#34;
                    }
                }
            &#34;&#34;&#34;
    )
    result = self.opencti.query(
        query,
        {
            &#34;input&#34;: {
                &#34;fromId&#34;: from_id,
                &#34;fromRole&#34;: from_role,
                &#34;toId&#34;: to_id,
                &#34;toRole&#34;: to_role,
                &#34;relationship_type&#34;: relationship_type,
                &#34;description&#34;: description,
                &#34;role_played&#34;: role_played,
                &#34;first_seen&#34;: first_seen,
                &#34;last_seen&#34;: last_seen,
                &#34;weight&#34;: weight,
                &#34;internal_id_key&#34;: id,
                &#34;stix_id_key&#34;: stix_id_key,
                &#34;created&#34;: created,
                &#34;modified&#34;: modified,
                &#34;createdByRef&#34;: created_by_ref,
                &#34;markingDefinitions&#34;: marking_definitions,
                &#34;killChainPhases&#34;: kill_chain_phases,
            }
        },
    )
    return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;stixRelationAdd&#34;])</code></pre>
</details>
</dd>
<dt id="pycti.StixRelation.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    if id is not None:
        self.opencti.log(&#34;info&#34;, &#34;Deleting stix_relation {&#34; + id + &#34;}.&#34;)
        query = &#34;&#34;&#34;
            mutation StixRelationEdit($id: ID!) {
                stixRelationEdit(id: $id) {
                    delete
                }
            }
        &#34;&#34;&#34;
        self.opencti.query(query, {&#34;id&#34;: id})
    else:
        self.opencti.log(&#34;error&#34;, &#34;[opencti_stix_relation] Missing parameters: id&#34;)
        return None</code></pre>
</details>
</dd>
<dt id="pycti.StixRelation.list"><code class="name flex">
<span>def <span class="ident">list</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list(self, **kwargs):
    from_id = kwargs.get(&#34;fromId&#34;, None)
    from_types = kwargs.get(&#34;fromTypes&#34;, None)
    to_id = kwargs.get(&#34;toId&#34;, None)
    to_types = kwargs.get(&#34;toTypes&#34;, None)
    relation_type = kwargs.get(&#34;relationType&#34;, None)
    first_seen_start = kwargs.get(&#34;firstSeenStart&#34;, None)
    first_seen_stop = kwargs.get(&#34;firstSeenStop&#34;, None)
    last_seen_start = kwargs.get(&#34;lastSeenStart&#34;, None)
    last_seen_stop = kwargs.get(&#34;lastSeenStop&#34;, None)
    filters = kwargs.get(&#34;filters&#34;, [])
    inferred = kwargs.get(&#34;inferred&#34;, None)
    first = kwargs.get(&#34;first&#34;, 500)
    after = kwargs.get(&#34;after&#34;, None)
    order_by = kwargs.get(&#34;orderBy&#34;, None)
    order_mode = kwargs.get(&#34;orderMode&#34;, None)
    get_all = kwargs.get(&#34;getAll&#34;, False)
    force_natural = kwargs.get(&#34;forceNatural&#34;, False)
    if get_all:
        first = 500

    self.opencti.log(
        &#34;info&#34;,
        &#34;Listing stix_relations with {type: &#34;
        + str(relation_type)
        + &#34;, from_id: &#34;
        + str(from_id)
        + &#34;, to_id: &#34;
        + str(to_id)
        + &#34;}&#34;,
    )
    query = (
        &#34;&#34;&#34;
            query StixRelations($fromId: String, $fromTypes: [String], $toId: String, $toTypes: [String], $relationType: String, $firstSeenStart: DateTime, $firstSeenStop: DateTime, $lastSeenStart: DateTime, $lastSeenStop: DateTime, $inferred: Boolean, $filters: [StixRelationsFiltering], $first: Int, $after: ID, $orderBy: StixRelationsOrdering, $orderMode: OrderingMode, $forceNatural: Boolean) {
                stixRelations(fromId: $fromId, fromTypes: $fromTypes, toId: $toId, toTypes: $toTypes, relationType: $relationType, firstSeenStart: $firstSeenStart, firstSeenStop: $firstSeenStop, lastSeenStart: $lastSeenStart, lastSeenStop: $lastSeenStop, inferred: $inferred, filters: $filters, first: $first, after: $after, orderBy: $orderBy, orderMode: $orderMode, forceNatural: $forceNatural) {
                    edges {
                        node {
                            &#34;&#34;&#34;
        + self.properties
        + &#34;&#34;&#34;
                    }
                }
                pageInfo {
                    startCursor
                    endCursor
                    hasNextPage
                    hasPreviousPage
                    globalCount
                }
            }
        }
     &#34;&#34;&#34;
    )
    result = self.opencti.query(
        query,
        {
            &#34;fromId&#34;: from_id,
            &#34;fromTypes&#34;: from_types,
            &#34;toId&#34;: to_id,
            &#34;toTypes&#34;: to_types,
            &#34;relationType&#34;: relation_type,
            &#34;firstSeenStart&#34;: first_seen_start,
            &#34;firstSeenStop&#34;: first_seen_stop,
            &#34;lastSeenStart&#34;: last_seen_start,
            &#34;lastSeenStop&#34;: last_seen_stop,
            &#34;filters&#34;: filters,
            &#34;inferred&#34;: inferred,
            &#34;first&#34;: first,
            &#34;after&#34;: after,
            &#34;orderBy&#34;: order_by,
            &#34;orderMode&#34;: order_mode,
            &#34;forceNatural&#34;: force_natural,
        },
    )
    return self.opencti.process_multiple(result[&#34;data&#34;][&#34;stixRelations&#34;])</code></pre>
</details>
</dd>
<dt id="pycti.StixRelation.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    from_id = kwargs.get(&#34;fromId&#34;, None)
    to_id = kwargs.get(&#34;toId&#34;, None)
    relation_type = kwargs.get(&#34;relationType&#34;, None)
    first_seen_start = kwargs.get(&#34;firstSeenStart&#34;, None)
    first_seen_stop = kwargs.get(&#34;firstSeenStop&#34;, None)
    last_seen_start = kwargs.get(&#34;lastSeenStart&#34;, None)
    last_seen_stop = kwargs.get(&#34;lastSeenStop&#34;, None)
    inferred = kwargs.get(&#34;inferred&#34;, None)
    custom_attributes = kwargs.get(&#34;customAttributes&#34;, None)
    if id is not None:
        self.opencti.log(&#34;info&#34;, &#34;Reading stix_relation {&#34; + id + &#34;}.&#34;)
        query = (
            &#34;&#34;&#34;
                query StixRelation($id: String!) {
                    stixRelation(id: $id) {
                        &#34;&#34;&#34;
            + (
                custom_attributes
                if custom_attributes is not None
                else self.properties
            )
            + &#34;&#34;&#34;
                }
            }
         &#34;&#34;&#34;
        )
        result = self.opencti.query(query, {&#34;id&#34;: id})
        return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;stixRelation&#34;])
    elif from_id is not None and to_id is not None:
        result = self.list(
            fromId=from_id,
            toId=to_id,
            relationType=relation_type,
            firstSeenStart=first_seen_start,
            firstSeenStop=first_seen_stop,
            lastSeenStart=last_seen_start,
            lastSeenStop=last_seen_stop,
            inferred=inferred,
        )
        if len(result) &gt; 0:
            return result[0]
        else:
            return None
    else:
        self.opencti.log(&#34;error&#34;, &#34;Missing parameters: id or from_id and to_id&#34;)
        return None</code></pre>
</details>
</dd>
<dt id="pycti.StixRelation.to_stix2"><code class="name flex">
<span>def <span class="ident">to_stix2</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_stix2(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    mode = kwargs.get(&#34;mode&#34;, &#34;simple&#34;)
    max_marking_definition_entity = kwargs.get(
        &#34;max_marking_definition_entity&#34;, None
    )
    entity = kwargs.get(&#34;entity&#34;, None)
    if id is not None and entity is None:
        entity = self.read(id=id)
    if entity is not None:
        roles = self.opencti.resolve_role(
            entity[&#34;relationship_type&#34;],
            entity[&#34;from&#34;][&#34;entity_type&#34;],
            entity[&#34;to&#34;][&#34;entity_type&#34;],
        )
        if roles is not None:
            final_from_id = entity[&#34;from&#34;][&#34;stix_id_key&#34;]
            final_to_id = entity[&#34;to&#34;][&#34;stix_id_key&#34;]
        else:
            roles = self.opencti.resolve_role(
                entity[&#34;relationship_type&#34;],
                entity[&#34;to&#34;][&#34;entity_type&#34;],
                entity[&#34;from&#34;][&#34;entity_type&#34;],
            )
            if roles is not None:
                final_from_id = entity[&#34;to&#34;][&#34;stix_id_key&#34;]
                final_to_id = entity[&#34;from&#34;][&#34;stix_id_key&#34;]

        stix_relation = dict()
        stix_relation[&#34;id&#34;] = entity[&#34;stix_id_key&#34;]
        stix_relation[&#34;type&#34;] = &#34;relationship&#34;
        stix_relation[&#34;relationship_type&#34;] = entity[&#34;relationship_type&#34;]
        if self.opencti.not_empty(entity[&#34;description&#34;]):
            stix_relation[&#34;description&#34;] = entity[&#34;description&#34;]
        stix_relation[&#34;source_ref&#34;] = final_from_id
        stix_relation[&#34;target_ref&#34;] = final_to_id
        stix_relation[CustomProperties.SOURCE_REF] = final_from_id
        stix_relation[CustomProperties.TARGET_REF] = final_to_id
        stix_relation[&#34;created&#34;] = self.opencti.stix2.format_date(entity[&#34;created&#34;])
        stix_relation[&#34;modified&#34;] = self.opencti.stix2.format_date(
            entity[&#34;modified&#34;]
        )
        if self.opencti.not_empty(entity[&#34;first_seen&#34;]):
            stix_relation[
                CustomProperties.FIRST_SEEN
            ] = self.opencti.stix2.format_date(entity[&#34;first_seen&#34;])
        if self.opencti.not_empty(entity[&#34;last_seen&#34;]):
            stix_relation[
                CustomProperties.LAST_SEEN
            ] = self.opencti.stix2.format_date(entity[&#34;last_seen&#34;])
        if self.opencti.not_empty(entity[&#34;weight&#34;]):
            stix_relation[CustomProperties.WEIGHT] = entity[&#34;weight&#34;]
        if self.opencti.not_empty(entity[&#34;role_played&#34;]):
            stix_relation[CustomProperties.ROLE_PLAYED] = entity[&#34;role_played&#34;]
        stix_relation[CustomProperties.ID] = entity[&#34;id&#34;]
        return self.opencti.stix2.prepare_export(
            entity, stix_relation, mode, max_marking_definition_entity
        )
    else:
        self.opencti.log(
            &#34;error&#34;, &#34;[opencti_stix_relation] Missing parameters: id or entity&#34;
        )</code></pre>
</details>
</dd>
<dt id="pycti.StixRelation.update_field"><code class="name flex">
<span>def <span class="ident">update_field</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_field(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    key = kwargs.get(&#34;key&#34;, None)
    value = kwargs.get(&#34;value&#34;, None)
    if id is not None and key is not None and value is not None:
        self.opencti.log(
            &#34;info&#34;, &#34;Updating stix_relation {&#34; + id + &#34;} field {&#34; + key + &#34;}.&#34;
        )
        query = &#34;&#34;&#34;
                mutation StixRelationEdit($id: ID!, $input: EditInput!) {
                    stixRelationEdit(id: $id) {
                        fieldPatch(input: $input) {
                            id
                        }
                    }
                }
            &#34;&#34;&#34;
        result = self.opencti.query(
            query, {&#34;id&#34;: id, &#34;input&#34;: {&#34;key&#34;: key, &#34;value&#34;: value}}
        )
        return self.opencti.process_multiple_fields(
            result[&#34;data&#34;][&#34;stixRelationEdit&#34;][&#34;fieldPatch&#34;]
        )
    else:
        self.opencti.log(
            &#34;error&#34;,
            &#34;[opencti_stix_relation] Missing parameters: id and key and value&#34;,
        )
        return None</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pycti.Tag"><code class="flex name class">
<span>class <span class="ident">Tag</span></span>
<span>(</span><span>opencti)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Tag:
    def __init__(self, opencti):
        self.opencti = opencti
        self.properties = &#34;&#34;&#34;
            id
            tag_type
            value
            color
            created_at
            updated_at
        &#34;&#34;&#34;

    &#34;&#34;&#34;
        List Tag objects

        :param filters: the filters to apply
        :param first: return the first n rows from the after ID (or the beginning if not set)
        :param after: ID of the first row for pagination
        :return List of Tag objects
    &#34;&#34;&#34;

    def list(self, **kwargs):
        filters = kwargs.get(&#34;filters&#34;, None)
        first = kwargs.get(&#34;first&#34;, 500)
        after = kwargs.get(&#34;after&#34;, None)
        order_by = kwargs.get(&#34;orderBy&#34;, None)
        order_mode = kwargs.get(&#34;orderMode&#34;, None)
        get_all = kwargs.get(&#34;getAll&#34;, False)
        if get_all:
            first = 500

        self.opencti.log(
            &#34;info&#34;, &#34;Listing Tags with filters &#34; + json.dumps(filters) + &#34;.&#34;
        )
        query = (
            &#34;&#34;&#34;
            query Tags($filters: [TagsFiltering], $first: Int, $after: ID, $orderBy: TagsOrdering, $orderMode: OrderingMode) {
                tags(filters: $filters, first: $first, after: $after, orderBy: $orderBy, orderMode: $orderMode) {
                    edges {
                        node {
                            &#34;&#34;&#34;
            + self.properties
            + &#34;&#34;&#34;
                        }
                    }
                    pageInfo {
                        startCursor
                        endCursor
                        hasNextPage
                        hasPreviousPage
                        globalCount
                    }                    
                }
            }
        &#34;&#34;&#34;
        )
        result = self.opencti.query(
            query,
            {
                &#34;filters&#34;: filters,
                &#34;first&#34;: first,
                &#34;after&#34;: after,
                &#34;orderBy&#34;: order_by,
                &#34;orderMode&#34;: order_mode,
            },
        )
        return self.opencti.process_multiple(result[&#34;data&#34;][&#34;tags&#34;])

    &#34;&#34;&#34;
        Read a Tag object

        :param id: the id of the Tag
        :param filters: the filters to apply if no id provided
        :return Marking-Definition object
    &#34;&#34;&#34;

    def read(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        filters = kwargs.get(&#34;filters&#34;, None)
        if id is not None:
            self.opencti.log(&#34;info&#34;, &#34;Reading Tag {&#34; + id + &#34;}.&#34;)
            query = (
                &#34;&#34;&#34;
                query Tag($id: String!) {
                    tag(id: $id) {
                        &#34;&#34;&#34;
                + self.properties
                + &#34;&#34;&#34;
                    }
                }
            &#34;&#34;&#34;
            )
            result = self.opencti.query(query, {&#34;id&#34;: id})
            return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;tag&#34;])
        elif filters is not None:
            result = self.list(filters=filters)
            if len(result) &gt; 0:
                return result[0]
            else:
                return None
        else:
            self.opencti.log(&#34;error&#34;, &#34;[opencti_tag] Missing parameters: id or filters&#34;)
            return None

    &#34;&#34;&#34;
        Create a Tag object

        :param tag_type: the tag type
        :param value: the value
        :param color: the color
        :return Tag object
    &#34;&#34;&#34;

    def create_raw(self, **kwargs):
        tag_type = kwargs.get(&#34;tag_type&#34;, None)
        value = kwargs.get(&#34;value&#34;, None)
        color = kwargs.get(&#34;color&#34;, None)
        id = kwargs.get(&#34;id&#34;, None)

        if tag_type is not None and value is not None and color is not None:
            query = (
                &#34;&#34;&#34;
                mutation TagAdd($input: TagAddInput) {
                    tagAdd(input: $input) {
                        &#34;&#34;&#34;
                + self.properties
                + &#34;&#34;&#34;
                    }
                }
            &#34;&#34;&#34;
            )
            result = self.opencti.query(
                query,
                {
                    &#34;input&#34;: {
                        &#34;tag_type&#34;: tag_type,
                        &#34;value&#34;: value,
                        &#34;color&#34;: color,
                        &#34;internal_id_key&#34;: id,
                    }
                },
            )
            return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;tagAdd&#34;])
        else:
            self.opencti.log(
                &#34;error&#34;,
                &#34;[opencti_tag] Missing parameters: tag_type and value and color&#34;,
            )

    &#34;&#34;&#34;
        Create a Tag object only if it not exists, update it on request

        :param tag_type: the tag type
        :param value: the value
        :param color: the color
        :return Tag object
    &#34;&#34;&#34;

    def create(self, **kwargs):
        tag_type = kwargs.get(&#34;tag_type&#34;, None)
        value = kwargs.get(&#34;value&#34;, None)
        color = kwargs.get(&#34;color&#34;, None)
        id = kwargs.get(&#34;id&#34;, None)

        object_result = self.read(filters=[{&#34;key&#34;: &#34;value&#34;, &#34;values&#34;: [value]}])
        if object_result is not None:
            return object_result
        else:
            return self.create_raw(tag_type=tag_type, value=value, color=color, id=id)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pycti.Tag.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create(self, **kwargs):
    tag_type = kwargs.get(&#34;tag_type&#34;, None)
    value = kwargs.get(&#34;value&#34;, None)
    color = kwargs.get(&#34;color&#34;, None)
    id = kwargs.get(&#34;id&#34;, None)

    object_result = self.read(filters=[{&#34;key&#34;: &#34;value&#34;, &#34;values&#34;: [value]}])
    if object_result is not None:
        return object_result
    else:
        return self.create_raw(tag_type=tag_type, value=value, color=color, id=id)</code></pre>
</details>
</dd>
<dt id="pycti.Tag.create_raw"><code class="name flex">
<span>def <span class="ident">create_raw</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_raw(self, **kwargs):
    tag_type = kwargs.get(&#34;tag_type&#34;, None)
    value = kwargs.get(&#34;value&#34;, None)
    color = kwargs.get(&#34;color&#34;, None)
    id = kwargs.get(&#34;id&#34;, None)

    if tag_type is not None and value is not None and color is not None:
        query = (
            &#34;&#34;&#34;
            mutation TagAdd($input: TagAddInput) {
                tagAdd(input: $input) {
                    &#34;&#34;&#34;
            + self.properties
            + &#34;&#34;&#34;
                }
            }
        &#34;&#34;&#34;
        )
        result = self.opencti.query(
            query,
            {
                &#34;input&#34;: {
                    &#34;tag_type&#34;: tag_type,
                    &#34;value&#34;: value,
                    &#34;color&#34;: color,
                    &#34;internal_id_key&#34;: id,
                }
            },
        )
        return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;tagAdd&#34;])
    else:
        self.opencti.log(
            &#34;error&#34;,
            &#34;[opencti_tag] Missing parameters: tag_type and value and color&#34;,
        )</code></pre>
</details>
</dd>
<dt id="pycti.Tag.list"><code class="name flex">
<span>def <span class="ident">list</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list(self, **kwargs):
    filters = kwargs.get(&#34;filters&#34;, None)
    first = kwargs.get(&#34;first&#34;, 500)
    after = kwargs.get(&#34;after&#34;, None)
    order_by = kwargs.get(&#34;orderBy&#34;, None)
    order_mode = kwargs.get(&#34;orderMode&#34;, None)
    get_all = kwargs.get(&#34;getAll&#34;, False)
    if get_all:
        first = 500

    self.opencti.log(
        &#34;info&#34;, &#34;Listing Tags with filters &#34; + json.dumps(filters) + &#34;.&#34;
    )
    query = (
        &#34;&#34;&#34;
        query Tags($filters: [TagsFiltering], $first: Int, $after: ID, $orderBy: TagsOrdering, $orderMode: OrderingMode) {
            tags(filters: $filters, first: $first, after: $after, orderBy: $orderBy, orderMode: $orderMode) {
                edges {
                    node {
                        &#34;&#34;&#34;
        + self.properties
        + &#34;&#34;&#34;
                    }
                }
                pageInfo {
                    startCursor
                    endCursor
                    hasNextPage
                    hasPreviousPage
                    globalCount
                }                    
            }
        }
    &#34;&#34;&#34;
    )
    result = self.opencti.query(
        query,
        {
            &#34;filters&#34;: filters,
            &#34;first&#34;: first,
            &#34;after&#34;: after,
            &#34;orderBy&#34;: order_by,
            &#34;orderMode&#34;: order_mode,
        },
    )
    return self.opencti.process_multiple(result[&#34;data&#34;][&#34;tags&#34;])</code></pre>
</details>
</dd>
<dt id="pycti.Tag.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    filters = kwargs.get(&#34;filters&#34;, None)
    if id is not None:
        self.opencti.log(&#34;info&#34;, &#34;Reading Tag {&#34; + id + &#34;}.&#34;)
        query = (
            &#34;&#34;&#34;
            query Tag($id: String!) {
                tag(id: $id) {
                    &#34;&#34;&#34;
            + self.properties
            + &#34;&#34;&#34;
                }
            }
        &#34;&#34;&#34;
        )
        result = self.opencti.query(query, {&#34;id&#34;: id})
        return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;tag&#34;])
    elif filters is not None:
        result = self.list(filters=filters)
        if len(result) &gt; 0:
            return result[0]
        else:
            return None
    else:
        self.opencti.log(&#34;error&#34;, &#34;[opencti_tag] Missing parameters: id or filters&#34;)
        return None</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pycti.ThreatActor"><code class="flex name class">
<span>class <span class="ident">ThreatActor</span></span>
<span>(</span><span>opencti)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ThreatActor:
    def __init__(self, opencti):
        self.opencti = opencti
        self.properties = &#34;&#34;&#34;
            id
            stix_id_key
            stix_label
            entity_type
            parent_types
            name
            alias
            description
            graph_data
            goal
            sophistication
            resource_level
            primary_motivation
            secondary_motivation
            personal_motivation
            created
            modified            
            created_at
            updated_at
            createdByRef {
                node {
                    id
                    entity_type
                    stix_id_key
                    stix_label
                    name
                    alias
                    description
                    created
                    modified
                    ... on Organization {
                        organization_class
                    }
                }
                relation {
                    id
                }
            }            
            markingDefinitions {
                edges {
                    node {
                        id
                        entity_type
                        stix_id_key
                        definition_type
                        definition
                        level
                        color
                        created
                        modified
                    }
                    relation {
                        id
                    }
                }
            }
            tags {
                edges {
                    node {
                        id
                        tag_type
                        value
                        color
                    }
                    relation {
                        id
                    }
                }
            }
            externalReferences {
                edges {
                    node {
                        id
                        entity_type
                        stix_id_key
                        source_name
                        description
                        url
                        hash
                        external_id
                        created
                        modified
                    }
                    relation {
                        id
                    }
                }
            }     
        &#34;&#34;&#34;

    &#34;&#34;&#34;
        List Threat-Actor objects

        :param filters: the filters to apply
        :param search: the search keyword
        :param first: return the first n rows from the after ID (or the beginning if not set)
        :param after: ID of the first row for pagination
        :return List of Threat-Actor objects
    &#34;&#34;&#34;

    def list(self, **kwargs):
        filters = kwargs.get(&#34;filters&#34;, None)
        search = kwargs.get(&#34;search&#34;, None)
        first = kwargs.get(&#34;first&#34;, 500)
        after = kwargs.get(&#34;after&#34;, None)
        order_by = kwargs.get(&#34;orderBy&#34;, None)
        order_mode = kwargs.get(&#34;orderMode&#34;, None)
        get_all = kwargs.get(&#34;getAll&#34;, False)
        if get_all:
            first = 500

        self.opencti.log(
            &#34;info&#34;, &#34;Listing Threat-Actors with filters &#34; + json.dumps(filters) + &#34;.&#34;
        )
        query = (
            &#34;&#34;&#34;
            query ThreatActors($filters: [ThreatActorsFiltering], $search: String, $first: Int, $after: ID, $orderBy: ThreatActorsOrdering, $orderMode: OrderingMode) {
                threatActors(filters: $filters, search: $search, first: $first, after: $after, orderBy: $orderBy, orderMode: $orderMode) {
                    edges {
                        node {
                            &#34;&#34;&#34;
            + self.properties
            + &#34;&#34;&#34;
                        }
                    }
                    pageInfo {
                        startCursor
                        endCursor
                        hasNextPage
                        hasPreviousPage
                        globalCount
                    }
                }
            }
        &#34;&#34;&#34;
        )
        result = self.opencti.query(
            query,
            {
                &#34;filters&#34;: filters,
                &#34;search&#34;: search,
                &#34;first&#34;: first,
                &#34;after&#34;: after,
                &#34;orderBy&#34;: order_by,
                &#34;orderMode&#34;: order_mode,
            },
        )
        return self.opencti.process_multiple(result[&#34;data&#34;][&#34;threatActors&#34;])

    &#34;&#34;&#34;
        Read a Threat-Actor object
        
        :param id: the id of the Threat-Actor
        :param filters: the filters to apply if no id provided
        :return Threat-Actor object
    &#34;&#34;&#34;

    def read(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        filters = kwargs.get(&#34;filters&#34;, None)
        custom_attributes = kwargs.get(&#34;customAttributes&#34;, None)
        if id is not None:
            self.opencti.log(&#34;info&#34;, &#34;Reading Threat-Actor {&#34; + id + &#34;}.&#34;)
            query = (
                &#34;&#34;&#34;
                query ThreatActor($id: String!) {
                    threatActor(id: $id) {
                        &#34;&#34;&#34;
                + (
                    custom_attributes
                    if custom_attributes is not None
                    else self.properties
                )
                + &#34;&#34;&#34;
                    }
                }
             &#34;&#34;&#34;
            )
            result = self.opencti.query(query, {&#34;id&#34;: id})
            return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;threatActor&#34;])
        elif filters is not None:
            result = self.list(filters=filters)
            if len(result) &gt; 0:
                return result[0]
            else:
                return None
        else:
            self.opencti.log(
                &#34;error&#34;, &#34;[opencti_threat_actor] Missing parameters: id or filters&#34;
            )
            return None

    &#34;&#34;&#34;
        Create a Threat-Actor object

        :param name: the name of the Threat-Actor
        :return Threat-Actor object
    &#34;&#34;&#34;

    def create_raw(self, **kwargs):
        name = kwargs.get(&#34;name&#34;, None)
        description = kwargs.get(&#34;description&#34;, None)
        alias = kwargs.get(&#34;alias&#34;, None)
        goal = kwargs.get(&#34;goal&#34;, None)
        sophistication = kwargs.get(&#34;sophistication&#34;, None)
        resource_level = kwargs.get(&#34;resource_level&#34;, None)
        primary_motivation = kwargs.get(&#34;primary_motivation&#34;, None)
        secondary_motivation = kwargs.get(&#34;secondary_motivation&#34;, None)
        personal_motivation = kwargs.get(&#34;personal_motivation&#34;, None)
        id = kwargs.get(&#34;id&#34;, None)
        stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
        created = kwargs.get(&#34;created&#34;, None)
        modified = kwargs.get(&#34;modified&#34;, None)
        created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
        marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)

        if name is not None and description is not None:
            self.opencti.log(&#34;info&#34;, &#34;Creating Threat-Actor {&#34; + name + &#34;}.&#34;)
            query = (
                &#34;&#34;&#34;
                mutation ThreatActorAdd($input: ThreatActorAddInput) {
                    threatActorAdd(input: $input) {
                        &#34;&#34;&#34;
                + self.properties
                + &#34;&#34;&#34;
                    }
                }
            &#34;&#34;&#34;
            )
            result = self.opencti.query(
                query,
                {
                    &#34;input&#34;: {
                        &#34;name&#34;: name,
                        &#34;description&#34;: description,
                        &#34;alias&#34;: alias,
                        &#34;goal&#34;: goal,
                        &#34;sophistication&#34;: sophistication,
                        &#34;resource_level&#34;: resource_level,
                        &#34;primary_motivation&#34;: primary_motivation,
                        &#34;secondary_motivation&#34;: secondary_motivation,
                        &#34;personal_motivation&#34;: personal_motivation,
                        &#34;internal_id_key&#34;: id,
                        &#34;stix_id_key&#34;: stix_id_key,
                        &#34;created&#34;: created,
                        &#34;modified&#34;: modified,
                        &#34;createdByRef&#34;: created_by_ref,
                        &#34;markingDefinitions&#34;: marking_definitions,
                    }
                },
            )
            return self.opencti.process_multiple_fields(
                result[&#34;data&#34;][&#34;threatActorAdd&#34;]
            )
        else:
            self.opencti.log(
                &#34;error&#34;,
                &#34;[opencti_threat_actor] Missing parameters: name and description&#34;,
            )

    &#34;&#34;&#34;
        Create a Threat-Actor object only if it not exists, update it on request

        :param name: the name of the Threat-Actor
        :return Threat-Actor object
    &#34;&#34;&#34;

    def create(self, **kwargs):
        name = kwargs.get(&#34;name&#34;, None)
        description = kwargs.get(&#34;description&#34;, None)
        alias = kwargs.get(&#34;alias&#34;, None)
        goal = kwargs.get(&#34;goal&#34;, None)
        sophistication = kwargs.get(&#34;sophistication&#34;, None)
        resource_level = kwargs.get(&#34;resource_level&#34;, None)
        primary_motivation = kwargs.get(&#34;primary_motivation&#34;, None)
        secondary_motivation = kwargs.get(&#34;secondary_motivation&#34;, None)
        personal_motivation = kwargs.get(&#34;personal_motivation&#34;, None)
        id = kwargs.get(&#34;id&#34;, None)
        stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
        created = kwargs.get(&#34;created&#34;, None)
        modified = kwargs.get(&#34;modified&#34;, None)
        created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
        marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)
        update = kwargs.get(&#34;update&#34;, False)
        custom_attributes = &#34;&#34;&#34;
            id
            entity_type
            name
            description 
            alias
            ... on ThreatActor {
                goal
                sophistication
                resource_level
                primary_motivation
                secondary_motivation
                personal_motivation
            }
        &#34;&#34;&#34;
        object_result = self.opencti.stix_domain_entity.get_by_stix_id_or_name(
            types=[&#34;Threat-Actor&#34;],
            stix_id_key=stix_id_key,
            name=name,
            customAttributes=custom_attributes,
        )
        if object_result is not None:
            if update:
                # name
                if object_result[&#34;name&#34;] != name:
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;name&#34;, value=name
                    )
                    object_result[&#34;name&#34;] = name
                # description
                if object_result[&#34;description&#34;] != description:
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;description&#34;, value=description
                    )
                    object_result[&#34;description&#34;] = description
                # alias
                if alias is not None and object_result[&#34;alias&#34;] != alias:
                    if &#34;alias&#34; in object_result:
                        new_aliases = object_result[&#34;alias&#34;] + list(
                            set(alias) - set(object_result[&#34;alias&#34;])
                        )
                    else:
                        new_aliases = alias
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;alias&#34;, value=new_aliases
                    )
                    object_result[&#34;alias&#34;] = new_aliases
                # goal
                if goal is not None and object_result[&#34;goal&#34;] != goal:
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;goal&#34;, value=goal
                    )
                    object_result[&#34;goal&#34;] = goal
                # sophistication
                if (
                    sophistication is not None
                    and object_result[&#34;sophistication&#34;] != sophistication
                ):
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;],
                        key=&#34;sophistication&#34;,
                        value=sophistication,
                    )
                    object_result[&#34;sophistication&#34;] = sophistication
                # resource_level
                if (
                    resource_level is not None
                    and object_result[&#34;resource_level&#34;] != resource_level
                ):
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;],
                        key=&#34;resource_level&#34;,
                        value=resource_level,
                    )
                    object_result[&#34;resource_level&#34;] = resource_level
                # primary_motivation
                if (
                    primary_motivation is not None
                    and object_result[&#34;primary_motivation&#34;] != primary_motivation
                ):
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;],
                        key=&#34;primary_motivation&#34;,
                        value=primary_motivation,
                    )
                    object_result[&#34;primary_motivation&#34;] = primary_motivation
                # secondary_motivation
                if (
                    secondary_motivation is not None
                    and object_result[&#34;secondary_motivation&#34;] != secondary_motivation
                ):
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;],
                        key=&#34;secondary_motivation&#34;,
                        value=secondary_motivation,
                    )
                    object_result[&#34;secondary_motivation&#34;] = secondary_motivation
                # personal_motivation
                if (
                    personal_motivation is not None
                    and object_result[&#34;personal_motivation&#34;] != personal_motivation
                ):
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;],
                        key=&#34;personal_motivation&#34;,
                        value=personal_motivation,
                    )
                    object_result[&#34;personal_motivation&#34;] = personal_motivation
            return object_result
        else:
            return self.create_raw(
                name=name,
                description=description,
                alias=alias,
                goal=goal,
                sophistication=sophistication,
                resource_level=resource_level,
                primary_motivation=primary_motivation,
                secondary_motivation=secondary_motivation,
                personal_motivation=personal_motivation,
                id=id,
                stix_id_key=stix_id_key,
                created=created,
                modified=modified,
                createdByRef=created_by_ref,
                markingDefinitions=marking_definitions,
            )

    &#34;&#34;&#34;
        Export an Threat-Actor object in STIX2
    
        :param id: the id of the Threat-Actor
        :return Threat-Actor object
    &#34;&#34;&#34;

    def to_stix2(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        mode = kwargs.get(&#34;mode&#34;, &#34;simple&#34;)
        max_marking_definition_entity = kwargs.get(
            &#34;max_marking_definition_entity&#34;, None
        )
        entity = kwargs.get(&#34;entity&#34;, None)
        if id is not None and entity is None:
            entity = self.read(id=id)
        if entity is not None:
            threat_actor = dict()
            threat_actor[&#34;id&#34;] = entity[&#34;stix_id_key&#34;]
            threat_actor[&#34;type&#34;] = &#34;threat-actor&#34;
            threat_actor[&#34;name&#34;] = entity[&#34;name&#34;]
            if self.opencti.not_empty(entity[&#34;stix_label&#34;]):
                threat_actor[&#34;labels&#34;] = entity[&#34;stix_label&#34;]
            else:
                threat_actor[&#34;labels&#34;] = [&#34;threat-actor&#34;]
            if self.opencti.not_empty(entity[&#34;alias&#34;]):
                threat_actor[&#34;aliases&#34;] = entity[&#34;alias&#34;]
            if self.opencti.not_empty(entity[&#34;description&#34;]):
                threat_actor[&#34;description&#34;] = entity[&#34;description&#34;]
            if self.opencti.not_empty(entity[&#34;goal&#34;]):
                threat_actor[&#34;goals&#34;] = entity[&#34;goal&#34;]
            if self.opencti.not_empty(entity[&#34;sophistication&#34;]):
                threat_actor[&#34;sophistication&#34;] = entity[&#34;sophistication&#34;]
            if self.opencti.not_empty(entity[&#34;resource_level&#34;]):
                threat_actor[&#34;resource_level&#34;] = entity[&#34;resource_level&#34;]
            if self.opencti.not_empty(entity[&#34;primary_motivation&#34;]):
                threat_actor[&#34;primary_motivation&#34;] = entity[&#34;primary_motivation&#34;]
            if self.opencti.not_empty(entity[&#34;secondary_motivation&#34;]):
                threat_actor[&#34;secondary_motivations&#34;] = entity[&#34;secondary_motivation&#34;]
            threat_actor[&#34;created&#34;] = self.opencti.stix2.format_date(entity[&#34;created&#34;])
            threat_actor[&#34;modified&#34;] = self.opencti.stix2.format_date(
                entity[&#34;modified&#34;]
            )
            threat_actor[CustomProperties.ID] = entity[&#34;id&#34;]
            return self.opencti.stix2.prepare_export(
                entity, threat_actor, mode, max_marking_definition_entity
            )
        else:
            self.opencti.log(&#34;error&#34;, &#34;Missing parameters: id or entity&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pycti.ThreatActor.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create(self, **kwargs):
    name = kwargs.get(&#34;name&#34;, None)
    description = kwargs.get(&#34;description&#34;, None)
    alias = kwargs.get(&#34;alias&#34;, None)
    goal = kwargs.get(&#34;goal&#34;, None)
    sophistication = kwargs.get(&#34;sophistication&#34;, None)
    resource_level = kwargs.get(&#34;resource_level&#34;, None)
    primary_motivation = kwargs.get(&#34;primary_motivation&#34;, None)
    secondary_motivation = kwargs.get(&#34;secondary_motivation&#34;, None)
    personal_motivation = kwargs.get(&#34;personal_motivation&#34;, None)
    id = kwargs.get(&#34;id&#34;, None)
    stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
    created = kwargs.get(&#34;created&#34;, None)
    modified = kwargs.get(&#34;modified&#34;, None)
    created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
    marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)
    update = kwargs.get(&#34;update&#34;, False)
    custom_attributes = &#34;&#34;&#34;
        id
        entity_type
        name
        description 
        alias
        ... on ThreatActor {
            goal
            sophistication
            resource_level
            primary_motivation
            secondary_motivation
            personal_motivation
        }
    &#34;&#34;&#34;
    object_result = self.opencti.stix_domain_entity.get_by_stix_id_or_name(
        types=[&#34;Threat-Actor&#34;],
        stix_id_key=stix_id_key,
        name=name,
        customAttributes=custom_attributes,
    )
    if object_result is not None:
        if update:
            # name
            if object_result[&#34;name&#34;] != name:
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;name&#34;, value=name
                )
                object_result[&#34;name&#34;] = name
            # description
            if object_result[&#34;description&#34;] != description:
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;description&#34;, value=description
                )
                object_result[&#34;description&#34;] = description
            # alias
            if alias is not None and object_result[&#34;alias&#34;] != alias:
                if &#34;alias&#34; in object_result:
                    new_aliases = object_result[&#34;alias&#34;] + list(
                        set(alias) - set(object_result[&#34;alias&#34;])
                    )
                else:
                    new_aliases = alias
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;alias&#34;, value=new_aliases
                )
                object_result[&#34;alias&#34;] = new_aliases
            # goal
            if goal is not None and object_result[&#34;goal&#34;] != goal:
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;goal&#34;, value=goal
                )
                object_result[&#34;goal&#34;] = goal
            # sophistication
            if (
                sophistication is not None
                and object_result[&#34;sophistication&#34;] != sophistication
            ):
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;],
                    key=&#34;sophistication&#34;,
                    value=sophistication,
                )
                object_result[&#34;sophistication&#34;] = sophistication
            # resource_level
            if (
                resource_level is not None
                and object_result[&#34;resource_level&#34;] != resource_level
            ):
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;],
                    key=&#34;resource_level&#34;,
                    value=resource_level,
                )
                object_result[&#34;resource_level&#34;] = resource_level
            # primary_motivation
            if (
                primary_motivation is not None
                and object_result[&#34;primary_motivation&#34;] != primary_motivation
            ):
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;],
                    key=&#34;primary_motivation&#34;,
                    value=primary_motivation,
                )
                object_result[&#34;primary_motivation&#34;] = primary_motivation
            # secondary_motivation
            if (
                secondary_motivation is not None
                and object_result[&#34;secondary_motivation&#34;] != secondary_motivation
            ):
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;],
                    key=&#34;secondary_motivation&#34;,
                    value=secondary_motivation,
                )
                object_result[&#34;secondary_motivation&#34;] = secondary_motivation
            # personal_motivation
            if (
                personal_motivation is not None
                and object_result[&#34;personal_motivation&#34;] != personal_motivation
            ):
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;],
                    key=&#34;personal_motivation&#34;,
                    value=personal_motivation,
                )
                object_result[&#34;personal_motivation&#34;] = personal_motivation
        return object_result
    else:
        return self.create_raw(
            name=name,
            description=description,
            alias=alias,
            goal=goal,
            sophistication=sophistication,
            resource_level=resource_level,
            primary_motivation=primary_motivation,
            secondary_motivation=secondary_motivation,
            personal_motivation=personal_motivation,
            id=id,
            stix_id_key=stix_id_key,
            created=created,
            modified=modified,
            createdByRef=created_by_ref,
            markingDefinitions=marking_definitions,
        )</code></pre>
</details>
</dd>
<dt id="pycti.ThreatActor.create_raw"><code class="name flex">
<span>def <span class="ident">create_raw</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_raw(self, **kwargs):
    name = kwargs.get(&#34;name&#34;, None)
    description = kwargs.get(&#34;description&#34;, None)
    alias = kwargs.get(&#34;alias&#34;, None)
    goal = kwargs.get(&#34;goal&#34;, None)
    sophistication = kwargs.get(&#34;sophistication&#34;, None)
    resource_level = kwargs.get(&#34;resource_level&#34;, None)
    primary_motivation = kwargs.get(&#34;primary_motivation&#34;, None)
    secondary_motivation = kwargs.get(&#34;secondary_motivation&#34;, None)
    personal_motivation = kwargs.get(&#34;personal_motivation&#34;, None)
    id = kwargs.get(&#34;id&#34;, None)
    stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
    created = kwargs.get(&#34;created&#34;, None)
    modified = kwargs.get(&#34;modified&#34;, None)
    created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
    marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)

    if name is not None and description is not None:
        self.opencti.log(&#34;info&#34;, &#34;Creating Threat-Actor {&#34; + name + &#34;}.&#34;)
        query = (
            &#34;&#34;&#34;
            mutation ThreatActorAdd($input: ThreatActorAddInput) {
                threatActorAdd(input: $input) {
                    &#34;&#34;&#34;
            + self.properties
            + &#34;&#34;&#34;
                }
            }
        &#34;&#34;&#34;
        )
        result = self.opencti.query(
            query,
            {
                &#34;input&#34;: {
                    &#34;name&#34;: name,
                    &#34;description&#34;: description,
                    &#34;alias&#34;: alias,
                    &#34;goal&#34;: goal,
                    &#34;sophistication&#34;: sophistication,
                    &#34;resource_level&#34;: resource_level,
                    &#34;primary_motivation&#34;: primary_motivation,
                    &#34;secondary_motivation&#34;: secondary_motivation,
                    &#34;personal_motivation&#34;: personal_motivation,
                    &#34;internal_id_key&#34;: id,
                    &#34;stix_id_key&#34;: stix_id_key,
                    &#34;created&#34;: created,
                    &#34;modified&#34;: modified,
                    &#34;createdByRef&#34;: created_by_ref,
                    &#34;markingDefinitions&#34;: marking_definitions,
                }
            },
        )
        return self.opencti.process_multiple_fields(
            result[&#34;data&#34;][&#34;threatActorAdd&#34;]
        )
    else:
        self.opencti.log(
            &#34;error&#34;,
            &#34;[opencti_threat_actor] Missing parameters: name and description&#34;,
        )</code></pre>
</details>
</dd>
<dt id="pycti.ThreatActor.list"><code class="name flex">
<span>def <span class="ident">list</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list(self, **kwargs):
    filters = kwargs.get(&#34;filters&#34;, None)
    search = kwargs.get(&#34;search&#34;, None)
    first = kwargs.get(&#34;first&#34;, 500)
    after = kwargs.get(&#34;after&#34;, None)
    order_by = kwargs.get(&#34;orderBy&#34;, None)
    order_mode = kwargs.get(&#34;orderMode&#34;, None)
    get_all = kwargs.get(&#34;getAll&#34;, False)
    if get_all:
        first = 500

    self.opencti.log(
        &#34;info&#34;, &#34;Listing Threat-Actors with filters &#34; + json.dumps(filters) + &#34;.&#34;
    )
    query = (
        &#34;&#34;&#34;
        query ThreatActors($filters: [ThreatActorsFiltering], $search: String, $first: Int, $after: ID, $orderBy: ThreatActorsOrdering, $orderMode: OrderingMode) {
            threatActors(filters: $filters, search: $search, first: $first, after: $after, orderBy: $orderBy, orderMode: $orderMode) {
                edges {
                    node {
                        &#34;&#34;&#34;
        + self.properties
        + &#34;&#34;&#34;
                    }
                }
                pageInfo {
                    startCursor
                    endCursor
                    hasNextPage
                    hasPreviousPage
                    globalCount
                }
            }
        }
    &#34;&#34;&#34;
    )
    result = self.opencti.query(
        query,
        {
            &#34;filters&#34;: filters,
            &#34;search&#34;: search,
            &#34;first&#34;: first,
            &#34;after&#34;: after,
            &#34;orderBy&#34;: order_by,
            &#34;orderMode&#34;: order_mode,
        },
    )
    return self.opencti.process_multiple(result[&#34;data&#34;][&#34;threatActors&#34;])</code></pre>
</details>
</dd>
<dt id="pycti.ThreatActor.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    filters = kwargs.get(&#34;filters&#34;, None)
    custom_attributes = kwargs.get(&#34;customAttributes&#34;, None)
    if id is not None:
        self.opencti.log(&#34;info&#34;, &#34;Reading Threat-Actor {&#34; + id + &#34;}.&#34;)
        query = (
            &#34;&#34;&#34;
            query ThreatActor($id: String!) {
                threatActor(id: $id) {
                    &#34;&#34;&#34;
            + (
                custom_attributes
                if custom_attributes is not None
                else self.properties
            )
            + &#34;&#34;&#34;
                }
            }
         &#34;&#34;&#34;
        )
        result = self.opencti.query(query, {&#34;id&#34;: id})
        return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;threatActor&#34;])
    elif filters is not None:
        result = self.list(filters=filters)
        if len(result) &gt; 0:
            return result[0]
        else:
            return None
    else:
        self.opencti.log(
            &#34;error&#34;, &#34;[opencti_threat_actor] Missing parameters: id or filters&#34;
        )
        return None</code></pre>
</details>
</dd>
<dt id="pycti.ThreatActor.to_stix2"><code class="name flex">
<span>def <span class="ident">to_stix2</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_stix2(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    mode = kwargs.get(&#34;mode&#34;, &#34;simple&#34;)
    max_marking_definition_entity = kwargs.get(
        &#34;max_marking_definition_entity&#34;, None
    )
    entity = kwargs.get(&#34;entity&#34;, None)
    if id is not None and entity is None:
        entity = self.read(id=id)
    if entity is not None:
        threat_actor = dict()
        threat_actor[&#34;id&#34;] = entity[&#34;stix_id_key&#34;]
        threat_actor[&#34;type&#34;] = &#34;threat-actor&#34;
        threat_actor[&#34;name&#34;] = entity[&#34;name&#34;]
        if self.opencti.not_empty(entity[&#34;stix_label&#34;]):
            threat_actor[&#34;labels&#34;] = entity[&#34;stix_label&#34;]
        else:
            threat_actor[&#34;labels&#34;] = [&#34;threat-actor&#34;]
        if self.opencti.not_empty(entity[&#34;alias&#34;]):
            threat_actor[&#34;aliases&#34;] = entity[&#34;alias&#34;]
        if self.opencti.not_empty(entity[&#34;description&#34;]):
            threat_actor[&#34;description&#34;] = entity[&#34;description&#34;]
        if self.opencti.not_empty(entity[&#34;goal&#34;]):
            threat_actor[&#34;goals&#34;] = entity[&#34;goal&#34;]
        if self.opencti.not_empty(entity[&#34;sophistication&#34;]):
            threat_actor[&#34;sophistication&#34;] = entity[&#34;sophistication&#34;]
        if self.opencti.not_empty(entity[&#34;resource_level&#34;]):
            threat_actor[&#34;resource_level&#34;] = entity[&#34;resource_level&#34;]
        if self.opencti.not_empty(entity[&#34;primary_motivation&#34;]):
            threat_actor[&#34;primary_motivation&#34;] = entity[&#34;primary_motivation&#34;]
        if self.opencti.not_empty(entity[&#34;secondary_motivation&#34;]):
            threat_actor[&#34;secondary_motivations&#34;] = entity[&#34;secondary_motivation&#34;]
        threat_actor[&#34;created&#34;] = self.opencti.stix2.format_date(entity[&#34;created&#34;])
        threat_actor[&#34;modified&#34;] = self.opencti.stix2.format_date(
            entity[&#34;modified&#34;]
        )
        threat_actor[CustomProperties.ID] = entity[&#34;id&#34;]
        return self.opencti.stix2.prepare_export(
            entity, threat_actor, mode, max_marking_definition_entity
        )
    else:
        self.opencti.log(&#34;error&#34;, &#34;Missing parameters: id or entity&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pycti.Tool"><code class="flex name class">
<span>class <span class="ident">Tool</span></span>
<span>(</span><span>opencti)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Tool:
    def __init__(self, opencti):
        self.opencti = opencti
        self.properties = &#34;&#34;&#34;
            id
            stix_id_key
            stix_label
            entity_type
            parent_types
            name
            alias
            description
            graph_data
            tool_version
            created
            modified            
            created_at
            updated_at
            createdByRef {
                node {
                    id
                    entity_type
                    stix_id_key
                    stix_label
                    name
                    alias
                    description
                    created
                    modified
                    ... on Organization {
                        organization_class
                    }
                }
                relation {
                    id
                }
            }            
            markingDefinitions {
                edges {
                    node {
                        id
                        entity_type
                        stix_id_key
                        definition_type
                        definition
                        level
                        color
                        created
                        modified
                    }
                    relation {
                        id
                    }
                }
            }
            tags {
                edges {
                    node {
                        id
                        tag_type
                        value
                        color
                    }
                    relation {
                        id
                    }
                }
            }
            externalReferences {
                edges {
                    node {
                        id
                        entity_type
                        stix_id_key
                        source_name
                        description
                        url
                        hash
                        external_id
                        created
                        modified
                    }
                    relation {
                        id
                    }
                }
            }     
        &#34;&#34;&#34;

    &#34;&#34;&#34;
        List Tool objects

        :param filters: the filters to apply
        :param search: the search keyword
        :param first: return the first n rows from the after ID (or the beginning if not set)
        :param after: ID of the first row for pagination
        :return List of Tool objects
    &#34;&#34;&#34;

    def list(self, **kwargs):
        filters = kwargs.get(&#34;filters&#34;, None)
        search = kwargs.get(&#34;search&#34;, None)
        first = kwargs.get(&#34;first&#34;, 500)
        after = kwargs.get(&#34;after&#34;, None)
        order_by = kwargs.get(&#34;orderBy&#34;, None)
        order_mode = kwargs.get(&#34;orderMode&#34;, None)
        get_all = kwargs.get(&#34;getAll&#34;, False)
        if get_all:
            first = 500

        self.opencti.log(
            &#34;info&#34;, &#34;Listing Tools with filters &#34; + json.dumps(filters) + &#34;.&#34;
        )
        query = (
            &#34;&#34;&#34;
            query Tools($filters: [ToolsFiltering], $search: String, $first: Int, $after: ID, $orderBy: ToolsOrdering, $orderMode: OrderingMode) {
                tools(filters: $filters, search: $search, first: $first, after: $after, orderBy: $orderBy, orderMode: $orderMode) {
                    edges {
                        node {
                            &#34;&#34;&#34;
            + self.properties
            + &#34;&#34;&#34;
                        }
                    }
                    pageInfo {
                        startCursor
                        endCursor
                        hasNextPage
                        hasPreviousPage
                        globalCount
                    }
                }
            }
        &#34;&#34;&#34;
        )
        result = self.opencti.query(
            query,
            {
                &#34;filters&#34;: filters,
                &#34;search&#34;: search,
                &#34;first&#34;: first,
                &#34;after&#34;: after,
                &#34;orderBy&#34;: order_by,
                &#34;orderMode&#34;: order_mode,
            },
        )
        return self.opencti.process_multiple(result[&#34;data&#34;][&#34;tools&#34;])

    &#34;&#34;&#34;
        Read a Tool object
        
        :param id: the id of the Tool
        :param filters: the filters to apply if no id provided
        :return Tool object
    &#34;&#34;&#34;

    def read(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        filters = kwargs.get(&#34;filters&#34;, None)
        custom_attributes = kwargs.get(&#34;customAttributes&#34;, None)
        if id is not None:
            self.opencti.log(&#34;info&#34;, &#34;Reading Tool {&#34; + id + &#34;}.&#34;)
            query = (
                &#34;&#34;&#34;
                query Tool($id: String!) {
                    tool(id: $id) {
                        &#34;&#34;&#34;
                + (
                    custom_attributes
                    if custom_attributes is not None
                    else self.properties
                )
                + &#34;&#34;&#34;
                    }
                }
             &#34;&#34;&#34;
            )
            result = self.opencti.query(query, {&#34;id&#34;: id})
            return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;tool&#34;])
        elif filters is not None:
            result = self.list(filters=filters)
            if len(result) &gt; 0:
                return result[0]
            else:
                return None
        else:
            self.opencti.log(
                &#34;error&#34;, &#34;[opencti_tool] Missing parameters: id or filters&#34;
            )
            return None

    &#34;&#34;&#34;
        Create a Tool object

        :param name: the name of the Tool
        :return Tool object
    &#34;&#34;&#34;

    def create_raw(self, **kwargs):
        name = kwargs.get(&#34;name&#34;, None)
        description = kwargs.get(&#34;description&#34;, None)
        alias = kwargs.get(&#34;alias&#34;, None)
        id = kwargs.get(&#34;id&#34;, None)
        stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
        created = kwargs.get(&#34;created&#34;, None)
        modified = kwargs.get(&#34;modified&#34;, None)
        created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
        marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)

        if name is not None and description is not None:
            self.opencti.log(&#34;info&#34;, &#34;Creating Tool {&#34; + name + &#34;}.&#34;)
            query = (
                &#34;&#34;&#34;
                mutation ToolAdd($input: ToolAddInput) {
                    toolAdd(input: $input) {
                        &#34;&#34;&#34;
                + self.properties
                + &#34;&#34;&#34;
                    }
                }
            &#34;&#34;&#34;
            )
            result = self.opencti.query(
                query,
                {
                    &#34;input&#34;: {
                        &#34;name&#34;: name,
                        &#34;description&#34;: description,
                        &#34;alias&#34;: alias,
                        &#34;internal_id_key&#34;: id,
                        &#34;stix_id_key&#34;: stix_id_key,
                        &#34;created&#34;: created,
                        &#34;modified&#34;: modified,
                        &#34;createdByRef&#34;: created_by_ref,
                        &#34;markingDefinitions&#34;: marking_definitions,
                    }
                },
            )
            return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;toolAdd&#34;])
        else:
            self.opencti.log(
                &#34;error&#34;, &#34;[opencti_tool] Missing parameters: name and description&#34;
            )

    &#34;&#34;&#34;
        Create a Tool object only if it not exists, update it on request

        :param name: the name of the Tool
        :return Tool object
    &#34;&#34;&#34;

    def create(self, **kwargs):
        name = kwargs.get(&#34;name&#34;, None)
        description = kwargs.get(&#34;description&#34;, None)
        alias = kwargs.get(&#34;alias&#34;, None)
        id = kwargs.get(&#34;id&#34;, None)
        stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
        created = kwargs.get(&#34;created&#34;, None)
        modified = kwargs.get(&#34;modified&#34;, None)
        created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
        marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)
        update = kwargs.get(&#34;update&#34;, False)
        custom_attributes = &#34;&#34;&#34;
            id
            entity_type
            name
            description 
            alias
        &#34;&#34;&#34;
        object_result = self.opencti.stix_domain_entity.get_by_stix_id_or_name(
            types=[&#34;Tool&#34;],
            stix_id_key=stix_id_key,
            name=name,
            customAttributes=custom_attributes,
        )
        if object_result is not None:
            if update:
                # name
                if object_result[&#34;name&#34;] != name:
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;name&#34;, value=name
                    )
                    object_result[&#34;name&#34;] = name
                # description
                if object_result[&#34;description&#34;] != description:
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;description&#34;, value=description
                    )
                    object_result[&#34;description&#34;] = description
                # alias
                if alias is not None and object_result[&#34;alias&#34;] != alias:
                    if &#34;alias&#34; in object_result:
                        new_aliases = object_result[&#34;alias&#34;] + list(
                            set(alias) - set(object_result[&#34;alias&#34;])
                        )
                    else:
                        new_aliases = alias
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;alias&#34;, value=new_aliases
                    )
                    object_result[&#34;alias&#34;] = new_aliases
            return object_result
        else:
            return self.create_raw(
                name=name,
                description=description,
                alias=alias,
                id=id,
                stix_id_key=stix_id_key,
                created=created,
                modified=modified,
                createdByRef=created_by_ref,
                markingDefinitions=marking_definitions,
            )

    &#34;&#34;&#34;
        Export an Tool object in STIX2
    
        :param id: the id of the Tool
        :return Tool object
    &#34;&#34;&#34;

    def to_stix2(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        mode = kwargs.get(&#34;mode&#34;, &#34;simple&#34;)
        max_marking_definition_entity = kwargs.get(
            &#34;max_marking_definition_entity&#34;, None
        )
        entity = kwargs.get(&#34;entity&#34;, None)
        if id is not None and entity is None:
            entity = self.read(id=id)
        if entity is not None:
            entity = self.read(id=id)
            tool = dict()
            tool[&#34;id&#34;] = entity[&#34;stix_id_key&#34;]
            tool[&#34;type&#34;] = &#34;tool&#34;
            tool[&#34;name&#34;] = entity[&#34;name&#34;]
            if self.opencti.not_empty(entity[&#34;stix_label&#34;]):
                tool[&#34;labels&#34;] = entity[&#34;stix_label&#34;]
            else:
                tool[&#34;labels&#34;] = [&#34;tool&#34;]
            if self.opencti.not_empty(entity[&#34;description&#34;]):
                tool[&#34;description&#34;] = entity[&#34;description&#34;]
            if self.opencti.not_empty(entity[&#34;tool_version&#34;]):
                tool[&#34;tool_version&#34;] = entity[&#34;tool_version&#34;]
            tool[&#34;created&#34;] = self.opencti.stix2.format_date(entity[&#34;created&#34;])
            tool[&#34;modified&#34;] = self.opencti.stix2.format_date(entity[&#34;modified&#34;])
            if self.opencti.not_empty(entity[&#34;alias&#34;]):
                tool[CustomProperties.ALIASES] = entity[&#34;alias&#34;]
            tool[CustomProperties.ID] = entity[&#34;id&#34;]
            return self.opencti.stix2.prepare_export(
                entity, tool, mode, max_marking_definition_entity
            )
        else:
            self.opencti.log(&#34;error&#34;, &#34;Missing parameters: id or entity&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pycti.Tool.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create(self, **kwargs):
    name = kwargs.get(&#34;name&#34;, None)
    description = kwargs.get(&#34;description&#34;, None)
    alias = kwargs.get(&#34;alias&#34;, None)
    id = kwargs.get(&#34;id&#34;, None)
    stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
    created = kwargs.get(&#34;created&#34;, None)
    modified = kwargs.get(&#34;modified&#34;, None)
    created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
    marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)
    update = kwargs.get(&#34;update&#34;, False)
    custom_attributes = &#34;&#34;&#34;
        id
        entity_type
        name
        description 
        alias
    &#34;&#34;&#34;
    object_result = self.opencti.stix_domain_entity.get_by_stix_id_or_name(
        types=[&#34;Tool&#34;],
        stix_id_key=stix_id_key,
        name=name,
        customAttributes=custom_attributes,
    )
    if object_result is not None:
        if update:
            # name
            if object_result[&#34;name&#34;] != name:
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;name&#34;, value=name
                )
                object_result[&#34;name&#34;] = name
            # description
            if object_result[&#34;description&#34;] != description:
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;description&#34;, value=description
                )
                object_result[&#34;description&#34;] = description
            # alias
            if alias is not None and object_result[&#34;alias&#34;] != alias:
                if &#34;alias&#34; in object_result:
                    new_aliases = object_result[&#34;alias&#34;] + list(
                        set(alias) - set(object_result[&#34;alias&#34;])
                    )
                else:
                    new_aliases = alias
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;alias&#34;, value=new_aliases
                )
                object_result[&#34;alias&#34;] = new_aliases
        return object_result
    else:
        return self.create_raw(
            name=name,
            description=description,
            alias=alias,
            id=id,
            stix_id_key=stix_id_key,
            created=created,
            modified=modified,
            createdByRef=created_by_ref,
            markingDefinitions=marking_definitions,
        )</code></pre>
</details>
</dd>
<dt id="pycti.Tool.create_raw"><code class="name flex">
<span>def <span class="ident">create_raw</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_raw(self, **kwargs):
    name = kwargs.get(&#34;name&#34;, None)
    description = kwargs.get(&#34;description&#34;, None)
    alias = kwargs.get(&#34;alias&#34;, None)
    id = kwargs.get(&#34;id&#34;, None)
    stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
    created = kwargs.get(&#34;created&#34;, None)
    modified = kwargs.get(&#34;modified&#34;, None)
    created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
    marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)

    if name is not None and description is not None:
        self.opencti.log(&#34;info&#34;, &#34;Creating Tool {&#34; + name + &#34;}.&#34;)
        query = (
            &#34;&#34;&#34;
            mutation ToolAdd($input: ToolAddInput) {
                toolAdd(input: $input) {
                    &#34;&#34;&#34;
            + self.properties
            + &#34;&#34;&#34;
                }
            }
        &#34;&#34;&#34;
        )
        result = self.opencti.query(
            query,
            {
                &#34;input&#34;: {
                    &#34;name&#34;: name,
                    &#34;description&#34;: description,
                    &#34;alias&#34;: alias,
                    &#34;internal_id_key&#34;: id,
                    &#34;stix_id_key&#34;: stix_id_key,
                    &#34;created&#34;: created,
                    &#34;modified&#34;: modified,
                    &#34;createdByRef&#34;: created_by_ref,
                    &#34;markingDefinitions&#34;: marking_definitions,
                }
            },
        )
        return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;toolAdd&#34;])
    else:
        self.opencti.log(
            &#34;error&#34;, &#34;[opencti_tool] Missing parameters: name and description&#34;
        )</code></pre>
</details>
</dd>
<dt id="pycti.Tool.list"><code class="name flex">
<span>def <span class="ident">list</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list(self, **kwargs):
    filters = kwargs.get(&#34;filters&#34;, None)
    search = kwargs.get(&#34;search&#34;, None)
    first = kwargs.get(&#34;first&#34;, 500)
    after = kwargs.get(&#34;after&#34;, None)
    order_by = kwargs.get(&#34;orderBy&#34;, None)
    order_mode = kwargs.get(&#34;orderMode&#34;, None)
    get_all = kwargs.get(&#34;getAll&#34;, False)
    if get_all:
        first = 500

    self.opencti.log(
        &#34;info&#34;, &#34;Listing Tools with filters &#34; + json.dumps(filters) + &#34;.&#34;
    )
    query = (
        &#34;&#34;&#34;
        query Tools($filters: [ToolsFiltering], $search: String, $first: Int, $after: ID, $orderBy: ToolsOrdering, $orderMode: OrderingMode) {
            tools(filters: $filters, search: $search, first: $first, after: $after, orderBy: $orderBy, orderMode: $orderMode) {
                edges {
                    node {
                        &#34;&#34;&#34;
        + self.properties
        + &#34;&#34;&#34;
                    }
                }
                pageInfo {
                    startCursor
                    endCursor
                    hasNextPage
                    hasPreviousPage
                    globalCount
                }
            }
        }
    &#34;&#34;&#34;
    )
    result = self.opencti.query(
        query,
        {
            &#34;filters&#34;: filters,
            &#34;search&#34;: search,
            &#34;first&#34;: first,
            &#34;after&#34;: after,
            &#34;orderBy&#34;: order_by,
            &#34;orderMode&#34;: order_mode,
        },
    )
    return self.opencti.process_multiple(result[&#34;data&#34;][&#34;tools&#34;])</code></pre>
</details>
</dd>
<dt id="pycti.Tool.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    filters = kwargs.get(&#34;filters&#34;, None)
    custom_attributes = kwargs.get(&#34;customAttributes&#34;, None)
    if id is not None:
        self.opencti.log(&#34;info&#34;, &#34;Reading Tool {&#34; + id + &#34;}.&#34;)
        query = (
            &#34;&#34;&#34;
            query Tool($id: String!) {
                tool(id: $id) {
                    &#34;&#34;&#34;
            + (
                custom_attributes
                if custom_attributes is not None
                else self.properties
            )
            + &#34;&#34;&#34;
                }
            }
         &#34;&#34;&#34;
        )
        result = self.opencti.query(query, {&#34;id&#34;: id})
        return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;tool&#34;])
    elif filters is not None:
        result = self.list(filters=filters)
        if len(result) &gt; 0:
            return result[0]
        else:
            return None
    else:
        self.opencti.log(
            &#34;error&#34;, &#34;[opencti_tool] Missing parameters: id or filters&#34;
        )
        return None</code></pre>
</details>
</dd>
<dt id="pycti.Tool.to_stix2"><code class="name flex">
<span>def <span class="ident">to_stix2</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_stix2(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    mode = kwargs.get(&#34;mode&#34;, &#34;simple&#34;)
    max_marking_definition_entity = kwargs.get(
        &#34;max_marking_definition_entity&#34;, None
    )
    entity = kwargs.get(&#34;entity&#34;, None)
    if id is not None and entity is None:
        entity = self.read(id=id)
    if entity is not None:
        entity = self.read(id=id)
        tool = dict()
        tool[&#34;id&#34;] = entity[&#34;stix_id_key&#34;]
        tool[&#34;type&#34;] = &#34;tool&#34;
        tool[&#34;name&#34;] = entity[&#34;name&#34;]
        if self.opencti.not_empty(entity[&#34;stix_label&#34;]):
            tool[&#34;labels&#34;] = entity[&#34;stix_label&#34;]
        else:
            tool[&#34;labels&#34;] = [&#34;tool&#34;]
        if self.opencti.not_empty(entity[&#34;description&#34;]):
            tool[&#34;description&#34;] = entity[&#34;description&#34;]
        if self.opencti.not_empty(entity[&#34;tool_version&#34;]):
            tool[&#34;tool_version&#34;] = entity[&#34;tool_version&#34;]
        tool[&#34;created&#34;] = self.opencti.stix2.format_date(entity[&#34;created&#34;])
        tool[&#34;modified&#34;] = self.opencti.stix2.format_date(entity[&#34;modified&#34;])
        if self.opencti.not_empty(entity[&#34;alias&#34;]):
            tool[CustomProperties.ALIASES] = entity[&#34;alias&#34;]
        tool[CustomProperties.ID] = entity[&#34;id&#34;]
        return self.opencti.stix2.prepare_export(
            entity, tool, mode, max_marking_definition_entity
        )
    else:
        self.opencti.log(&#34;error&#34;, &#34;Missing parameters: id or entity&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pycti.Vulnerability"><code class="flex name class">
<span>class <span class="ident">Vulnerability</span></span>
<span>(</span><span>opencti)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Vulnerability:
    def __init__(self, opencti):
        self.opencti = opencti
        self.properties = &#34;&#34;&#34;
            id
            stix_id_key
            stix_label
            entity_type
            parent_types
            name
            alias
            description
            base_score
            base_severity
            attack_vector
            integrity_impact
            availability_impact
            graph_data
            created
            modified            
            created_at
            updated_at
            createdByRef {
                node {
                    id
                    entity_type
                    stix_id_key
                    stix_label
                    name
                    alias
                    description
                    created
                    modified
                    ... on Organization {
                        organization_class
                    }
                }
                relation {
                    id
                }
            }            
            markingDefinitions {
                edges {
                    node {
                        id
                        entity_type
                        stix_id_key
                        definition_type
                        definition
                        level
                        color
                        created
                        modified
                    }
                    relation {
                        id
                    }
                }
            }
            tags {
                edges {
                    node {
                        id
                        tag_type
                        value
                        color
                    }
                    relation {
                        id
                    }
                }
            } 
            externalReferences {
                edges {
                    node {
                        id
                        entity_type
                        stix_id_key
                        source_name
                        description
                        url
                        hash
                        external_id
                        created
                        modified
                    }
                    relation {
                        id
                    }
                }
            }      
        &#34;&#34;&#34;

    &#34;&#34;&#34;
        List Vulnerability objects

        :param filters: the filters to apply
        :param search: the search keyword
        :param first: return the first n rows from the after ID (or the beginning if not set)
        :param after: ID of the first row for pagination
        :return List of Vulnerability objects
    &#34;&#34;&#34;

    def list(self, **kwargs):
        filters = kwargs.get(&#34;filters&#34;, None)
        search = kwargs.get(&#34;search&#34;, None)
        first = kwargs.get(&#34;first&#34;, 500)
        after = kwargs.get(&#34;after&#34;, None)
        order_by = kwargs.get(&#34;orderBy&#34;, None)
        order_mode = kwargs.get(&#34;orderMode&#34;, None)
        get_all = kwargs.get(&#34;getAll&#34;, False)
        if get_all:
            first = 500

        self.opencti.log(
            &#34;info&#34;, &#34;Listing Vulnerabilities with filters &#34; + json.dumps(filters) + &#34;.&#34;
        )
        query = (
            &#34;&#34;&#34;
            query Vulnerabilities($filters: [VulnerabilitiesFiltering], $search: String, $first: Int, $after: ID, $orderBy: VulnerabilitiesOrdering, $orderMode: OrderingMode) {
                vulnerabilities(filters: $filters, search: $search, first: $first, after: $after, orderBy: $orderBy, orderMode: $orderMode) {
                    edges {
                        node {
                            &#34;&#34;&#34;
            + self.properties
            + &#34;&#34;&#34;
                        }
                    }
                    pageInfo {
                        startCursor
                        endCursor
                        hasNextPage
                        hasPreviousPage
                        globalCount
                    }
                }
            }
        &#34;&#34;&#34;
        )
        result = self.opencti.query(
            query,
            {
                &#34;filters&#34;: filters,
                &#34;search&#34;: search,
                &#34;first&#34;: first,
                &#34;after&#34;: after,
                &#34;orderBy&#34;: order_by,
                &#34;orderMode&#34;: order_mode,
            },
        )

        if get_all:
            final_data = []
            data = self.opencti.process_multiple(result[&#34;data&#34;][&#34;vulnerabilities&#34;])
            final_data = final_data + data
            while result[&#34;data&#34;][&#34;vulnerabilities&#34;][&#34;pageInfo&#34;][&#34;hasNextPage&#34;]:
                after = result[&#34;data&#34;][&#34;vulnerabilities&#34;][&#34;pageInfo&#34;][&#34;endCursor&#34;]
                self.opencti.log(&#34;info&#34;, &#34;Listing Vulnerabilities after &#34; + after)
                result = self.opencti.query(
                    query,
                    {
                        &#34;filters&#34;: filters,
                        &#34;search&#34;: search,
                        &#34;first&#34;: first,
                        &#34;after&#34;: after,
                        &#34;orderBy&#34;: order_by,
                        &#34;orderMode&#34;: order_mode,
                    },
                )
                data = self.opencti.process_multiple(result[&#34;data&#34;][&#34;vulnerabilities&#34;])
                final_data = final_data + data
            return final_data
        else:
            return self.opencti.process_multiple(result[&#34;data&#34;][&#34;vulnerabilities&#34;])

    &#34;&#34;&#34;
        Read a Vulnerability object
        
        :param id: the id of the Vulnerability
        :param filters: the filters to apply if no id provided
        :return Vulnerability object
    &#34;&#34;&#34;

    def read(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        filters = kwargs.get(&#34;filters&#34;, None)
        custom_attributes = kwargs.get(&#34;customAttributes&#34;, None)
        if id is not None:
            self.opencti.log(&#34;info&#34;, &#34;Reading Vulnerability {&#34; + id + &#34;}.&#34;)
            query = (
                &#34;&#34;&#34;
                query Vulnerability($id: String!) {
                    vulnerability(id: $id) {
                        &#34;&#34;&#34;
                + (
                    custom_attributes
                    if custom_attributes is not None
                    else self.properties
                )
                + &#34;&#34;&#34;
                    }
                }
             &#34;&#34;&#34;
            )
            result = self.opencti.query(query, {&#34;id&#34;: id})
            return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;vulnerability&#34;])
        elif filters is not None:
            result = self.list(filters=filters)
            if len(result) &gt; 0:
                return result[0]
            else:
                return None
        else:
            self.opencti.log(
                &#34;error&#34;, &#34;[opencti_tool] Missing parameters: id or filters&#34;
            )
            return None

    &#34;&#34;&#34;
        Create a Vulnerability object

        :param name: the name of the Vulnerability
        :return Vulnerability object
    &#34;&#34;&#34;

    def create_raw(self, **kwargs):
        name = kwargs.get(&#34;name&#34;, None)
        description = kwargs.get(&#34;description&#34;, None)
        alias = kwargs.get(&#34;alias&#34;, None)
        base_score = kwargs.get(&#34;base_score&#34;, None)
        base_severity = kwargs.get(&#34;base_severity&#34;, None)
        attack_vector = kwargs.get(&#34;attack_vector&#34;, None)
        integrity_impact = kwargs.get(&#34;integrity_impact&#34;, None)
        availability_impact = kwargs.get(&#34;availability_impact&#34;, None)
        id = kwargs.get(&#34;id&#34;, None)
        stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
        created = kwargs.get(&#34;created&#34;, None)
        modified = kwargs.get(&#34;modified&#34;, None)
        created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
        marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)

        if name is not None and description is not None:
            self.opencti.log(&#34;info&#34;, &#34;Creating Vulnerability {&#34; + name + &#34;}.&#34;)
            query = (
                &#34;&#34;&#34;
                mutation VulnerabilityAdd($input: VulnerabilityAddInput) {
                    vulnerabilityAdd(input: $input) {
                        &#34;&#34;&#34;
                + self.properties
                + &#34;&#34;&#34;
                    }
                }
            &#34;&#34;&#34;
            )
            result = self.opencti.query(
                query,
                {
                    &#34;input&#34;: {
                        &#34;name&#34;: name,
                        &#34;description&#34;: description,
                        &#34;alias&#34;: alias,
                        &#34;base_score&#34;: base_score,
                        &#34;base_severity&#34;: base_severity,
                        &#34;attack_vector&#34;: attack_vector,
                        &#34;integrity_impact&#34;: integrity_impact,
                        &#34;availability_impact&#34;: availability_impact,
                        &#34;internal_id_key&#34;: id,
                        &#34;stix_id_key&#34;: stix_id_key,
                        &#34;created&#34;: created,
                        &#34;modified&#34;: modified,
                        &#34;createdByRef&#34;: created_by_ref,
                        &#34;markingDefinitions&#34;: marking_definitions,
                    }
                },
            )
            return self.opencti.process_multiple_fields(
                result[&#34;data&#34;][&#34;vulnerabilityAdd&#34;]
            )
        else:
            self.opencti.log(
                &#34;error&#34;,
                &#34;[opencti_vulnerability] Missing parameters: name and description&#34;,
            )

    &#34;&#34;&#34;
        Create a Vulnerability object only if it not exists, update it on request

        :param name: the name of the Vulnerability
        :return Vulnerability object
    &#34;&#34;&#34;

    def create(self, **kwargs):
        name = kwargs.get(&#34;name&#34;, None)
        description = kwargs.get(&#34;description&#34;, None)
        alias = kwargs.get(&#34;alias&#34;, None)
        base_score = kwargs.get(&#34;base_score&#34;, None)
        base_severity = kwargs.get(&#34;base_severity&#34;, None)
        attack_vector = kwargs.get(&#34;attack_vector&#34;, None)
        integrity_impact = kwargs.get(&#34;integrity_impact&#34;, None)
        availability_impact = kwargs.get(&#34;availability_impact&#34;, None)
        id = kwargs.get(&#34;id&#34;, None)
        stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
        created = kwargs.get(&#34;created&#34;, None)
        modified = kwargs.get(&#34;modified&#34;, None)
        created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
        marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)
        update = kwargs.get(&#34;update&#34;, False)
        custom_attributes = &#34;&#34;&#34;
            id
            entity_type
            name
            description 
            alias
            ... on Vulnerability {
                base_score
                base_severity
                attack_vector
                integrity_impact
                availability_impact
            }
        &#34;&#34;&#34;
        object_result = self.opencti.stix_domain_entity.get_by_stix_id_or_name(
            types=[&#34;Vulnerability&#34;],
            stix_id_key=stix_id_key,
            name=name,
            customAttributes=custom_attributes,
        )
        if object_result is not None:
            if update:
                # name
                if object_result[&#34;name&#34;] != name:
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;name&#34;, value=name
                    )
                    object_result[&#34;name&#34;] = name
                # description
                if object_result[&#34;description&#34;] != description:
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;description&#34;, value=description
                    )
                    object_result[&#34;description&#34;] = description
                # alias
                if alias is not None and object_result[&#34;alias&#34;] != alias:
                    if &#34;alias&#34; in object_result:
                        new_aliases = object_result[&#34;alias&#34;] + list(
                            set(alias) - set(object_result[&#34;alias&#34;])
                        )
                    else:
                        new_aliases = alias
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;alias&#34;, value=new_aliases
                    )
                    object_result[&#34;alias&#34;] = new_aliases
                # base_score
                if base_score is not None and object_result[&#34;base_score&#34;] != base_score:
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;base_score&#34;, value=str(base_score)
                    )
                    object_result[&#34;base_score&#34;] = base_score
                # base_severity
                if (
                    base_severity is not None
                    and object_result[&#34;base_severity&#34;] != base_severity
                ):
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;base_severity&#34;, value=base_severity
                    )
                    object_result[&#34;base_severity&#34;] = base_severity
                # attack_vector
                if (
                    attack_vector is not None
                    and object_result[&#34;attack_vector&#34;] != attack_vector
                ):
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;], key=&#34;attack_vector&#34;, value=attack_vector
                    )
                    object_result[&#34;attack_vector&#34;] = attack_vector
                # integrity_impact
                if (
                    integrity_impact is not None
                    and object_result[&#34;integrity_impact&#34;] != integrity_impact
                ):
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;],
                        key=&#34;integrity_impact&#34;,
                        value=integrity_impact,
                    )
                    object_result[&#34;integrity_impact&#34;] = integrity_impact
                # availability_impact
                if (
                    availability_impact is not None
                    and object_result[&#34;availability_impact&#34;] != availability_impact
                ):
                    self.opencti.stix_domain_entity.update_field(
                        id=object_result[&#34;id&#34;],
                        key=&#34;availability_impact&#34;,
                        value=availability_impact,
                    )
                    object_result[&#34;availability_impact&#34;] = availability_impact
            return object_result
        else:
            return self.create_raw(
                name=name,
                description=description,
                base_score=base_score,
                base_severity=base_severity,
                attack_vector=attack_vector,
                integrity_impact=integrity_impact,
                availability_impact=availability_impact,
                alias=alias,
                id=id,
                stix_id_key=stix_id_key,
                created=created,
                modified=modified,
                createdByRef=created_by_ref,
                markingDefinitions=marking_definitions,
            )

    &#34;&#34;&#34;
        Export an Vulnerability object in STIX2
    
        :param id: the id of the Vulnerability
        :return Vulnerability object
    &#34;&#34;&#34;

    def to_stix2(self, **kwargs):
        id = kwargs.get(&#34;id&#34;, None)
        mode = kwargs.get(&#34;mode&#34;, &#34;simple&#34;)
        max_marking_definition_entity = kwargs.get(
            &#34;max_marking_definition_entity&#34;, None
        )
        entity = kwargs.get(&#34;entity&#34;, None)
        if id is not None and entity is None:
            entity = self.read(id=id)
        if entity is not None:
            vulnerability = dict()
            vulnerability[&#34;id&#34;] = entity[&#34;stix_id_key&#34;]
            vulnerability[&#34;type&#34;] = &#34;vulnerability&#34;
            vulnerability[&#34;name&#34;] = entity[&#34;name&#34;]
            if self.opencti.not_empty(entity[&#34;stix_label&#34;]):
                vulnerability[&#34;labels&#34;] = entity[&#34;stix_label&#34;]
            else:
                vulnerability[&#34;labels&#34;] = [&#34;vulnerability&#34;]
            if self.opencti.not_empty(entity[&#34;description&#34;]):
                vulnerability[&#34;description&#34;] = entity[&#34;description&#34;]
            vulnerability[&#34;created&#34;] = self.opencti.stix2.format_date(entity[&#34;created&#34;])
            vulnerability[&#34;modified&#34;] = self.opencti.stix2.format_date(
                entity[&#34;modified&#34;]
            )
            if self.opencti.not_empty(entity[&#34;alias&#34;]):
                vulnerability[CustomProperties.ALIASES] = entity[&#34;alias&#34;]
            vulnerability[CustomProperties.ID] = entity[&#34;id&#34;]
            return self.opencti.stix2.prepare_export(
                entity, vulnerability, mode, max_marking_definition_entity
            )
        else:
            self.opencti.log(&#34;error&#34;, &#34;Missing parameters: id or entity&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pycti.Vulnerability.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create(self, **kwargs):
    name = kwargs.get(&#34;name&#34;, None)
    description = kwargs.get(&#34;description&#34;, None)
    alias = kwargs.get(&#34;alias&#34;, None)
    base_score = kwargs.get(&#34;base_score&#34;, None)
    base_severity = kwargs.get(&#34;base_severity&#34;, None)
    attack_vector = kwargs.get(&#34;attack_vector&#34;, None)
    integrity_impact = kwargs.get(&#34;integrity_impact&#34;, None)
    availability_impact = kwargs.get(&#34;availability_impact&#34;, None)
    id = kwargs.get(&#34;id&#34;, None)
    stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
    created = kwargs.get(&#34;created&#34;, None)
    modified = kwargs.get(&#34;modified&#34;, None)
    created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
    marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)
    update = kwargs.get(&#34;update&#34;, False)
    custom_attributes = &#34;&#34;&#34;
        id
        entity_type
        name
        description 
        alias
        ... on Vulnerability {
            base_score
            base_severity
            attack_vector
            integrity_impact
            availability_impact
        }
    &#34;&#34;&#34;
    object_result = self.opencti.stix_domain_entity.get_by_stix_id_or_name(
        types=[&#34;Vulnerability&#34;],
        stix_id_key=stix_id_key,
        name=name,
        customAttributes=custom_attributes,
    )
    if object_result is not None:
        if update:
            # name
            if object_result[&#34;name&#34;] != name:
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;name&#34;, value=name
                )
                object_result[&#34;name&#34;] = name
            # description
            if object_result[&#34;description&#34;] != description:
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;description&#34;, value=description
                )
                object_result[&#34;description&#34;] = description
            # alias
            if alias is not None and object_result[&#34;alias&#34;] != alias:
                if &#34;alias&#34; in object_result:
                    new_aliases = object_result[&#34;alias&#34;] + list(
                        set(alias) - set(object_result[&#34;alias&#34;])
                    )
                else:
                    new_aliases = alias
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;alias&#34;, value=new_aliases
                )
                object_result[&#34;alias&#34;] = new_aliases
            # base_score
            if base_score is not None and object_result[&#34;base_score&#34;] != base_score:
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;base_score&#34;, value=str(base_score)
                )
                object_result[&#34;base_score&#34;] = base_score
            # base_severity
            if (
                base_severity is not None
                and object_result[&#34;base_severity&#34;] != base_severity
            ):
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;base_severity&#34;, value=base_severity
                )
                object_result[&#34;base_severity&#34;] = base_severity
            # attack_vector
            if (
                attack_vector is not None
                and object_result[&#34;attack_vector&#34;] != attack_vector
            ):
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;], key=&#34;attack_vector&#34;, value=attack_vector
                )
                object_result[&#34;attack_vector&#34;] = attack_vector
            # integrity_impact
            if (
                integrity_impact is not None
                and object_result[&#34;integrity_impact&#34;] != integrity_impact
            ):
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;],
                    key=&#34;integrity_impact&#34;,
                    value=integrity_impact,
                )
                object_result[&#34;integrity_impact&#34;] = integrity_impact
            # availability_impact
            if (
                availability_impact is not None
                and object_result[&#34;availability_impact&#34;] != availability_impact
            ):
                self.opencti.stix_domain_entity.update_field(
                    id=object_result[&#34;id&#34;],
                    key=&#34;availability_impact&#34;,
                    value=availability_impact,
                )
                object_result[&#34;availability_impact&#34;] = availability_impact
        return object_result
    else:
        return self.create_raw(
            name=name,
            description=description,
            base_score=base_score,
            base_severity=base_severity,
            attack_vector=attack_vector,
            integrity_impact=integrity_impact,
            availability_impact=availability_impact,
            alias=alias,
            id=id,
            stix_id_key=stix_id_key,
            created=created,
            modified=modified,
            createdByRef=created_by_ref,
            markingDefinitions=marking_definitions,
        )</code></pre>
</details>
</dd>
<dt id="pycti.Vulnerability.create_raw"><code class="name flex">
<span>def <span class="ident">create_raw</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_raw(self, **kwargs):
    name = kwargs.get(&#34;name&#34;, None)
    description = kwargs.get(&#34;description&#34;, None)
    alias = kwargs.get(&#34;alias&#34;, None)
    base_score = kwargs.get(&#34;base_score&#34;, None)
    base_severity = kwargs.get(&#34;base_severity&#34;, None)
    attack_vector = kwargs.get(&#34;attack_vector&#34;, None)
    integrity_impact = kwargs.get(&#34;integrity_impact&#34;, None)
    availability_impact = kwargs.get(&#34;availability_impact&#34;, None)
    id = kwargs.get(&#34;id&#34;, None)
    stix_id_key = kwargs.get(&#34;stix_id_key&#34;, None)
    created = kwargs.get(&#34;created&#34;, None)
    modified = kwargs.get(&#34;modified&#34;, None)
    created_by_ref = kwargs.get(&#34;createdByRef&#34;, None)
    marking_definitions = kwargs.get(&#34;markingDefinitions&#34;, None)

    if name is not None and description is not None:
        self.opencti.log(&#34;info&#34;, &#34;Creating Vulnerability {&#34; + name + &#34;}.&#34;)
        query = (
            &#34;&#34;&#34;
            mutation VulnerabilityAdd($input: VulnerabilityAddInput) {
                vulnerabilityAdd(input: $input) {
                    &#34;&#34;&#34;
            + self.properties
            + &#34;&#34;&#34;
                }
            }
        &#34;&#34;&#34;
        )
        result = self.opencti.query(
            query,
            {
                &#34;input&#34;: {
                    &#34;name&#34;: name,
                    &#34;description&#34;: description,
                    &#34;alias&#34;: alias,
                    &#34;base_score&#34;: base_score,
                    &#34;base_severity&#34;: base_severity,
                    &#34;attack_vector&#34;: attack_vector,
                    &#34;integrity_impact&#34;: integrity_impact,
                    &#34;availability_impact&#34;: availability_impact,
                    &#34;internal_id_key&#34;: id,
                    &#34;stix_id_key&#34;: stix_id_key,
                    &#34;created&#34;: created,
                    &#34;modified&#34;: modified,
                    &#34;createdByRef&#34;: created_by_ref,
                    &#34;markingDefinitions&#34;: marking_definitions,
                }
            },
        )
        return self.opencti.process_multiple_fields(
            result[&#34;data&#34;][&#34;vulnerabilityAdd&#34;]
        )
    else:
        self.opencti.log(
            &#34;error&#34;,
            &#34;[opencti_vulnerability] Missing parameters: name and description&#34;,
        )</code></pre>
</details>
</dd>
<dt id="pycti.Vulnerability.list"><code class="name flex">
<span>def <span class="ident">list</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list(self, **kwargs):
    filters = kwargs.get(&#34;filters&#34;, None)
    search = kwargs.get(&#34;search&#34;, None)
    first = kwargs.get(&#34;first&#34;, 500)
    after = kwargs.get(&#34;after&#34;, None)
    order_by = kwargs.get(&#34;orderBy&#34;, None)
    order_mode = kwargs.get(&#34;orderMode&#34;, None)
    get_all = kwargs.get(&#34;getAll&#34;, False)
    if get_all:
        first = 500

    self.opencti.log(
        &#34;info&#34;, &#34;Listing Vulnerabilities with filters &#34; + json.dumps(filters) + &#34;.&#34;
    )
    query = (
        &#34;&#34;&#34;
        query Vulnerabilities($filters: [VulnerabilitiesFiltering], $search: String, $first: Int, $after: ID, $orderBy: VulnerabilitiesOrdering, $orderMode: OrderingMode) {
            vulnerabilities(filters: $filters, search: $search, first: $first, after: $after, orderBy: $orderBy, orderMode: $orderMode) {
                edges {
                    node {
                        &#34;&#34;&#34;
        + self.properties
        + &#34;&#34;&#34;
                    }
                }
                pageInfo {
                    startCursor
                    endCursor
                    hasNextPage
                    hasPreviousPage
                    globalCount
                }
            }
        }
    &#34;&#34;&#34;
    )
    result = self.opencti.query(
        query,
        {
            &#34;filters&#34;: filters,
            &#34;search&#34;: search,
            &#34;first&#34;: first,
            &#34;after&#34;: after,
            &#34;orderBy&#34;: order_by,
            &#34;orderMode&#34;: order_mode,
        },
    )

    if get_all:
        final_data = []
        data = self.opencti.process_multiple(result[&#34;data&#34;][&#34;vulnerabilities&#34;])
        final_data = final_data + data
        while result[&#34;data&#34;][&#34;vulnerabilities&#34;][&#34;pageInfo&#34;][&#34;hasNextPage&#34;]:
            after = result[&#34;data&#34;][&#34;vulnerabilities&#34;][&#34;pageInfo&#34;][&#34;endCursor&#34;]
            self.opencti.log(&#34;info&#34;, &#34;Listing Vulnerabilities after &#34; + after)
            result = self.opencti.query(
                query,
                {
                    &#34;filters&#34;: filters,
                    &#34;search&#34;: search,
                    &#34;first&#34;: first,
                    &#34;after&#34;: after,
                    &#34;orderBy&#34;: order_by,
                    &#34;orderMode&#34;: order_mode,
                },
            )
            data = self.opencti.process_multiple(result[&#34;data&#34;][&#34;vulnerabilities&#34;])
            final_data = final_data + data
        return final_data
    else:
        return self.opencti.process_multiple(result[&#34;data&#34;][&#34;vulnerabilities&#34;])</code></pre>
</details>
</dd>
<dt id="pycti.Vulnerability.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    filters = kwargs.get(&#34;filters&#34;, None)
    custom_attributes = kwargs.get(&#34;customAttributes&#34;, None)
    if id is not None:
        self.opencti.log(&#34;info&#34;, &#34;Reading Vulnerability {&#34; + id + &#34;}.&#34;)
        query = (
            &#34;&#34;&#34;
            query Vulnerability($id: String!) {
                vulnerability(id: $id) {
                    &#34;&#34;&#34;
            + (
                custom_attributes
                if custom_attributes is not None
                else self.properties
            )
            + &#34;&#34;&#34;
                }
            }
         &#34;&#34;&#34;
        )
        result = self.opencti.query(query, {&#34;id&#34;: id})
        return self.opencti.process_multiple_fields(result[&#34;data&#34;][&#34;vulnerability&#34;])
    elif filters is not None:
        result = self.list(filters=filters)
        if len(result) &gt; 0:
            return result[0]
        else:
            return None
    else:
        self.opencti.log(
            &#34;error&#34;, &#34;[opencti_tool] Missing parameters: id or filters&#34;
        )
        return None</code></pre>
</details>
</dd>
<dt id="pycti.Vulnerability.to_stix2"><code class="name flex">
<span>def <span class="ident">to_stix2</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_stix2(self, **kwargs):
    id = kwargs.get(&#34;id&#34;, None)
    mode = kwargs.get(&#34;mode&#34;, &#34;simple&#34;)
    max_marking_definition_entity = kwargs.get(
        &#34;max_marking_definition_entity&#34;, None
    )
    entity = kwargs.get(&#34;entity&#34;, None)
    if id is not None and entity is None:
        entity = self.read(id=id)
    if entity is not None:
        vulnerability = dict()
        vulnerability[&#34;id&#34;] = entity[&#34;stix_id_key&#34;]
        vulnerability[&#34;type&#34;] = &#34;vulnerability&#34;
        vulnerability[&#34;name&#34;] = entity[&#34;name&#34;]
        if self.opencti.not_empty(entity[&#34;stix_label&#34;]):
            vulnerability[&#34;labels&#34;] = entity[&#34;stix_label&#34;]
        else:
            vulnerability[&#34;labels&#34;] = [&#34;vulnerability&#34;]
        if self.opencti.not_empty(entity[&#34;description&#34;]):
            vulnerability[&#34;description&#34;] = entity[&#34;description&#34;]
        vulnerability[&#34;created&#34;] = self.opencti.stix2.format_date(entity[&#34;created&#34;])
        vulnerability[&#34;modified&#34;] = self.opencti.stix2.format_date(
            entity[&#34;modified&#34;]
        )
        if self.opencti.not_empty(entity[&#34;alias&#34;]):
            vulnerability[CustomProperties.ALIASES] = entity[&#34;alias&#34;]
        vulnerability[CustomProperties.ID] = entity[&#34;id&#34;]
        return self.opencti.stix2.prepare_export(
            entity, vulnerability, mode, max_marking_definition_entity
        )
    else:
        self.opencti.log(&#34;error&#34;, &#34;Missing parameters: id or entity&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="pycti.api" href="api/index.html">pycti.api</a></code></li>
<li><code><a title="pycti.connector" href="connector/index.html">pycti.connector</a></code></li>
<li><code><a title="pycti.entities" href="entities/index.html">pycti.entities</a></code></li>
<li><code><a title="pycti.utils" href="utils/index.html">pycti.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pycti.get_config_variable" href="#pycti.get_config_variable">get_config_variable</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pycti.AttackPattern" href="#pycti.AttackPattern">AttackPattern</a></code></h4>
<ul class="two-column">
<li><code><a title="pycti.AttackPattern.create" href="#pycti.AttackPattern.create">create</a></code></li>
<li><code><a title="pycti.AttackPattern.create_raw" href="#pycti.AttackPattern.create_raw">create_raw</a></code></li>
<li><code><a title="pycti.AttackPattern.import_from_stix2" href="#pycti.AttackPattern.import_from_stix2">import_from_stix2</a></code></li>
<li><code><a title="pycti.AttackPattern.list" href="#pycti.AttackPattern.list">list</a></code></li>
<li><code><a title="pycti.AttackPattern.read" href="#pycti.AttackPattern.read">read</a></code></li>
<li><code><a title="pycti.AttackPattern.to_stix2" href="#pycti.AttackPattern.to_stix2">to_stix2</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pycti.Campaign" href="#pycti.Campaign">Campaign</a></code></h4>
<ul class="">
<li><code><a title="pycti.Campaign.create" href="#pycti.Campaign.create">create</a></code></li>
<li><code><a title="pycti.Campaign.create_raw" href="#pycti.Campaign.create_raw">create_raw</a></code></li>
<li><code><a title="pycti.Campaign.list" href="#pycti.Campaign.list">list</a></code></li>
<li><code><a title="pycti.Campaign.read" href="#pycti.Campaign.read">read</a></code></li>
<li><code><a title="pycti.Campaign.to_stix2" href="#pycti.Campaign.to_stix2">to_stix2</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pycti.ConnectorType" href="#pycti.ConnectorType">ConnectorType</a></code></h4>
<ul class="">
<li><code><a title="pycti.ConnectorType.EXTERNAL_IMPORT" href="#pycti.ConnectorType.EXTERNAL_IMPORT">EXTERNAL_IMPORT</a></code></li>
<li><code><a title="pycti.ConnectorType.INTERNAL_ENRICHMENT" href="#pycti.ConnectorType.INTERNAL_ENRICHMENT">INTERNAL_ENRICHMENT</a></code></li>
<li><code><a title="pycti.ConnectorType.INTERNAL_EXPORT_FILE" href="#pycti.ConnectorType.INTERNAL_EXPORT_FILE">INTERNAL_EXPORT_FILE</a></code></li>
<li><code><a title="pycti.ConnectorType.INTERNAL_IMPORT_FILE" href="#pycti.ConnectorType.INTERNAL_IMPORT_FILE">INTERNAL_IMPORT_FILE</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pycti.CourseOfAction" href="#pycti.CourseOfAction">CourseOfAction</a></code></h4>
<ul class="">
<li><code><a title="pycti.CourseOfAction.create" href="#pycti.CourseOfAction.create">create</a></code></li>
<li><code><a title="pycti.CourseOfAction.create_raw" href="#pycti.CourseOfAction.create_raw">create_raw</a></code></li>
<li><code><a title="pycti.CourseOfAction.list" href="#pycti.CourseOfAction.list">list</a></code></li>
<li><code><a title="pycti.CourseOfAction.read" href="#pycti.CourseOfAction.read">read</a></code></li>
<li><code><a title="pycti.CourseOfAction.to_stix2" href="#pycti.CourseOfAction.to_stix2">to_stix2</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pycti.CustomProperties" href="#pycti.CustomProperties">CustomProperties</a></code></h4>
<ul class="two-column">
<li><code><a title="pycti.CustomProperties.ALIASES" href="#pycti.CustomProperties.ALIASES">ALIASES</a></code></li>
<li><code><a title="pycti.CustomProperties.ATTACK_VECTOR" href="#pycti.CustomProperties.ATTACK_VECTOR">ATTACK_VECTOR</a></code></li>
<li><code><a title="pycti.CustomProperties.AVAILABILITY_IMPACT" href="#pycti.CustomProperties.AVAILABILITY_IMPACT">AVAILABILITY_IMPACT</a></code></li>
<li><code><a title="pycti.CustomProperties.BASE_SCORE" href="#pycti.CustomProperties.BASE_SCORE">BASE_SCORE</a></code></li>
<li><code><a title="pycti.CustomProperties.BASE_SEVERITY" href="#pycti.CustomProperties.BASE_SEVERITY">BASE_SEVERITY</a></code></li>
<li><code><a title="pycti.CustomProperties.COLOR" href="#pycti.CustomProperties.COLOR">COLOR</a></code></li>
<li><code><a title="pycti.CustomProperties.CREATED" href="#pycti.CustomProperties.CREATED">CREATED</a></code></li>
<li><code><a title="pycti.CustomProperties.CREATE_INDICATOR" href="#pycti.CustomProperties.CREATE_INDICATOR">CREATE_INDICATOR</a></code></li>
<li><code><a title="pycti.CustomProperties.CREATE_OBSERVABLES" href="#pycti.CustomProperties.CREATE_OBSERVABLES">CREATE_OBSERVABLES</a></code></li>
<li><code><a title="pycti.CustomProperties.EXPIRATION" href="#pycti.CustomProperties.EXPIRATION">EXPIRATION</a></code></li>
<li><code><a title="pycti.CustomProperties.EXTERNAL_ID" href="#pycti.CustomProperties.EXTERNAL_ID">EXTERNAL_ID</a></code></li>
<li><code><a title="pycti.CustomProperties.FILES" href="#pycti.CustomProperties.FILES">FILES</a></code></li>
<li><code><a title="pycti.CustomProperties.FIRST_SEEN" href="#pycti.CustomProperties.FIRST_SEEN">FIRST_SEEN</a></code></li>
<li><code><a title="pycti.CustomProperties.GRAPH_DATA" href="#pycti.CustomProperties.GRAPH_DATA">GRAPH_DATA</a></code></li>
<li><code><a title="pycti.CustomProperties.ID" href="#pycti.CustomProperties.ID">ID</a></code></li>
<li><code><a title="pycti.CustomProperties.IDENTITY_TYPE" href="#pycti.CustomProperties.IDENTITY_TYPE">IDENTITY_TYPE</a></code></li>
<li><code><a title="pycti.CustomProperties.IGNORE_DATES" href="#pycti.CustomProperties.IGNORE_DATES">IGNORE_DATES</a></code></li>
<li><code><a title="pycti.CustomProperties.INDICATOR_PATTERN" href="#pycti.CustomProperties.INDICATOR_PATTERN">INDICATOR_PATTERN</a></code></li>
<li><code><a title="pycti.CustomProperties.INTEGRITY_IMPACT" href="#pycti.CustomProperties.INTEGRITY_IMPACT">INTEGRITY_IMPACT</a></code></li>
<li><code><a title="pycti.CustomProperties.LAST_SEEN" href="#pycti.CustomProperties.LAST_SEEN">LAST_SEEN</a></code></li>
<li><code><a title="pycti.CustomProperties.LEVEL" href="#pycti.CustomProperties.LEVEL">LEVEL</a></code></li>
<li><code><a title="pycti.CustomProperties.MODIFIED" href="#pycti.CustomProperties.MODIFIED">MODIFIED</a></code></li>
<li><code><a title="pycti.CustomProperties.NAME" href="#pycti.CustomProperties.NAME">NAME</a></code></li>
<li><code><a title="pycti.CustomProperties.OBJECT_STATUS" href="#pycti.CustomProperties.OBJECT_STATUS">OBJECT_STATUS</a></code></li>
<li><code><a title="pycti.CustomProperties.OBSERVABLE_TYPE" href="#pycti.CustomProperties.OBSERVABLE_TYPE">OBSERVABLE_TYPE</a></code></li>
<li><code><a title="pycti.CustomProperties.OBSERVABLE_VALUE" href="#pycti.CustomProperties.OBSERVABLE_VALUE">OBSERVABLE_VALUE</a></code></li>
<li><code><a title="pycti.CustomProperties.ORG_CLASS" href="#pycti.CustomProperties.ORG_CLASS">ORG_CLASS</a></code></li>
<li><code><a title="pycti.CustomProperties.PATTERN_TYPE" href="#pycti.CustomProperties.PATTERN_TYPE">PATTERN_TYPE</a></code></li>
<li><code><a title="pycti.CustomProperties.PHASE_ORDER" href="#pycti.CustomProperties.PHASE_ORDER">PHASE_ORDER</a></code></li>
<li><code><a title="pycti.CustomProperties.REPORT_CLASS" href="#pycti.CustomProperties.REPORT_CLASS">REPORT_CLASS</a></code></li>
<li><code><a title="pycti.CustomProperties.ROLE_PLAYED" href="#pycti.CustomProperties.ROLE_PLAYED">ROLE_PLAYED</a></code></li>
<li><code><a title="pycti.CustomProperties.SCORE" href="#pycti.CustomProperties.SCORE">SCORE</a></code></li>
<li><code><a title="pycti.CustomProperties.SOURCE_REF" href="#pycti.CustomProperties.SOURCE_REF">SOURCE_REF</a></code></li>
<li><code><a title="pycti.CustomProperties.SRC_CONF_LEVEL" href="#pycti.CustomProperties.SRC_CONF_LEVEL">SRC_CONF_LEVEL</a></code></li>
<li><code><a title="pycti.CustomProperties.TAG_TYPE" href="#pycti.CustomProperties.TAG_TYPE">TAG_TYPE</a></code></li>
<li><code><a title="pycti.CustomProperties.TARGET_REF" href="#pycti.CustomProperties.TARGET_REF">TARGET_REF</a></code></li>
<li><code><a title="pycti.CustomProperties.WEIGHT" href="#pycti.CustomProperties.WEIGHT">WEIGHT</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pycti.ExternalReference" href="#pycti.ExternalReference">ExternalReference</a></code></h4>
<ul class="">
<li><code><a title="pycti.ExternalReference.create" href="#pycti.ExternalReference.create">create</a></code></li>
<li><code><a title="pycti.ExternalReference.create_raw" href="#pycti.ExternalReference.create_raw">create_raw</a></code></li>
<li><code><a title="pycti.ExternalReference.list" href="#pycti.ExternalReference.list">list</a></code></li>
<li><code><a title="pycti.ExternalReference.read" href="#pycti.ExternalReference.read">read</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pycti.Identity" href="#pycti.Identity">Identity</a></code></h4>
<ul class="">
<li><code><a title="pycti.Identity.create" href="#pycti.Identity.create">create</a></code></li>
<li><code><a title="pycti.Identity.create_raw" href="#pycti.Identity.create_raw">create_raw</a></code></li>
<li><code><a title="pycti.Identity.list" href="#pycti.Identity.list">list</a></code></li>
<li><code><a title="pycti.Identity.read" href="#pycti.Identity.read">read</a></code></li>
<li><code><a title="pycti.Identity.to_stix2" href="#pycti.Identity.to_stix2">to_stix2</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pycti.Incident" href="#pycti.Incident">Incident</a></code></h4>
<ul class="two-column">
<li><code><a title="pycti.Incident.add_stix_observable" href="#pycti.Incident.add_stix_observable">add_stix_observable</a></code></li>
<li><code><a title="pycti.Incident.create" href="#pycti.Incident.create">create</a></code></li>
<li><code><a title="pycti.Incident.create_raw" href="#pycti.Incident.create_raw">create_raw</a></code></li>
<li><code><a title="pycti.Incident.list" href="#pycti.Incident.list">list</a></code></li>
<li><code><a title="pycti.Incident.read" href="#pycti.Incident.read">read</a></code></li>
<li><code><a title="pycti.Incident.to_stix2" href="#pycti.Incident.to_stix2">to_stix2</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pycti.Indicator" href="#pycti.Indicator">Indicator</a></code></h4>
<ul class="two-column">
<li><code><a title="pycti.Indicator.add_stix_observable" href="#pycti.Indicator.add_stix_observable">add_stix_observable</a></code></li>
<li><code><a title="pycti.Indicator.create" href="#pycti.Indicator.create">create</a></code></li>
<li><code><a title="pycti.Indicator.create_raw" href="#pycti.Indicator.create_raw">create_raw</a></code></li>
<li><code><a title="pycti.Indicator.list" href="#pycti.Indicator.list">list</a></code></li>
<li><code><a title="pycti.Indicator.read" href="#pycti.Indicator.read">read</a></code></li>
<li><code><a title="pycti.Indicator.to_stix2" href="#pycti.Indicator.to_stix2">to_stix2</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pycti.IntrusionSet" href="#pycti.IntrusionSet">IntrusionSet</a></code></h4>
<ul class="">
<li><code><a title="pycti.IntrusionSet.create" href="#pycti.IntrusionSet.create">create</a></code></li>
<li><code><a title="pycti.IntrusionSet.create_raw" href="#pycti.IntrusionSet.create_raw">create_raw</a></code></li>
<li><code><a title="pycti.IntrusionSet.list" href="#pycti.IntrusionSet.list">list</a></code></li>
<li><code><a title="pycti.IntrusionSet.read" href="#pycti.IntrusionSet.read">read</a></code></li>
<li><code><a title="pycti.IntrusionSet.to_stix2" href="#pycti.IntrusionSet.to_stix2">to_stix2</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pycti.KillChainPhase" href="#pycti.KillChainPhase">KillChainPhase</a></code></h4>
<ul class="">
<li><code><a title="pycti.KillChainPhase.create" href="#pycti.KillChainPhase.create">create</a></code></li>
<li><code><a title="pycti.KillChainPhase.create_raw" href="#pycti.KillChainPhase.create_raw">create_raw</a></code></li>
<li><code><a title="pycti.KillChainPhase.list" href="#pycti.KillChainPhase.list">list</a></code></li>
<li><code><a title="pycti.KillChainPhase.read" href="#pycti.KillChainPhase.read">read</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pycti.Malware" href="#pycti.Malware">Malware</a></code></h4>
<ul class="">
<li><code><a title="pycti.Malware.create" href="#pycti.Malware.create">create</a></code></li>
<li><code><a title="pycti.Malware.create_raw" href="#pycti.Malware.create_raw">create_raw</a></code></li>
<li><code><a title="pycti.Malware.list" href="#pycti.Malware.list">list</a></code></li>
<li><code><a title="pycti.Malware.read" href="#pycti.Malware.read">read</a></code></li>
<li><code><a title="pycti.Malware.to_stix2" href="#pycti.Malware.to_stix2">to_stix2</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pycti.MarkingDefinition" href="#pycti.MarkingDefinition">MarkingDefinition</a></code></h4>
<ul class="">
<li><code><a title="pycti.MarkingDefinition.create" href="#pycti.MarkingDefinition.create">create</a></code></li>
<li><code><a title="pycti.MarkingDefinition.create_raw" href="#pycti.MarkingDefinition.create_raw">create_raw</a></code></li>
<li><code><a title="pycti.MarkingDefinition.list" href="#pycti.MarkingDefinition.list">list</a></code></li>
<li><code><a title="pycti.MarkingDefinition.read" href="#pycti.MarkingDefinition.read">read</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pycti.Note" href="#pycti.Note">Note</a></code></h4>
<ul class="">
<li><code><a title="pycti.Note.add_stix_entity" href="#pycti.Note.add_stix_entity">add_stix_entity</a></code></li>
<li><code><a title="pycti.Note.add_stix_observable" href="#pycti.Note.add_stix_observable">add_stix_observable</a></code></li>
<li><code><a title="pycti.Note.contains_stix_entity" href="#pycti.Note.contains_stix_entity">contains_stix_entity</a></code></li>
<li><code><a title="pycti.Note.contains_stix_observable" href="#pycti.Note.contains_stix_observable">contains_stix_observable</a></code></li>
<li><code><a title="pycti.Note.create" href="#pycti.Note.create">create</a></code></li>
<li><code><a title="pycti.Note.create_raw" href="#pycti.Note.create_raw">create_raw</a></code></li>
<li><code><a title="pycti.Note.get_by_stix_id_or_name" href="#pycti.Note.get_by_stix_id_or_name">get_by_stix_id_or_name</a></code></li>
<li><code><a title="pycti.Note.import_from_stix2" href="#pycti.Note.import_from_stix2">import_from_stix2</a></code></li>
<li><code><a title="pycti.Note.list" href="#pycti.Note.list">list</a></code></li>
<li><code><a title="pycti.Note.read" href="#pycti.Note.read">read</a></code></li>
<li><code><a title="pycti.Note.to_stix2" href="#pycti.Note.to_stix2">to_stix2</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pycti.ObservableTypes" href="#pycti.ObservableTypes">ObservableTypes</a></code></h4>
<ul class="two-column">
<li><code><a title="pycti.ObservableTypes.AUTONOMOUS_SYSTEM" href="#pycti.ObservableTypes.AUTONOMOUS_SYSTEM">AUTONOMOUS_SYSTEM</a></code></li>
<li><code><a title="pycti.ObservableTypes.DIRECTORY" href="#pycti.ObservableTypes.DIRECTORY">DIRECTORY</a></code></li>
<li><code><a title="pycti.ObservableTypes.DOMAIN" href="#pycti.ObservableTypes.DOMAIN">DOMAIN</a></code></li>
<li><code><a title="pycti.ObservableTypes.EMAIL_ADDR" href="#pycti.ObservableTypes.EMAIL_ADDR">EMAIL_ADDR</a></code></li>
<li><code><a title="pycti.ObservableTypes.EMAIL_SUBJECT" href="#pycti.ObservableTypes.EMAIL_SUBJECT">EMAIL_SUBJECT</a></code></li>
<li><code><a title="pycti.ObservableTypes.FILE_HASH_MD5" href="#pycti.ObservableTypes.FILE_HASH_MD5">FILE_HASH_MD5</a></code></li>
<li><code><a title="pycti.ObservableTypes.FILE_HASH_SHA1" href="#pycti.ObservableTypes.FILE_HASH_SHA1">FILE_HASH_SHA1</a></code></li>
<li><code><a title="pycti.ObservableTypes.FILE_HASH_SHA256" href="#pycti.ObservableTypes.FILE_HASH_SHA256">FILE_HASH_SHA256</a></code></li>
<li><code><a title="pycti.ObservableTypes.FILE_NAME" href="#pycti.ObservableTypes.FILE_NAME">FILE_NAME</a></code></li>
<li><code><a title="pycti.ObservableTypes.FILE_PATH" href="#pycti.ObservableTypes.FILE_PATH">FILE_PATH</a></code></li>
<li><code><a title="pycti.ObservableTypes.IPV4_ADDR" href="#pycti.ObservableTypes.IPV4_ADDR">IPV4_ADDR</a></code></li>
<li><code><a title="pycti.ObservableTypes.IPV6_ADDR" href="#pycti.ObservableTypes.IPV6_ADDR">IPV6_ADDR</a></code></li>
<li><code><a title="pycti.ObservableTypes.MAC_ADDR" href="#pycti.ObservableTypes.MAC_ADDR">MAC_ADDR</a></code></li>
<li><code><a title="pycti.ObservableTypes.MUTEX" href="#pycti.ObservableTypes.MUTEX">MUTEX</a></code></li>
<li><code><a title="pycti.ObservableTypes.PDB_PATH" href="#pycti.ObservableTypes.PDB_PATH">PDB_PATH</a></code></li>
<li><code><a title="pycti.ObservableTypes.REGISTRY_KEY" href="#pycti.ObservableTypes.REGISTRY_KEY">REGISTRY_KEY</a></code></li>
<li><code><a title="pycti.ObservableTypes.REGISTRY_VALUE" href="#pycti.ObservableTypes.REGISTRY_VALUE">REGISTRY_VALUE</a></code></li>
<li><code><a title="pycti.ObservableTypes.URL" href="#pycti.ObservableTypes.URL">URL</a></code></li>
<li><code><a title="pycti.ObservableTypes.WIN_SCHEDULED_TASK" href="#pycti.ObservableTypes.WIN_SCHEDULED_TASK">WIN_SCHEDULED_TASK</a></code></li>
<li><code><a title="pycti.ObservableTypes.WIN_SERVICE_DISPLAY" href="#pycti.ObservableTypes.WIN_SERVICE_DISPLAY">WIN_SERVICE_DISPLAY</a></code></li>
<li><code><a title="pycti.ObservableTypes.WIN_SERVICE_NAME" href="#pycti.ObservableTypes.WIN_SERVICE_NAME">WIN_SERVICE_NAME</a></code></li>
<li><code><a title="pycti.ObservableTypes.X509_CERT_ISSUER" href="#pycti.ObservableTypes.X509_CERT_ISSUER">X509_CERT_ISSUER</a></code></li>
<li><code><a title="pycti.ObservableTypes.X509_CERT_SN" href="#pycti.ObservableTypes.X509_CERT_SN">X509_CERT_SN</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pycti.OpenCTIApiClient" href="#pycti.OpenCTIApiClient">OpenCTIApiClient</a></code></h4>
<ul class="">
<li><code><a title="pycti.OpenCTIApiClient.create_vulnerability_if_not_exists" href="#pycti.OpenCTIApiClient.create_vulnerability_if_not_exists">create_vulnerability_if_not_exists</a></code></li>
<li><code><a title="pycti.OpenCTIApiClient.delete_external_reference" href="#pycti.OpenCTIApiClient.delete_external_reference">delete_external_reference</a></code></li>
<li><code><a title="pycti.OpenCTIApiClient.fetch_opencti_file" href="#pycti.OpenCTIApiClient.fetch_opencti_file">fetch_opencti_file</a></code></li>
<li><code><a title="pycti.OpenCTIApiClient.health_check" href="#pycti.OpenCTIApiClient.health_check">health_check</a></code></li>
<li><code><a title="pycti.OpenCTIApiClient.log" href="#pycti.OpenCTIApiClient.log">log</a></code></li>
<li><code><a title="pycti.OpenCTIApiClient.not_empty" href="#pycti.OpenCTIApiClient.not_empty">not_empty</a></code></li>
<li><code><a title="pycti.OpenCTIApiClient.process_multiple" href="#pycti.OpenCTIApiClient.process_multiple">process_multiple</a></code></li>
<li><code><a title="pycti.OpenCTIApiClient.process_multiple_fields" href="#pycti.OpenCTIApiClient.process_multiple_fields">process_multiple_fields</a></code></li>
<li><code><a title="pycti.OpenCTIApiClient.process_multiple_ids" href="#pycti.OpenCTIApiClient.process_multiple_ids">process_multiple_ids</a></code></li>
<li><code><a title="pycti.OpenCTIApiClient.query" href="#pycti.OpenCTIApiClient.query">query</a></code></li>
<li><code><a title="pycti.OpenCTIApiClient.resolve_role" href="#pycti.OpenCTIApiClient.resolve_role">resolve_role</a></code></li>
<li><code><a title="pycti.OpenCTIApiClient.update_stix_observable_field" href="#pycti.OpenCTIApiClient.update_stix_observable_field">update_stix_observable_field</a></code></li>
<li><code><a title="pycti.OpenCTIApiClient.upload_file" href="#pycti.OpenCTIApiClient.upload_file">upload_file</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pycti.OpenCTIApiConnector" href="#pycti.OpenCTIApiConnector">OpenCTIApiConnector</a></code></h4>
<ul class="">
<li><code><a title="pycti.OpenCTIApiConnector.list" href="#pycti.OpenCTIApiConnector.list">list</a></code></li>
<li><code><a title="pycti.OpenCTIApiConnector.ping" href="#pycti.OpenCTIApiConnector.ping">ping</a></code></li>
<li><code><a title="pycti.OpenCTIApiConnector.register" href="#pycti.OpenCTIApiConnector.register">register</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pycti.OpenCTIApiJob" href="#pycti.OpenCTIApiJob">OpenCTIApiJob</a></code></h4>
<ul class="">
<li><code><a title="pycti.OpenCTIApiJob.initiate_job" href="#pycti.OpenCTIApiJob.initiate_job">initiate_job</a></code></li>
<li><code><a title="pycti.OpenCTIApiJob.update_job" href="#pycti.OpenCTIApiJob.update_job">update_job</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pycti.OpenCTIConnector" href="#pycti.OpenCTIConnector">OpenCTIConnector</a></code></h4>
<ul class="">
<li><code><a title="pycti.OpenCTIConnector.to_input" href="#pycti.OpenCTIConnector.to_input">to_input</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pycti.OpenCTIConnectorHelper" href="#pycti.OpenCTIConnectorHelper">OpenCTIConnectorHelper</a></code></h4>
<ul class="">
<li><code><a title="pycti.OpenCTIConnectorHelper.check_max_tlp" href="#pycti.OpenCTIConnectorHelper.check_max_tlp">check_max_tlp</a></code></li>
<li><code><a title="pycti.OpenCTIConnectorHelper.date_now" href="#pycti.OpenCTIConnectorHelper.date_now">date_now</a></code></li>
<li><code><a title="pycti.OpenCTIConnectorHelper.get_connector" href="#pycti.OpenCTIConnectorHelper.get_connector">get_connector</a></code></li>
<li><code><a title="pycti.OpenCTIConnectorHelper.get_state" href="#pycti.OpenCTIConnectorHelper.get_state">get_state</a></code></li>
<li><code><a title="pycti.OpenCTIConnectorHelper.listen" href="#pycti.OpenCTIConnectorHelper.listen">listen</a></code></li>
<li><code><a title="pycti.OpenCTIConnectorHelper.log_error" href="#pycti.OpenCTIConnectorHelper.log_error">log_error</a></code></li>
<li><code><a title="pycti.OpenCTIConnectorHelper.log_info" href="#pycti.OpenCTIConnectorHelper.log_info">log_info</a></code></li>
<li><code><a title="pycti.OpenCTIConnectorHelper.send_stix2_bundle" href="#pycti.OpenCTIConnectorHelper.send_stix2_bundle">send_stix2_bundle</a></code></li>
<li><code><a title="pycti.OpenCTIConnectorHelper.set_state" href="#pycti.OpenCTIConnectorHelper.set_state">set_state</a></code></li>
<li><code><a title="pycti.OpenCTIConnectorHelper.split_stix2_bundle" href="#pycti.OpenCTIConnectorHelper.split_stix2_bundle">split_stix2_bundle</a></code></li>
<li><code><a title="pycti.OpenCTIConnectorHelper.stix2_create_bundle" href="#pycti.OpenCTIConnectorHelper.stix2_create_bundle">stix2_create_bundle</a></code></li>
<li><code><a title="pycti.OpenCTIConnectorHelper.stix2_deduplicate_objects" href="#pycti.OpenCTIConnectorHelper.stix2_deduplicate_objects">stix2_deduplicate_objects</a></code></li>
<li><code><a title="pycti.OpenCTIConnectorHelper.stix2_get_embedded_objects" href="#pycti.OpenCTIConnectorHelper.stix2_get_embedded_objects">stix2_get_embedded_objects</a></code></li>
<li><code><a title="pycti.OpenCTIConnectorHelper.stix2_get_entity_objects" href="#pycti.OpenCTIConnectorHelper.stix2_get_entity_objects">stix2_get_entity_objects</a></code></li>
<li><code><a title="pycti.OpenCTIConnectorHelper.stix2_get_relationship_objects" href="#pycti.OpenCTIConnectorHelper.stix2_get_relationship_objects">stix2_get_relationship_objects</a></code></li>
<li><code><a title="pycti.OpenCTIConnectorHelper.stix2_get_report_objects" href="#pycti.OpenCTIConnectorHelper.stix2_get_report_objects">stix2_get_report_objects</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pycti.OpenCTIStix2" href="#pycti.OpenCTIStix2">OpenCTIStix2</a></code></h4>
<ul class="">
<li><code><a title="pycti.OpenCTIStix2.check_max_marking_definition" href="#pycti.OpenCTIStix2.check_max_marking_definition">check_max_marking_definition</a></code></li>
<li><code><a title="pycti.OpenCTIStix2.convert_markdown" href="#pycti.OpenCTIStix2.convert_markdown">convert_markdown</a></code></li>
<li><code><a title="pycti.OpenCTIStix2.create_attack_pattern" href="#pycti.OpenCTIStix2.create_attack_pattern">create_attack_pattern</a></code></li>
<li><code><a title="pycti.OpenCTIStix2.create_campaign" href="#pycti.OpenCTIStix2.create_campaign">create_campaign</a></code></li>
<li><code><a title="pycti.OpenCTIStix2.create_course_of_action" href="#pycti.OpenCTIStix2.create_course_of_action">create_course_of_action</a></code></li>
<li><code><a title="pycti.OpenCTIStix2.create_identity" href="#pycti.OpenCTIStix2.create_identity">create_identity</a></code></li>
<li><code><a title="pycti.OpenCTIStix2.create_incident" href="#pycti.OpenCTIStix2.create_incident">create_incident</a></code></li>
<li><code><a title="pycti.OpenCTIStix2.create_indicator" href="#pycti.OpenCTIStix2.create_indicator">create_indicator</a></code></li>
<li><code><a title="pycti.OpenCTIStix2.create_intrusion_set" href="#pycti.OpenCTIStix2.create_intrusion_set">create_intrusion_set</a></code></li>
<li><code><a title="pycti.OpenCTIStix2.create_malware" href="#pycti.OpenCTIStix2.create_malware">create_malware</a></code></li>
<li><code><a title="pycti.OpenCTIStix2.create_marking_definition" href="#pycti.OpenCTIStix2.create_marking_definition">create_marking_definition</a></code></li>
<li><code><a title="pycti.OpenCTIStix2.create_note" href="#pycti.OpenCTIStix2.create_note">create_note</a></code></li>
<li><code><a title="pycti.OpenCTIStix2.create_opinion" href="#pycti.OpenCTIStix2.create_opinion">create_opinion</a></code></li>
<li><code><a title="pycti.OpenCTIStix2.create_report" href="#pycti.OpenCTIStix2.create_report">create_report</a></code></li>
<li><code><a title="pycti.OpenCTIStix2.create_threat_actor" href="#pycti.OpenCTIStix2.create_threat_actor">create_threat_actor</a></code></li>
<li><code><a title="pycti.OpenCTIStix2.create_tool" href="#pycti.OpenCTIStix2.create_tool">create_tool</a></code></li>
<li><code><a title="pycti.OpenCTIStix2.create_vulnerability" href="#pycti.OpenCTIStix2.create_vulnerability">create_vulnerability</a></code></li>
<li><code><a title="pycti.OpenCTIStix2.export_entity" href="#pycti.OpenCTIStix2.export_entity">export_entity</a></code></li>
<li><code><a title="pycti.OpenCTIStix2.export_list" href="#pycti.OpenCTIStix2.export_list">export_list</a></code></li>
<li><code><a title="pycti.OpenCTIStix2.export_stix_observables" href="#pycti.OpenCTIStix2.export_stix_observables">export_stix_observables</a></code></li>
<li><code><a title="pycti.OpenCTIStix2.extract_embedded_relationships" href="#pycti.OpenCTIStix2.extract_embedded_relationships">extract_embedded_relationships</a></code></li>
<li><code><a title="pycti.OpenCTIStix2.filter_objects" href="#pycti.OpenCTIStix2.filter_objects">filter_objects</a></code></li>
<li><code><a title="pycti.OpenCTIStix2.format_date" href="#pycti.OpenCTIStix2.format_date">format_date</a></code></li>
<li><code><a title="pycti.OpenCTIStix2.get_author" href="#pycti.OpenCTIStix2.get_author">get_author</a></code></li>
<li><code><a title="pycti.OpenCTIStix2.import_bundle" href="#pycti.OpenCTIStix2.import_bundle">import_bundle</a></code></li>
<li><code><a title="pycti.OpenCTIStix2.import_bundle_from_file" href="#pycti.OpenCTIStix2.import_bundle_from_file">import_bundle_from_file</a></code></li>
<li><code><a title="pycti.OpenCTIStix2.import_bundle_from_json" href="#pycti.OpenCTIStix2.import_bundle_from_json">import_bundle_from_json</a></code></li>
<li><code><a title="pycti.OpenCTIStix2.import_object" href="#pycti.OpenCTIStix2.import_object">import_object</a></code></li>
<li><code><a title="pycti.OpenCTIStix2.import_observables" href="#pycti.OpenCTIStix2.import_observables">import_observables</a></code></li>
<li><code><a title="pycti.OpenCTIStix2.import_relationship" href="#pycti.OpenCTIStix2.import_relationship">import_relationship</a></code></li>
<li><code><a title="pycti.OpenCTIStix2.pick_aliases" href="#pycti.OpenCTIStix2.pick_aliases">pick_aliases</a></code></li>
<li><code><a title="pycti.OpenCTIStix2.prepare_export" href="#pycti.OpenCTIStix2.prepare_export">prepare_export</a></code></li>
<li><code><a title="pycti.OpenCTIStix2.resolve_author" href="#pycti.OpenCTIStix2.resolve_author">resolve_author</a></code></li>
<li><code><a title="pycti.OpenCTIStix2.unknown_type" href="#pycti.OpenCTIStix2.unknown_type">unknown_type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pycti.Opinion" href="#pycti.Opinion">Opinion</a></code></h4>
<ul class="">
<li><code><a title="pycti.Opinion.add_stix_entity" href="#pycti.Opinion.add_stix_entity">add_stix_entity</a></code></li>
<li><code><a title="pycti.Opinion.add_stix_observable" href="#pycti.Opinion.add_stix_observable">add_stix_observable</a></code></li>
<li><code><a title="pycti.Opinion.contains_stix_entity" href="#pycti.Opinion.contains_stix_entity">contains_stix_entity</a></code></li>
<li><code><a title="pycti.Opinion.contains_stix_observable" href="#pycti.Opinion.contains_stix_observable">contains_stix_observable</a></code></li>
<li><code><a title="pycti.Opinion.create" href="#pycti.Opinion.create">create</a></code></li>
<li><code><a title="pycti.Opinion.create_raw" href="#pycti.Opinion.create_raw">create_raw</a></code></li>
<li><code><a title="pycti.Opinion.get_by_stix_id_or_name" href="#pycti.Opinion.get_by_stix_id_or_name">get_by_stix_id_or_name</a></code></li>
<li><code><a title="pycti.Opinion.import_from_stix2" href="#pycti.Opinion.import_from_stix2">import_from_stix2</a></code></li>
<li><code><a title="pycti.Opinion.list" href="#pycti.Opinion.list">list</a></code></li>
<li><code><a title="pycti.Opinion.read" href="#pycti.Opinion.read">read</a></code></li>
<li><code><a title="pycti.Opinion.to_stix2" href="#pycti.Opinion.to_stix2">to_stix2</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pycti.Report" href="#pycti.Report">Report</a></code></h4>
<ul class="">
<li><code><a title="pycti.Report.add_stix_entity" href="#pycti.Report.add_stix_entity">add_stix_entity</a></code></li>
<li><code><a title="pycti.Report.add_stix_observable" href="#pycti.Report.add_stix_observable">add_stix_observable</a></code></li>
<li><code><a title="pycti.Report.contains_stix_entity" href="#pycti.Report.contains_stix_entity">contains_stix_entity</a></code></li>
<li><code><a title="pycti.Report.contains_stix_observable" href="#pycti.Report.contains_stix_observable">contains_stix_observable</a></code></li>
<li><code><a title="pycti.Report.create" href="#pycti.Report.create">create</a></code></li>
<li><code><a title="pycti.Report.create_raw" href="#pycti.Report.create_raw">create_raw</a></code></li>
<li><code><a title="pycti.Report.get_by_stix_id_or_name" href="#pycti.Report.get_by_stix_id_or_name">get_by_stix_id_or_name</a></code></li>
<li><code><a title="pycti.Report.import_from_stix2" href="#pycti.Report.import_from_stix2">import_from_stix2</a></code></li>
<li><code><a title="pycti.Report.list" href="#pycti.Report.list">list</a></code></li>
<li><code><a title="pycti.Report.read" href="#pycti.Report.read">read</a></code></li>
<li><code><a title="pycti.Report.to_stix2" href="#pycti.Report.to_stix2">to_stix2</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pycti.StixDomainEntity" href="#pycti.StixDomainEntity">StixDomainEntity</a></code></h4>
<ul class="">
<li><code><a title="pycti.StixDomainEntity.add_file" href="#pycti.StixDomainEntity.add_file">add_file</a></code></li>
<li><code><a title="pycti.StixDomainEntity.delete" href="#pycti.StixDomainEntity.delete">delete</a></code></li>
<li><code><a title="pycti.StixDomainEntity.get_by_stix_id_or_name" href="#pycti.StixDomainEntity.get_by_stix_id_or_name">get_by_stix_id_or_name</a></code></li>
<li><code><a title="pycti.StixDomainEntity.list" href="#pycti.StixDomainEntity.list">list</a></code></li>
<li><code><a title="pycti.StixDomainEntity.push_entity_export" href="#pycti.StixDomainEntity.push_entity_export">push_entity_export</a></code></li>
<li><code><a title="pycti.StixDomainEntity.push_list_export" href="#pycti.StixDomainEntity.push_list_export">push_list_export</a></code></li>
<li><code><a title="pycti.StixDomainEntity.read" href="#pycti.StixDomainEntity.read">read</a></code></li>
<li><code><a title="pycti.StixDomainEntity.update_field" href="#pycti.StixDomainEntity.update_field">update_field</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pycti.StixEntity" href="#pycti.StixEntity">StixEntity</a></code></h4>
<ul class="">
<li><code><a title="pycti.StixEntity.add_external_reference" href="#pycti.StixEntity.add_external_reference">add_external_reference</a></code></li>
<li><code><a title="pycti.StixEntity.add_kill_chain_phase" href="#pycti.StixEntity.add_kill_chain_phase">add_kill_chain_phase</a></code></li>
<li><code><a title="pycti.StixEntity.add_marking_definition" href="#pycti.StixEntity.add_marking_definition">add_marking_definition</a></code></li>
<li><code><a title="pycti.StixEntity.add_tag" href="#pycti.StixEntity.add_tag">add_tag</a></code></li>
<li><code><a title="pycti.StixEntity.read" href="#pycti.StixEntity.read">read</a></code></li>
<li><code><a title="pycti.StixEntity.reports" href="#pycti.StixEntity.reports">reports</a></code></li>
<li><code><a title="pycti.StixEntity.update_created_by_ref" href="#pycti.StixEntity.update_created_by_ref">update_created_by_ref</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pycti.StixObservable" href="#pycti.StixObservable">StixObservable</a></code></h4>
<ul class="">
<li><code><a title="pycti.StixObservable.create" href="#pycti.StixObservable.create">create</a></code></li>
<li><code><a title="pycti.StixObservable.create_raw" href="#pycti.StixObservable.create_raw">create_raw</a></code></li>
<li><code><a title="pycti.StixObservable.delete" href="#pycti.StixObservable.delete">delete</a></code></li>
<li><code><a title="pycti.StixObservable.list" href="#pycti.StixObservable.list">list</a></code></li>
<li><code><a title="pycti.StixObservable.read" href="#pycti.StixObservable.read">read</a></code></li>
<li><code><a title="pycti.StixObservable.update_created_by_ref" href="#pycti.StixObservable.update_created_by_ref">update_created_by_ref</a></code></li>
<li><code><a title="pycti.StixObservable.update_field" href="#pycti.StixObservable.update_field">update_field</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pycti.StixObservableRelation" href="#pycti.StixObservableRelation">StixObservableRelation</a></code></h4>
<ul class="">
<li><code><a title="pycti.StixObservableRelation.create" href="#pycti.StixObservableRelation.create">create</a></code></li>
<li><code><a title="pycti.StixObservableRelation.create_raw" href="#pycti.StixObservableRelation.create_raw">create_raw</a></code></li>
<li><code><a title="pycti.StixObservableRelation.list" href="#pycti.StixObservableRelation.list">list</a></code></li>
<li><code><a title="pycti.StixObservableRelation.read" href="#pycti.StixObservableRelation.read">read</a></code></li>
<li><code><a title="pycti.StixObservableRelation.update_field" href="#pycti.StixObservableRelation.update_field">update_field</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pycti.StixRelation" href="#pycti.StixRelation">StixRelation</a></code></h4>
<ul class="">
<li><code><a title="pycti.StixRelation.add_kill_chain_phase" href="#pycti.StixRelation.add_kill_chain_phase">add_kill_chain_phase</a></code></li>
<li><code><a title="pycti.StixRelation.create" href="#pycti.StixRelation.create">create</a></code></li>
<li><code><a title="pycti.StixRelation.create_raw" href="#pycti.StixRelation.create_raw">create_raw</a></code></li>
<li><code><a title="pycti.StixRelation.delete" href="#pycti.StixRelation.delete">delete</a></code></li>
<li><code><a title="pycti.StixRelation.list" href="#pycti.StixRelation.list">list</a></code></li>
<li><code><a title="pycti.StixRelation.read" href="#pycti.StixRelation.read">read</a></code></li>
<li><code><a title="pycti.StixRelation.to_stix2" href="#pycti.StixRelation.to_stix2">to_stix2</a></code></li>
<li><code><a title="pycti.StixRelation.update_field" href="#pycti.StixRelation.update_field">update_field</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pycti.Tag" href="#pycti.Tag">Tag</a></code></h4>
<ul class="">
<li><code><a title="pycti.Tag.create" href="#pycti.Tag.create">create</a></code></li>
<li><code><a title="pycti.Tag.create_raw" href="#pycti.Tag.create_raw">create_raw</a></code></li>
<li><code><a title="pycti.Tag.list" href="#pycti.Tag.list">list</a></code></li>
<li><code><a title="pycti.Tag.read" href="#pycti.Tag.read">read</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pycti.ThreatActor" href="#pycti.ThreatActor">ThreatActor</a></code></h4>
<ul class="">
<li><code><a title="pycti.ThreatActor.create" href="#pycti.ThreatActor.create">create</a></code></li>
<li><code><a title="pycti.ThreatActor.create_raw" href="#pycti.ThreatActor.create_raw">create_raw</a></code></li>
<li><code><a title="pycti.ThreatActor.list" href="#pycti.ThreatActor.list">list</a></code></li>
<li><code><a title="pycti.ThreatActor.read" href="#pycti.ThreatActor.read">read</a></code></li>
<li><code><a title="pycti.ThreatActor.to_stix2" href="#pycti.ThreatActor.to_stix2">to_stix2</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pycti.Tool" href="#pycti.Tool">Tool</a></code></h4>
<ul class="">
<li><code><a title="pycti.Tool.create" href="#pycti.Tool.create">create</a></code></li>
<li><code><a title="pycti.Tool.create_raw" href="#pycti.Tool.create_raw">create_raw</a></code></li>
<li><code><a title="pycti.Tool.list" href="#pycti.Tool.list">list</a></code></li>
<li><code><a title="pycti.Tool.read" href="#pycti.Tool.read">read</a></code></li>
<li><code><a title="pycti.Tool.to_stix2" href="#pycti.Tool.to_stix2">to_stix2</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pycti.Vulnerability" href="#pycti.Vulnerability">Vulnerability</a></code></h4>
<ul class="">
<li><code><a title="pycti.Vulnerability.create" href="#pycti.Vulnerability.create">create</a></code></li>
<li><code><a title="pycti.Vulnerability.create_raw" href="#pycti.Vulnerability.create_raw">create_raw</a></code></li>
<li><code><a title="pycti.Vulnerability.list" href="#pycti.Vulnerability.list">list</a></code></li>
<li><code><a title="pycti.Vulnerability.read" href="#pycti.Vulnerability.read">read</a></code></li>
<li><code><a title="pycti.Vulnerability.to_stix2" href="#pycti.Vulnerability.to_stix2">to_stix2</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>