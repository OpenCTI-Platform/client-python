<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>pycti.utils.opencti_stix2 API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pycti.utils.opencti_stix2</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># coding: utf-8

import time
import os
import json
import uuid
import base64
import datetime
from typing import List

import datefinder
import dateutil.parser
import pytz

from pycti.utils.constants import (
    ObservableTypes,
    IdentityTypes,
    CustomProperties,
    StixObservableRelationTypes,
)

datefinder.ValueError = ValueError, OverflowError
utc = pytz.UTC

# ObservableRelations
OBSERVABLE_RELATIONS = [&#34;corresponds&#34;, &#34;belongs&#34;]

# Spec version
SPEC_VERSION = &#34;2.1&#34;


class OpenCTIStix2:
    &#34;&#34;&#34;
        Python API for Stix2 in OpenCTI
        :param opencti: OpenCTI instance
    &#34;&#34;&#34;

    def __init__(self, opencti):
        self.opencti = opencti
        self.mapping_cache = {}

    def unknown_type(self, stix_object):
        self.opencti.log(
            &#34;error&#34;,
            &#39;Unknown object type &#34;&#39; + stix_object[&#34;type&#34;] + &#39;&#34;, doing nothing...&#39;,
        )

    def convert_markdown(self, text):
        return text.replace(&#34;&lt;code&gt;&#34;, &#34;`&#34;).replace(&#34;&lt;/code&gt;&#34;, &#34;`&#34;)

    def format_date(self, date):
        if isinstance(date, datetime.date):
            return date.isoformat(timespec=&#34;milliseconds&#34;).replace(&#34;+00:00&#34;, &#34;Z&#34;)
        if date is not None:
            return (
                dateutil.parser.parse(date)
                .isoformat(timespec=&#34;milliseconds&#34;)
                .replace(&#34;+00:00&#34;, &#34;Z&#34;)
            )
        else:
            return (
                datetime.datetime.utcnow()
                .isoformat(timespec=&#34;milliseconds&#34;)
                .replace(&#34;+00:00&#34;, &#34;Z&#34;)
            )

    def filter_objects(self, uuids, objects):
        result = []
        if objects is not None:
            for object in objects:
                if &#34;id&#34; in object and object[&#34;id&#34;] not in uuids:
                    result.append(object)
        return result

    def pick_aliases(self, stix_object):
        # Add aliases
        if CustomProperties.ALIASES in stix_object:
            return stix_object[CustomProperties.ALIASES]
        elif &#34;x_mitre_aliases&#34; in stix_object:
            return stix_object[&#34;x_mitre_aliases&#34;]
        elif &#34;x_amitt_aliases&#34; in stix_object:
            return stix_object[&#34;x_amitt_aliases&#34;]
        elif &#34;aliases&#34; in stix_object:
            return stix_object[&#34;aliases&#34;]
        return None

    def check_max_marking_definition(
        self, max_marking_definition_entity, entity_marking_definitions
    ):
        # Max is not set, return True
        if max_marking_definition_entity is None:
            return True
        # Filter entity markings definition to the max_marking_definition type
        typed_entity_marking_definitions = []
        for entity_marking_definition in entity_marking_definitions:
            if (
                entity_marking_definition[&#34;definition_type&#34;]
                == max_marking_definition_entity[&#34;definition_type&#34;]
            ):
                typed_entity_marking_definitions.append(entity_marking_definition)
        # No entity marking defintions of the max_marking_definition type
        if len(typed_entity_marking_definitions) == 0:
            return True

        # Check if level is less or equal to max
        for typed_entity_marking_definition in typed_entity_marking_definitions:
            if (
                typed_entity_marking_definition[&#34;level&#34;]
                &lt;= max_marking_definition_entity[&#34;level&#34;]
            ):
                return True
        return False

    def import_bundle_from_file(self, file_path, update=False, types=None):
        if types is None:
            types = []
        if not os.path.isfile(file_path):
            self.opencti.log(&#34;error&#34;, &#34;The bundle file does not exists&#34;)
            return None

        with open(os.path.join(file_path)) as file:
            data = json.load(file)

        return self.import_bundle(data, update, types)

    def import_bundle_from_json(self, json_data, update=False, types=None) -&gt; List:
        if types is None:
            types = []
        data = json.loads(json_data)
        return self.import_bundle(data, update, types)

    def extract_embedded_relationships(self, stix_object, types=None):
        # Created By Ref
        created_by_ref_id = None
        if &#34;created_by_ref&#34; in stix_object:
            created_by_ref = stix_object[&#34;created_by_ref&#34;]
            if created_by_ref in self.mapping_cache:
                created_by_ref_result = self.mapping_cache[created_by_ref]
            else:
                created_by_ref_result = self.opencti.stix_domain_entity.read(
                    id=created_by_ref
                )
                if created_by_ref_result is not None:
                    self.mapping_cache[created_by_ref] = {
                        &#34;id&#34;: created_by_ref_result[&#34;id&#34;],
                        &#34;type&#34;: created_by_ref_result[&#34;entity_type&#34;],
                    }
            if created_by_ref_result is not None:
                created_by_ref_id = created_by_ref_result[&#34;id&#34;]

        # Object Marking Refs
        marking_definitions_ids = []
        if &#34;object_marking_refs&#34; in stix_object:
            for object_marking_ref in stix_object[&#34;object_marking_refs&#34;]:
                if object_marking_ref in self.mapping_cache:
                    object_marking_ref_result = self.mapping_cache[object_marking_ref]
                else:
                    object_marking_ref_result = self.opencti.marking_definition.read(
                        id=object_marking_ref
                    )
                    if object_marking_ref_result is not None:
                        self.mapping_cache[object_marking_ref] = {
                            &#34;id&#34;: object_marking_ref_result[&#34;id&#34;],
                            &#34;type&#34;: object_marking_ref_result[&#34;entity_type&#34;],
                        }
                if object_marking_ref_result is not None:
                    marking_definitions_ids.append(object_marking_ref_result[&#34;id&#34;])

        # Object Tags
        tags_ids = []
        if CustomProperties.TAG_TYPE in stix_object:
            for tag in stix_object[CustomProperties.TAG_TYPE]:
                tag_result = None
                if &#34;id&#34; in tag:
                    if tag[&#34;id&#34;] in self.mapping_cache:
                        tag_result = self.mapping_cache[tag[&#34;id&#34;]]
                    else:
                        tag_result = self.opencti.tag.read(id=tag[&#34;id&#34;])
                if tag_result is not None:
                    self.mapping_cache[tag[&#34;id&#34;]] = {&#34;id&#34;: tag_result[&#34;id&#34;]}
                else:
                    tag_result = self.opencti.tag.create(
                        tag_type=tag[&#34;tag_type&#34;],
                        value=tag[&#34;value&#34;],
                        color=tag[&#34;color&#34;],
                        id=tag[&#34;id&#34;] if &#34;id&#34; in tag else None,
                    )
                if tag_result is not None:
                    tags_ids.append(tag_result[&#34;id&#34;])

        # Kill Chain Phases
        kill_chain_phases_ids = []
        if &#34;kill_chain_phases&#34; in stix_object:
            for kill_chain_phase in stix_object[&#34;kill_chain_phases&#34;]:
                if kill_chain_phase[&#34;phase_name&#34;] in self.mapping_cache:
                    kill_chain_phase = self.mapping_cache[
                        kill_chain_phase[&#34;phase_name&#34;]
                    ]
                else:
                    kill_chain_phase = self.opencti.kill_chain_phase.create(
                        kill_chain_name=kill_chain_phase[&#34;kill_chain_name&#34;],
                        phase_name=kill_chain_phase[&#34;phase_name&#34;],
                        phase_order=kill_chain_phase[CustomProperties.PHASE_ORDER]
                        if CustomProperties.PHASE_ORDER in kill_chain_phase
                        else 0,
                        id=kill_chain_phase[CustomProperties.ID]
                        if CustomProperties.ID in kill_chain_phase
                        else None,
                        stix_id_key=kill_chain_phase[&#34;id&#34;]
                        if &#34;id&#34; in kill_chain_phase
                        else None,
                        created=kill_chain_phase[CustomProperties.CREATED]
                        if CustomProperties.CREATED in kill_chain_phase
                        else None,
                        modified=kill_chain_phase[CustomProperties.MODIFIED]
                        if CustomProperties.MODIFIED in kill_chain_phase
                        else None,
                    )
                    self.mapping_cache[kill_chain_phase[&#34;phase_name&#34;]] = {
                        &#34;id&#34;: kill_chain_phase[&#34;id&#34;],
                        &#34;type&#34;: kill_chain_phase[&#34;entity_type&#34;],
                    }
                kill_chain_phases_ids.append(kill_chain_phase[&#34;id&#34;])

        # Object refs
        object_refs_ids = []
        if &#34;object_refs&#34; in stix_object:
            for object_ref in stix_object[&#34;object_refs&#34;]:
                object_ref_result = None
                if object_ref in self.mapping_cache:
                    object_ref_result = self.mapping_cache[object_ref]
                elif &#34;relationship&#34; in object_ref:
                    object_ref_result = self.opencti.stix_relation.read(id=object_ref)
                    if object_ref_result is not None:
                        self.mapping_cache[object_ref] = {
                            &#34;id&#34;: object_ref_result[&#34;id&#34;],
                            &#34;type&#34;: object_ref_result[&#34;entity_type&#34;],
                        }
                elif &#34;observed-data&#34; not in object_ref:
                    object_ref_result = self.opencti.stix_entity.read(id=object_ref)
                    if object_ref_result is not None:
                        self.mapping_cache[object_ref] = {
                            &#34;id&#34;: object_ref_result[&#34;id&#34;],
                            &#34;type&#34;: object_ref_result[&#34;entity_type&#34;],
                        }
                if &#34;observed-data&#34; not in object_ref:
                    if object_ref_result is not None:
                        object_refs_ids.append(object_ref_result[&#34;id&#34;])
                else:
                    object_refs_ids.append(object_ref)

        # External References
        reports = {}
        external_references_ids = []
        if &#34;external_references&#34; in stix_object:
            for external_reference in stix_object[&#34;external_references&#34;]:
                if &#34;url&#34; in external_reference and &#34;source_name&#34; in external_reference:
                    url = external_reference[&#34;url&#34;]
                    source_name = external_reference[&#34;source_name&#34;]
                else:
                    continue
                if url in self.mapping_cache:
                    external_reference_id = self.mapping_cache[url][&#34;id&#34;]
                else:
                    external_reference_id = self.opencti.external_reference.create(
                        source_name=source_name,
                        url=url,
                        external_id=external_reference[&#34;external_id&#34;]
                        if &#34;external_id&#34; in external_reference
                        else None,
                        description=external_reference[&#34;description&#34;]
                        if &#34;description&#34; in external_reference
                        else None,
                        id=external_reference[CustomProperties.ID]
                        if CustomProperties.ID in external_reference
                        else None,
                        stix_id_key=external_reference[&#34;id&#34;]
                        if &#34;id&#34; in external_reference
                        else None,
                        created=external_reference[CustomProperties.CREATED]
                        if CustomProperties.CREATED in external_reference
                        else None,
                        modified=external_reference[CustomProperties.MODIFIED]
                        if CustomProperties.MODIFIED in external_reference
                        else None,
                    )[&#34;id&#34;]
                self.mapping_cache[url] = {&#34;id&#34;: external_reference_id}
                external_references_ids.append(external_reference_id)

                if stix_object[&#34;type&#34;] in [
                    &#34;threat-actor&#34;,
                    &#34;intrusion-set&#34;,
                    &#34;campaign&#34;,
                    &#34;incident&#34;,
                    &#34;malware&#34;,
                    &#34;relationship&#34;,
                ] and (types is None or &#34;report&#34; in types):
                    # Add a corresponding report
                    # Extract date
                    try:
                        if &#34;description&#34; in external_reference:
                            matches = datefinder.find_dates(
                                external_reference[&#34;description&#34;]
                            )
                        else:
                            matches = datefinder.find_dates(source_name)
                    except:
                        matches = None
                    published = None
                    today = datetime.datetime.today()
                    if matches is not None:
                        for match in matches:
                            if match &lt; today:
                                published = match.strftime(&#34;%Y-%m-%dT%H:%M:%SZ&#34;)
                    if published is None:
                        published = today.strftime(&#34;%Y-%m-%dT%H:%M:%SZ&#34;)

                    if &#34;mitre&#34; in source_name and &#34;name&#34; in stix_object:
                        title = &#34;[MITRE ATT&amp;CK] &#34; + stix_object[&#34;name&#34;]
                        if &#34;modified&#34; in stix_object:
                            published = stix_object[&#34;modified&#34;]
                    elif &#34;amitt&#34; in source_name and &#34;name&#34; in stix_object:
                        title = &#34;[AM!TT] &#34; + stix_object[&#34;name&#34;]
                        if &#34;modified&#34; in stix_object:
                            published = stix_object[&#34;modified&#34;]
                    else:
                        title = source_name

                    if &#34;external_id&#34; in external_reference:
                        title = title + &#34; (&#34; + external_reference[&#34;external_id&#34;] + &#34;)&#34;

                    author = self.resolve_author(title)
                    report = self.opencti.report.create(
                        name=title,
                        external_reference_id=external_reference_id,
                        description=external_reference[&#34;description&#34;]
                        if &#34;description&#34; in external_reference
                        else &#34;&#34;,
                        published=published,
                        report_class=&#34;Threat Report&#34;,
                        object_status=2,
                        createdByRef=author[&#34;id&#34;] if author is not None else None,
                        update=True,
                    )
                    # Add marking
                    if &#34;marking_tlpwhite&#34; in self.mapping_cache:
                        object_marking_ref_result = self.mapping_cache[
                            &#34;marking_tlpwhite&#34;
                        ]
                    else:
                        object_marking_ref_result = self.opencti.marking_definition.read(
                            filters=[
                                {&#34;key&#34;: &#34;definition_type&#34;, &#34;values&#34;: [&#34;TLP&#34;]},
                                {&#34;key&#34;: &#34;definition&#34;, &#34;values&#34;: [&#34;TLP:WHITE&#34;]},
                            ]
                        )
                    if object_marking_ref_result is not None:
                        self.mapping_cache[&#34;marking_tlpwhite&#34;] = {
                            &#34;id&#34;: object_marking_ref_result[&#34;id&#34;]
                        }
                        self.opencti.stix_entity.add_marking_definition(
                            id=report[&#34;id&#34;],
                            marking_definition_id=object_marking_ref_result[&#34;id&#34;],
                        )

                    # Add external reference to report
                    self.opencti.stix_entity.add_external_reference(
                        id=report[&#34;id&#34;], external_reference_id=external_reference_id,
                    )
                    reports[external_reference_id] = report

        return {
            &#34;created_by_ref&#34;: created_by_ref_id,
            &#34;marking_definitions&#34;: marking_definitions_ids,
            &#34;tags&#34;: tags_ids,
            &#34;kill_chain_phases&#34;: kill_chain_phases_ids,
            &#34;object_refs&#34;: object_refs_ids,
            &#34;external_references&#34;: external_references_ids,
            &#34;reports&#34;: reports,
        }

    def import_object(self, stix_object, update=False, types=None):
        self.opencti.log(
            &#34;info&#34;,
            &#34;Importing a &#34; + stix_object[&#34;type&#34;] + &#34; (id: &#34; + stix_object[&#34;id&#34;] + &#34;)&#34;,
        )

        # Extract
        embedded_relationships = self.extract_embedded_relationships(stix_object, types)
        created_by_ref_id = embedded_relationships[&#34;created_by_ref&#34;]
        marking_definitions_ids = embedded_relationships[&#34;marking_definitions&#34;]
        tags_ids = embedded_relationships[&#34;tags&#34;]
        kill_chain_phases_ids = embedded_relationships[&#34;kill_chain_phases&#34;]
        object_refs_ids = embedded_relationships[&#34;object_refs&#34;]
        external_references_ids = embedded_relationships[&#34;external_references&#34;]
        reports = embedded_relationships[&#34;reports&#34;]

        # Extra
        extras = {
            &#34;created_by_ref_id&#34;: created_by_ref_id,
            &#34;marking_definitions_ids&#34;: marking_definitions_ids,
            &#34;tags_ids&#34;: tags_ids,
            &#34;kill_chain_phases_ids&#34;: kill_chain_phases_ids,
            &#34;object_refs_ids&#34;: object_refs_ids,
            &#34;external_references_ids&#34;: external_references_ids,
            &#34;reports&#34;: reports,
        }

        # Import
        importer = {
            &#34;marking-definition&#34;: self.create_marking_definition,
            &#34;identity&#34;: self.create_identity,
            &#34;threat-actor&#34;: self.create_threat_actor,
            &#34;intrusion-set&#34;: self.create_intrusion_set,
            &#34;campaign&#34;: self.create_campaign,
            &#34;x-opencti-incident&#34;: self.create_incident,
            &#34;malware&#34;: self.create_malware,
            &#34;tool&#34;: self.create_tool,
            &#34;vulnerability&#34;: self.create_vulnerability,
            &#34;attack-pattern&#34;: self.create_attack_pattern,
            &#34;course-of-action&#34;: self.create_course_of_action,
            &#34;report&#34;: self.create_report,
            &#34;note&#34;: self.create_note,
            &#34;opinion&#34;: self.create_opinion,
            &#34;indicator&#34;: self.create_indicator,
        }
        do_import = importer.get(
            stix_object[&#34;type&#34;],
            lambda stix_object, extras, update: self.unknown_type(stix_object),
        )
        stix_object_results = do_import(stix_object, extras, update)

        if stix_object_results is None:
            return stix_object_results

        if not isinstance(stix_object_results, list):
            stix_object_results = [stix_object_results]

        for stix_object_result in stix_object_results:
            # Add embedded relationships
            self.mapping_cache[stix_object[&#34;id&#34;]] = {
                &#34;id&#34;: stix_object_result[&#34;id&#34;],
                &#34;type&#34;: stix_object_result[&#34;entity_type&#34;],
                &#34;observableRefs&#34;: stix_object_result[&#34;observableRefs&#34;]
                if &#34;observableRefs&#34; in stix_object_result
                else [],
            }
            self.mapping_cache[stix_object_result[&#34;id&#34;]] = {
                &#34;id&#34;: stix_object_result[&#34;id&#34;],
                &#34;type&#34;: stix_object_result[&#34;entity_type&#34;],
                &#34;observableRefs&#34;: stix_object_result[&#34;observableRefs&#34;]
                if &#34;observableRefs&#34; in stix_object_result
                else [],
            }

            # Add tags
            for tag_id in tags_ids:
                self.opencti.stix_entity.add_tag(
                    id=stix_object_result[&#34;id&#34;], tag_id=tag_id,
                )
            # Add external references
            for external_reference_id in external_references_ids:
                self.opencti.stix_entity.add_external_reference(
                    id=stix_object_result[&#34;id&#34;],
                    external_reference_id=external_reference_id,
                )
                if external_reference_id in reports:
                    self.opencti.report.add_stix_entity(
                        id=reports[external_reference_id][&#34;id&#34;],
                        entity_id=stix_object_result[&#34;id&#34;],
                    )
            # Add object refs
            for object_refs_id in object_refs_ids:
                if &#34;observed-data&#34; in object_refs_id:
                    if object_refs_id in self.mapping_cache:
                        for observable in self.mapping_cache[object_refs_id]:
                            if stix_object_result[&#34;entity_type&#34;] == &#34;report&#34;:
                                self.opencti.report.add_stix_observable(
                                    id=stix_object_result[&#34;id&#34;],
                                    stix_observable_id=observable[&#34;id&#34;],
                                )
                            elif stix_object_result[&#34;entity_type&#34;] == &#34;note&#34;:
                                self.opencti.note.add_stix_observable(
                                    id=stix_object_result[&#34;id&#34;],
                                    stix_observable_id=observable[&#34;id&#34;],
                                )
                            elif stix_object_result[&#34;entity_type&#34;] == &#34;opinion&#34;:
                                self.opencti.opinion.add_stix_observable(
                                    id=stix_object_result[&#34;id&#34;],
                                    stix_observable_id=observable[&#34;id&#34;],
                                )
                else:
                    if stix_object_result[&#34;entity_type&#34;] == &#34;report&#34;:
                        self.opencti.report.add_stix_entity(
                            id=stix_object_result[&#34;id&#34;], entity_id=object_refs_id,
                        )
                    elif stix_object_result[&#34;entity_type&#34;] == &#34;note&#34;:
                        self.opencti.note.add_stix_entity(
                            id=stix_object_result[&#34;id&#34;], entity_id=object_refs_id,
                        )
                    elif stix_object_result[&#34;entity_type&#34;] == &#34;opinion&#34;:
                        self.opencti.opinion.add_stix_entity(
                            id=stix_object_result[&#34;id&#34;], entity_id=object_refs_id,
                        )
                    if (
                        object_refs_id in self.mapping_cache
                        and &#34;observableRefs&#34; in self.mapping_cache[object_refs_id]
                        and self.mapping_cache[object_refs_id] is not None
                        and self.mapping_cache[object_refs_id][&#34;observableRefs&#34;]
                        is not None
                        and len(self.mapping_cache[object_refs_id][&#34;observableRefs&#34;])
                        &gt; 0
                    ):
                        for observable_ref in self.mapping_cache[object_refs_id][
                            &#34;observableRefs&#34;
                        ]:
                            if stix_object_result[&#34;entity_type&#34;] == &#34;report&#34;:
                                self.opencti.report.add_stix_observable(
                                    id=stix_object_result[&#34;id&#34;],
                                    stix_observable_id=observable_ref[&#34;id&#34;],
                                )
                            elif stix_object_result[&#34;entity_type&#34;] == &#34;note&#34;:
                                self.opencti.note.add_stix_observable(
                                    id=stix_object_result[&#34;id&#34;],
                                    stix_observable_id=observable_ref[&#34;id&#34;],
                                )
                            elif stix_object_result[&#34;entity_type&#34;] == &#34;opinion&#34;:
                                self.opencti.opinion.add_stix_observable(
                                    id=stix_object_result[&#34;id&#34;],
                                    stix_observable_id=observable_ref[&#34;id&#34;],
                                )
            # Add files
            if CustomProperties.FILES in stix_object:
                for file in stix_object[CustomProperties.FILES]:
                    self.opencti.stix_domain_entity.add_file(
                        id=stix_object_result[&#34;id&#34;],
                        file_name=file[&#34;name&#34;],
                        data=base64.b64decode(file[&#34;data&#34;]),
                        mime_type=file[&#34;mime_type&#34;],
                    )

        return stix_object_results

    def import_relationship(self, stix_relation, update=False, types=None):
        # Extract
        embedded_relationships = self.extract_embedded_relationships(
            stix_relation, types
        )
        created_by_ref_id = embedded_relationships[&#34;created_by_ref&#34;]
        marking_definitions_ids = embedded_relationships[&#34;marking_definitions&#34;]
        kill_chain_phases_ids = embedded_relationships[&#34;kill_chain_phases&#34;]
        external_references_ids = embedded_relationships[&#34;external_references&#34;]
        reports = embedded_relationships[&#34;reports&#34;]

        # Extra
        extras = {
            &#34;created_by_ref_id&#34;: created_by_ref_id,
            &#34;marking_definitions_ids&#34;: marking_definitions_ids,
            &#34;kill_chain_phases_ids&#34;: kill_chain_phases_ids,
            &#34;external_references_ids&#34;: external_references_ids,
            &#34;reports&#34;: reports,
        }

        # Create the relation

        ### Get the SOURCE_REF
        if CustomProperties.SOURCE_REF in stix_relation:
            source_ref = stix_relation[CustomProperties.SOURCE_REF]
        else:
            source_ref = stix_relation[&#34;source_ref&#34;]
        if source_ref in self.mapping_cache:
            if (
                StixObservableRelationTypes.has_value(
                    stix_relation[&#34;relationship_type&#34;]
                )
                and &#34;observableRefs&#34; in self.mapping_cache[source_ref]
                and self.mapping_cache[source_ref][&#34;observableRefs&#34;] is not None
                and len(self.mapping_cache[source_ref][&#34;observableRefs&#34;]) &gt; 0
            ):
                source_id = self.mapping_cache[source_ref][&#34;observableRefs&#34;][0][&#34;id&#34;]
                source_type = self.mapping_cache[source_ref][&#34;observableRefs&#34;][0][
                    &#34;entity_type&#34;
                ]
            else:
                source_id = self.mapping_cache[source_ref][&#34;id&#34;]
                source_type = self.mapping_cache[source_ref][&#34;type&#34;]
        else:
            stix_object_result = self.opencti.stix_entity.read(id=source_ref)
            if stix_object_result is not None:
                source_id = stix_object_result[&#34;id&#34;]
                source_type = stix_object_result[&#34;entity_type&#34;]
            else:
                self.opencti.log(
                    &#34;error&#34;,
                    &#34;Source ref of the relationship not found, doing nothing...&#34;,
                )
                return None

        ### Get the TARGET_REF
        if CustomProperties.TARGET_REF in stix_relation:
            target_ref = stix_relation[CustomProperties.TARGET_REF]
        else:
            target_ref = stix_relation[&#34;target_ref&#34;]
        if target_ref in self.mapping_cache:
            if (
                StixObservableRelationTypes.has_value(
                    stix_relation[&#34;relationship_type&#34;]
                )
                and &#34;observableRefs&#34; in self.mapping_cache[target_ref]
                and self.mapping_cache[target_ref][&#34;observableRefs&#34;] is not None
                and len(self.mapping_cache[target_ref][&#34;observableRefs&#34;]) &gt; 0
            ):
                target_id = self.mapping_cache[target_ref][&#34;observableRefs&#34;][0][&#34;id&#34;]
                target_type = self.mapping_cache[target_ref][&#34;observableRefs&#34;][0][
                    &#34;entity_type&#34;
                ]
            else:
                target_id = self.mapping_cache[target_ref][&#34;id&#34;]
                target_type = self.mapping_cache[target_ref][&#34;type&#34;]
        else:
            stix_object_result = self.opencti.stix_entity.read(id=target_ref)
            if stix_object_result is not None:
                target_id = stix_object_result[&#34;id&#34;]
                target_type = stix_object_result[&#34;entity_type&#34;]
            else:
                self.opencti.log(
                    &#34;error&#34;,
                    &#34;Target ref of the relationship not found, doing nothing...&#34;,
                )
                return None

        date = None
        if &#34;external_references&#34; in stix_relation:
            for external_reference in stix_relation[&#34;external_references&#34;]:
                try:
                    if &#34;description&#34; in external_reference:
                        matches = datefinder.find_dates(
                            external_reference[&#34;description&#34;]
                        )
                    else:
                        matches = datefinder.find_dates(
                            external_reference[&#34;source_name&#34;]
                        )
                except:
                    matches = None
                date = None
                today = datetime.datetime.today()
                if matches is not None:
                    for match in matches:
                        if match &lt; today:
                            date = match.strftime(&#34;%Y-%m-%dT%H:%M:%SZ&#34;)
        if date is None:
            date = datetime.datetime.today().strftime(&#34;%Y-%m-%dT%H:%M:%SZ&#34;)

        stix_relation_result = None
        if StixObservableRelationTypes.has_value(stix_relation[&#34;relationship_type&#34;]):
            stix_relation_result = self.opencti.stix_observable_relation.create(
                fromId=source_id,
                fromType=source_type,
                toId=target_id,
                toType=target_type,
                relationship_type=stix_relation[&#34;relationship_type&#34;],
                description=self.convert_markdown(stix_relation[&#34;description&#34;])
                if &#34;description&#34; in stix_relation
                else None,
                first_seen=stix_relation[CustomProperties.FIRST_SEEN]
                if CustomProperties.FIRST_SEEN in stix_relation
                else date,
                last_seen=stix_relation[CustomProperties.LAST_SEEN]
                if CustomProperties.LAST_SEEN in stix_relation
                else date,
                weight=stix_relation[CustomProperties.WEIGHT]
                if CustomProperties.WEIGHT in stix_relation
                else 1,
                role_played=stix_relation[CustomProperties.ROLE_PLAYED]
                if CustomProperties.ROLE_PLAYED in stix_relation
                else None,
                id=stix_relation[CustomProperties.ID]
                if CustomProperties.ID in stix_relation
                else None,
                stix_id_key=stix_relation[&#34;id&#34;] if &#34;id&#34; in stix_relation else None,
                created=stix_relation[&#34;created&#34;]
                if &#34;created&#34; in stix_relation
                else None,
                modified=stix_relation[&#34;modified&#34;]
                if &#34;modified&#34; in stix_relation
                else None,
                createdByRef=extras[&#34;created_by_ref_id&#34;]
                if &#34;created_by_ref_id&#34; in extras
                else None,
                markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
                if &#34;marking_definitions_ids&#34; in extras
                else [],
                killChainPhases=extras[&#34;kill_chain_phases_ids&#34;]
                if &#34;kill_chain_phases_ids&#34; in extras
                else [],
                update=update,
                ignore_dates=stix_relation[CustomProperties.IGNORE_DATES]
                if CustomProperties.IGNORE_DATES in stix_relation
                else None,
            )
        else:
            stix_relation_result = self.opencti.stix_relation.create(
                fromId=source_id,
                fromType=source_type,
                toId=target_id,
                toType=target_type,
                relationship_type=stix_relation[&#34;relationship_type&#34;],
                description=self.convert_markdown(stix_relation[&#34;description&#34;])
                if &#34;description&#34; in stix_relation
                else None,
                first_seen=stix_relation[CustomProperties.FIRST_SEEN]
                if CustomProperties.FIRST_SEEN in stix_relation
                else date,
                last_seen=stix_relation[CustomProperties.LAST_SEEN]
                if CustomProperties.LAST_SEEN in stix_relation
                else date,
                weight=stix_relation[CustomProperties.WEIGHT]
                if CustomProperties.WEIGHT in stix_relation
                else 1,
                role_played=stix_relation[CustomProperties.ROLE_PLAYED]
                if CustomProperties.ROLE_PLAYED in stix_relation
                else None,
                id=stix_relation[CustomProperties.ID]
                if CustomProperties.ID in stix_relation
                else None,
                stix_id_key=stix_relation[&#34;id&#34;] if &#34;id&#34; in stix_relation else None,
                created=stix_relation[&#34;created&#34;]
                if &#34;created&#34; in stix_relation
                else None,
                modified=stix_relation[&#34;modified&#34;]
                if &#34;modified&#34; in stix_relation
                else None,
                createdByRef=extras[&#34;created_by_ref_id&#34;]
                if &#34;created_by_ref_id&#34; in extras
                else None,
                markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
                if &#34;marking_definitions_ids&#34; in extras
                else [],
                killChainPhases=extras[&#34;kill_chain_phases_ids&#34;]
                if &#34;kill_chain_phases_ids&#34; in extras
                else [],
                update=update,
                ignore_dates=stix_relation[CustomProperties.IGNORE_DATES]
                if CustomProperties.IGNORE_DATES in stix_relation
                else None,
            )
        if stix_relation_result is not None:
            self.mapping_cache[stix_relation[&#34;id&#34;]] = {
                &#34;id&#34;: stix_relation_result[&#34;id&#34;],
                &#34;type&#34;: stix_relation_result[&#34;entity_type&#34;],
            }
        else:
            return None

        # Add external references
        for external_reference_id in external_references_ids:
            self.opencti.stix_entity.add_external_reference(
                id=stix_relation_result[&#34;id&#34;],
                external_reference_id=external_reference_id,
            )
            if external_reference_id in reports:
                self.opencti.report.add_stix_entity(
                    id=reports[external_reference_id][&#34;id&#34;],
                    entity_id=stix_relation_result[&#34;id&#34;],
                )
                self.opencti.report.add_stix_entity(
                    id=reports[external_reference_id][&#34;id&#34;], entity_id=source_id,
                )
                self.opencti.report.add_stix_entity(
                    id=reports[external_reference_id][&#34;id&#34;], entity_id=target_id,
                )

    def import_observables(self, stix_object):
        # Extract
        embedded_relationships = self.extract_embedded_relationships(stix_object)
        created_by_ref_id = embedded_relationships[&#34;created_by_ref&#34;]
        marking_definitions_ids = embedded_relationships[&#34;marking_definitions&#34;]

        observables_to_create = {}
        relations_to_create = []
        for key, observable_item in stix_object[&#34;objects&#34;].items():
            # TODO artifact
            if (
                CustomProperties.OBSERVABLE_TYPE in observable_item
                and CustomProperties.OBSERVABLE_VALUE in observable_item
            ):
                observables_to_create[key] = [
                    {
                        &#34;id&#34;: str(uuid.uuid4()),
                        &#34;stix_id&#34;: &#34;observable--&#34; + str(uuid.uuid4()),
                        &#34;type&#34;: observable_item[CustomProperties.OBSERVABLE_TYPE],
                        &#34;value&#34;: observable_item[CustomProperties.OBSERVABLE_VALUE],
                    }
                ]
            elif observable_item[&#34;type&#34;] == &#34;autonomous-system&#34;:
                observables_to_create[key] = [
                    {
                        &#34;id&#34;: str(uuid.uuid4()),
                        &#34;stix_id&#34;: &#34;observable--&#34; + str(uuid.uuid4()),
                        &#34;type&#34;: ObservableTypes.AUTONOMOUS_SYSTEM.value,
                        &#34;value&#34;: &#34;AS&#34; + observable_item[&#34;number&#34;],
                    }
                ]
            elif observable_item[&#34;type&#34;] == &#34;directory&#34;:
                observables_to_create[key] = [
                    {
                        &#34;id&#34;: str(uuid.uuid4()),
                        &#34;stix_id&#34;: &#34;observable--&#34; + str(uuid.uuid4()),
                        &#34;type&#34;: ObservableTypes.DIRECTORY.value,
                        &#34;value&#34;: observable_item[&#34;path&#34;],
                    }
                ]
            elif observable_item[&#34;type&#34;] == &#34;domain-name&#34;:
                observables_to_create[key] = [
                    {
                        &#34;id&#34;: str(uuid.uuid4()),
                        &#34;stix_id&#34;: &#34;observable--&#34; + str(uuid.uuid4()),
                        &#34;type&#34;: ObservableTypes.DOMAIN.value,
                        &#34;value&#34;: observable_item[&#34;value&#34;],
                    }
                ]
            elif observable_item[&#34;type&#34;] == &#34;email-addr&#34;:
                observables_to_create[key] = [
                    {
                        &#34;id&#34;: str(uuid.uuid4()),
                        &#34;stix_id&#34;: &#34;observable--&#34; + str(uuid.uuid4()),
                        &#34;type&#34;: ObservableTypes.EMAIL_ADDR.value,
                        &#34;value&#34;: observable_item[&#34;value&#34;],
                    }
                ]
                # TODO Belongs to ref
            # TODO email-message
            # TODO mime-part-type
            elif observable_item[&#34;type&#34;] == &#34;file&#34;:
                observables_to_create[key] = []
                if &#34;name&#34; in observable_item:
                    observables_to_create[key].append(
                        {
                            &#34;id&#34;: str(uuid.uuid4()),
                            &#34;type&#34;: ObservableTypes.FILE_NAME.value,
                            &#34;value&#34;: observable_item[&#34;name&#34;],
                        }
                    )
                if &#34;hashes&#34; in observable_item:
                    for keyfile, value in observable_item[&#34;hashes&#34;].items():
                        if keyfile == &#34;MD5&#34;:
                            observables_to_create[key].append(
                                {
                                    &#34;id&#34;: str(uuid.uuid4()),
                                    &#34;type&#34;: ObservableTypes.FILE_HASH_MD5.value,
                                    &#34;value&#34;: value,
                                }
                            )
                        if keyfile == &#34;SHA-1&#34;:
                            observables_to_create[key].append(
                                {
                                    &#34;id&#34;: str(uuid.uuid4()),
                                    &#34;type&#34;: ObservableTypes.FILE_HASH_SHA1.value,
                                    &#34;value&#34;: value,
                                }
                            )
                        if keyfile == &#34;SHA-256&#34;:
                            observables_to_create[key].append(
                                {
                                    &#34;id&#34;: str(uuid.uuid4()),
                                    &#34;type&#34;: ObservableTypes.FILE_HASH_SHA256.value,
                                    &#34;value&#34;: value,
                                }
                            )
            elif observable_item[&#34;type&#34;] == &#34;ipv4-addr&#34;:
                observables_to_create[key] = [
                    {
                        &#34;id&#34;: str(uuid.uuid4()),
                        &#34;type&#34;: ObservableTypes.IPV4_ADDR.value,
                        &#34;value&#34;: observable_item[&#34;value&#34;],
                    }
                ]
            elif observable_item[&#34;type&#34;] == &#34;ipv6-addr&#34;:
                observables_to_create[key] = [
                    {
                        &#34;id&#34;: str(uuid.uuid4()),
                        &#34;type&#34;: ObservableTypes.IPV6_ADDR.value,
                        &#34;value&#34;: observable_item[&#34;value&#34;],
                    }
                ]
            elif observable_item[&#34;type&#34;] == &#34;mac-addr&#34;:
                observables_to_create[key] = [
                    {
                        &#34;id&#34;: str(uuid.uuid4()),
                        &#34;type&#34;: ObservableTypes.MAC_ADDR.value,
                        &#34;value&#34;: observable_item[&#34;value&#34;],
                    }
                ]
            elif observable_item[&#34;type&#34;] == &#34;windows-registry-key&#34;:
                observables_to_create[key] = [
                    {
                        &#34;id&#34;: str(uuid.uuid4()),
                        &#34;type&#34;: ObservableTypes.REGISTRY_KEY.value,
                        &#34;value&#34;: observable_item[&#34;key&#34;],
                    }
                ]

        for key, observable_item in stix_object[&#34;objects&#34;].items():
            if observable_item[&#34;type&#34;] == &#34;directory&#34;:
                if &#34;contains_refs&#34; in observable_item:
                    for file in observable_item[&#34;contains_refs&#34;]:
                        for observable_to_create_from in observables_to_create[key]:
                            for observables_to_create_to in observables_to_create[file]:
                                if (
                                    observable_to_create_from[&#34;id&#34;]
                                    != observables_to_create_to[&#34;id&#34;]
                                ):
                                    relations_to_create.append(
                                        {
                                            &#34;id&#34;: str(uuid.uuid4()),
                                            &#34;from&#34;: observable_to_create_from[&#34;id&#34;],
                                            &#34;to&#34;: observables_to_create_to[&#34;id&#34;],
                                            &#34;type&#34;: &#34;contains&#34;,
                                        }
                                    )
            if observable_item[&#34;type&#34;] == &#34;domain-name&#34;:
                if &#34;resolves_to_refs&#34; in observable_item:
                    for resolved in observable_item[&#34;resolves_to_refs&#34;]:
                        for observable_to_create_from in observables_to_create[key]:
                            for observables_to_create_to in observables_to_create[
                                resolved
                            ]:
                                if (
                                    observable_to_create_from[&#34;id&#34;]
                                    != observables_to_create_to[&#34;id&#34;]
                                ):
                                    relations_to_create.append(
                                        {
                                            &#34;id&#34;: str(uuid.uuid4()),
                                            &#34;from&#34;: observable_to_create_from[&#34;id&#34;],
                                            &#34;fromType&#34;: observable_to_create_from[
                                                &#34;type&#34;
                                            ],
                                            &#34;to&#34;: observables_to_create_to[&#34;id&#34;],
                                            &#34;toType&#34;: observables_to_create_to[&#34;type&#34;],
                                            &#34;type&#34;: &#34;resolves&#34;,
                                        }
                                    )
            if observable_item[&#34;type&#34;] == &#34;file&#34;:
                for observable_to_create_from in observables_to_create[key]:
                    for observables_to_create_to in observables_to_create[key]:
                        if (
                            observable_to_create_from[&#34;id&#34;]
                            != observables_to_create_to[&#34;id&#34;]
                        ):
                            relations_to_create.append(
                                {
                                    &#34;id&#34;: str(uuid.uuid4()),
                                    &#34;from&#34;: observable_to_create_from[&#34;id&#34;],
                                    &#34;fromType&#34;: observable_to_create_from[&#34;type&#34;],
                                    &#34;to&#34;: observables_to_create_to[&#34;id&#34;],
                                    &#34;toType&#34;: observables_to_create_to[&#34;type&#34;],
                                    &#34;type&#34;: &#34;corresponds&#34;,
                                }
                            )
            if observable_item[&#34;type&#34;] == &#34;ipv4-addr&#34;:
                if &#34;belongs_to_refs&#34; in observable_item:
                    for belonging in observable_item[&#34;belongs_to_refs&#34;]:
                        for observable_to_create_from in observables_to_create[key]:
                            for observables_to_create_to in observables_to_create[
                                belonging
                            ]:
                                if (
                                    observable_to_create_from[&#34;id&#34;]
                                    != observables_to_create_to[&#34;id&#34;]
                                ):
                                    relations_to_create.append(
                                        {
                                            &#34;id&#34;: str(uuid.uuid4()),
                                            &#34;from&#34;: observable_to_create_from[&#34;id&#34;],
                                            &#34;fromType&#34;: observable_to_create_from[
                                                &#34;type&#34;
                                            ],
                                            &#34;to&#34;: observables_to_create_to[&#34;id&#34;],
                                            &#34;toType&#34;: observables_to_create_to[&#34;type&#34;],
                                            &#34;type&#34;: &#34;belongs&#34;,
                                        }
                                    )

        stix_observables_mapping = {}
        self.mapping_cache[stix_object[&#34;id&#34;]] = []
        for key, observable_to_create in observables_to_create.items():
            for observable in observable_to_create:
                observable_result = self.opencti.stix_observable.create(
                    type=observable[&#34;type&#34;],
                    observable_value=observable[&#34;value&#34;],
                    id=observable[&#34;id&#34;],
                    createdByRef=created_by_ref_id,
                    markingDefinitions=marking_definitions_ids,
                    createIndicator=stix_object[CustomProperties.CREATE_INDICATOR]
                    if CustomProperties.CREATE_INDICATOR in stix_object
                    else False,
                )
                stix_observables_mapping[observable[&#34;id&#34;]] = observable_result[&#34;id&#34;]
                self.mapping_cache[stix_object[&#34;id&#34;]].append(
                    {
                        &#34;id&#34;: observable_result[&#34;id&#34;],
                        &#34;type&#34;: observable_result[&#34;entity_type&#34;],
                    }
                )

        stix_observable_relations_mapping = {}
        for relation_to_create in relations_to_create:
            stix_observable_relation_result = self.opencti.stix_observable_relation.create(
                fromId=stix_observables_mapping[relation_to_create[&#34;from&#34;]],
                fromType=relation_to_create[&#34;fromType&#34;],
                toId=stix_observables_mapping[relation_to_create[&#34;to&#34;]],
                toType=relation_to_create[&#34;toType&#34;],
                relationship_type=relation_to_create[&#34;type&#34;],
                createdByRef=created_by_ref_id,
                markingDefinitions=marking_definitions_ids,
            )
            stix_observable_relations_mapping[
                relation_to_create[&#34;id&#34;]
            ] = stix_observable_relation_result[&#34;id&#34;]

    def export_entity(
        self, entity_type, entity_id, mode=&#34;simple&#34;, max_marking_definition=None
    ):
        max_marking_definition_entity = (
            self.opencti.marking_definition.read(id=max_marking_definition)
            if max_marking_definition is not None
            else None
        )
        bundle = {
            &#34;type&#34;: &#34;bundle&#34;,
            &#34;id&#34;: &#34;bundle--&#34; + str(uuid.uuid4()),
            &#34;objects&#34;: [],
        }
        # Map types
        if IdentityTypes.has_value(entity_type):
            entity_type = &#34;identity&#34;

        # Export
        exporter = {
            &#34;identity&#34;: self.opencti.identity.to_stix2,
            &#34;threat-actor&#34;: self.opencti.threat_actor.to_stix2,
            &#34;intrusion-set&#34;: self.opencti.intrusion_set.to_stix2,
            &#34;campaign&#34;: self.opencti.campaign.to_stix2,
            &#34;incident&#34;: self.opencti.incident.to_stix2,
            &#34;malware&#34;: self.opencti.malware.to_stix2,
            &#34;tool&#34;: self.opencti.tool.to_stix2,
            &#34;vulnerability&#34;: self.opencti.vulnerability.to_stix2,
            &#34;attack-pattern&#34;: self.opencti.attack_pattern.to_stix2,
            &#34;course-of-action&#34;: self.opencti.course_of_action.to_stix2,
            &#34;report&#34;: self.opencti.report.to_stix2,
            &#34;note&#34;: self.opencti.note.to_stix2,
            &#34;opinion&#34;: self.opencti.opinion.to_stix2,
            &#34;indicator&#34;: self.opencti.indicator.to_stix2,
        }
        do_export = exporter.get(
            entity_type, lambda **kwargs: self.unknown_type({&#34;type&#34;: entity_type})
        )
        objects = do_export(
            id=entity_id,
            mode=mode,
            max_marking_definition_entity=max_marking_definition_entity,
        )
        if objects is not None:
            bundle[&#34;objects&#34;].extend(objects)
        return bundle

    def export_list(
        self,
        entity_type,
        search=None,
        filters=None,
        order_by=None,
        order_mode=None,
        max_marking_definition=None,
    ):
        max_marking_definition_entity = (
            self.opencti.marking_definition.read(id=max_marking_definition)
            if max_marking_definition is not None
            else None
        )
        bundle = {
            &#34;type&#34;: &#34;bundle&#34;,
            &#34;id&#34;: &#34;bundle--&#34; + str(uuid.uuid4()),
            &#34;objects&#34;: [],
        }

        if IdentityTypes.has_value(entity_type):
            if filters is not None:
                filters.append({&#34;key&#34;: &#34;entity_type&#34;, &#34;values&#34;: [entity_type]})
            else:
                filters = [{&#34;key&#34;: &#34;entity_type&#34;, &#34;values&#34;: [entity_type]}]
            entity_type = &#34;identity&#34;

        # List
        lister = {
            &#34;identity&#34;: self.opencti.identity.list,
            &#34;threat-actor&#34;: self.opencti.threat_actor.list,
            &#34;intrusion-set&#34;: self.opencti.intrusion_set.list,
            &#34;campaign&#34;: self.opencti.campaign.list,
            &#34;incident&#34;: self.opencti.incident.list,
            &#34;malware&#34;: self.opencti.malware.list,
            &#34;tool&#34;: self.opencti.tool.list,
            &#34;vulnerability&#34;: self.opencti.vulnerability.list,
            &#34;attack-pattern&#34;: self.opencti.attack_pattern.list,
            &#34;course-of-action&#34;: self.opencti.course_of_action.list,
            &#34;report&#34;: self.opencti.report.list,
            &#34;note&#34;: self.opencti.note.list,
            &#34;opinion&#34;: self.opencti.opinion.list,
            &#34;indicator&#34;: self.opencti.indicator.list,
        }
        do_list = lister.get(
            entity_type, lambda **kwargs: self.unknown_type({&#34;type&#34;: entity_type})
        )
        entities_list = do_list(
            search=search,
            filters=filters,
            orderBy=order_by,
            orderMode=order_mode,
            getAll=True,
        )

        if entities_list is not None:
            # Export
            exporter = {
                &#34;identity&#34;: self.opencti.identity.to_stix2,
                &#34;threat-actor&#34;: self.opencti.threat_actor.to_stix2,
                &#34;intrusion-set&#34;: self.opencti.intrusion_set.to_stix2,
                &#34;campaign&#34;: self.opencti.campaign.to_stix2,
                &#34;incident&#34;: self.opencti.incident.to_stix2,
                &#34;malware&#34;: self.opencti.malware.to_stix2,
                &#34;tool&#34;: self.opencti.tool.to_stix2,
                &#34;vulnerability&#34;: self.opencti.vulnerability.to_stix2,
                &#34;attack-pattern&#34;: self.opencti.attack_pattern.to_stix2,
                &#34;course-of-action&#34;: self.opencti.course_of_action.to_stix2,
                &#34;report&#34;: self.opencti.report.to_stix2,
                &#34;note&#34;: self.opencti.note.to_stix2,
                &#34;opinion&#34;: self.opencti.opinion.to_stix2,
                &#34;indicator&#34;: self.opencti.indicator.to_stix2,
            }
            do_export = exporter.get(
                entity_type, lambda **kwargs: self.unknown_type({&#34;type&#34;: entity_type})
            )
            uuids = []
            for entity in entities_list:
                entity_bundle = do_export(
                    entity=entity,
                    max_marking_definition_entity=max_marking_definition_entity,
                )
                if entity_bundle is not None:
                    entity_bundle_filtered = self.filter_objects(uuids, entity_bundle)
                    for x in entity_bundle_filtered:
                        uuids.append(x[&#34;id&#34;])
                    bundle[&#34;objects&#34;] = bundle[&#34;objects&#34;] + entity_bundle_filtered

        return bundle

    def prepare_export(
        self, entity, stix_object, mode=&#34;simple&#34;, max_marking_definition_entity=None
    ):
        if (
            self.check_max_marking_definition(
                max_marking_definition_entity, entity[&#34;markingDefinitions&#34;]
            )
            is False
        ):
            self.opencti.log(
                &#34;info&#34;,
                &#34;Marking definitions of &#34;
                + stix_object[&#34;type&#34;]
                + &#39; &#34;&#39;
                + stix_object[&#34;name&#34;]
                + &#39;&#34; are less than max definition, not exporting.&#39;,
            )
            return []
        result = []
        objects_to_get = []
        relations_to_get = []
        if &#34;createdByRef&#34; in entity and entity[&#34;createdByRef&#34;] is not None:
            entity_created_by_ref = entity[&#34;createdByRef&#34;]
            if entity_created_by_ref[&#34;entity_type&#34;] == &#34;user&#34;:
                identity_class = &#34;individual&#34;
            elif entity_created_by_ref[&#34;entity_type&#34;] == &#34;sector&#34;:
                identity_class = &#34;class&#34;
            else:
                identity_class = entity_created_by_ref[&#34;entity_type&#34;]

            created_by_ref = dict()
            created_by_ref[&#34;id&#34;] = entity_created_by_ref[&#34;stix_id_key&#34;]
            created_by_ref[&#34;type&#34;] = &#34;identity&#34;
            created_by_ref[&#34;name&#34;] = entity_created_by_ref[&#34;name&#34;]
            created_by_ref[&#34;identity_class&#34;] = identity_class
            if self.opencti.not_empty(entity_created_by_ref[&#34;stix_label&#34;]):
                created_by_ref[&#34;labels&#34;] = entity_created_by_ref[&#34;stix_label&#34;]
            else:
                created_by_ref[&#34;labels&#34;] = [&#34;identity&#34;]
            created_by_ref[&#34;created&#34;] = self.format_date(
                entity_created_by_ref[&#34;created&#34;]
            )
            created_by_ref[&#34;modified&#34;] = self.format_date(
                entity_created_by_ref[&#34;modified&#34;]
            )
            if (
                entity_created_by_ref[&#34;entity_type&#34;] == &#34;organization&#34;
                and &#34;organization_class&#34; in entity_created_by_ref
            ):
                created_by_ref[CustomProperties.ORG_CLASS] = entity_created_by_ref[
                    &#34;organization_class&#34;
                ]
            if self.opencti.not_empty(entity_created_by_ref[&#34;alias&#34;]):
                created_by_ref[CustomProperties.ALIASES] = entity_created_by_ref[
                    &#34;alias&#34;
                ]
            created_by_ref[CustomProperties.IDENTITY_TYPE] = entity_created_by_ref[
                &#34;entity_type&#34;
            ]
            created_by_ref[CustomProperties.ID] = entity_created_by_ref[&#34;id&#34;]

            stix_object[&#34;created_by_ref&#34;] = created_by_ref[&#34;id&#34;]
            result.append(created_by_ref)
        if &#34;markingDefinitions&#34; in entity and len(entity[&#34;markingDefinitions&#34;]) &gt; 0:
            marking_definitions = []
            for entity_marking_definition in entity[&#34;markingDefinitions&#34;]:
                marking_definition = {
                    &#34;id&#34;: entity_marking_definition[&#34;stix_id_key&#34;],
                    &#34;type&#34;: &#34;marking-definition&#34;,
                    &#34;definition_type&#34;: entity_marking_definition[
                        &#34;definition_type&#34;
                    ].lower(),
                    &#34;definition&#34;: {
                        entity_marking_definition[
                            &#34;definition_type&#34;
                        ]: entity_marking_definition[&#34;definition&#34;]
                    },
                    &#34;created&#34;: entity_marking_definition[&#34;created&#34;],
                    CustomProperties.MODIFIED: entity_marking_definition[&#34;modified&#34;],
                    CustomProperties.ID: entity_marking_definition[&#34;id&#34;],
                }
                marking_definitions.append(marking_definition[&#34;id&#34;])
                result.append(marking_definition)
            stix_object[&#34;object_marking_refs&#34;] = marking_definitions
        if &#34;tags&#34; in entity and len(entity[&#34;tags&#34;]) &gt; 0:
            tags = []
            for entity_tag in entity[&#34;tags&#34;]:
                tag = dict()
                tag[&#34;id&#34;] = entity_tag[&#34;id&#34;]
                tag[&#34;tag_type&#34;] = entity_tag[&#34;tag_type&#34;]
                tag[&#34;value&#34;] = entity_tag[&#34;value&#34;]
                tag[&#34;color&#34;] = entity_tag[&#34;color&#34;]
                tags.append(tag)
            stix_object[CustomProperties.TAG_TYPE] = tags
        if &#34;killChainPhases&#34; in entity and len(entity[&#34;killChainPhases&#34;]) &gt; 0:
            kill_chain_phases = []
            for entity_kill_chain_phase in entity[&#34;killChainPhases&#34;]:
                kill_chain_phase = {
                    &#34;id&#34;: entity_kill_chain_phase[&#34;stix_id_key&#34;],
                    &#34;kill_chain_name&#34;: entity_kill_chain_phase[&#34;kill_chain_name&#34;],
                    &#34;phase_name&#34;: entity_kill_chain_phase[&#34;phase_name&#34;],
                    CustomProperties.ID: entity_kill_chain_phase[&#34;id&#34;],
                    CustomProperties.PHASE_ORDER: entity_kill_chain_phase[
                        &#34;phase_order&#34;
                    ],
                    CustomProperties.CREATED: entity_kill_chain_phase[&#34;created&#34;],
                    CustomProperties.MODIFIED: entity_kill_chain_phase[&#34;modified&#34;],
                }
                kill_chain_phases.append(kill_chain_phase)
            stix_object[&#34;kill_chain_phases&#34;] = kill_chain_phases
        if &#34;externalReferences&#34; in entity and len(entity[&#34;externalReferences&#34;]) &gt; 0:
            external_references = []
            for entity_external_reference in entity[&#34;externalReferences&#34;]:
                external_reference = dict()
                external_reference[&#34;id&#34;] = entity_external_reference[&#34;stix_id_key&#34;]
                if self.opencti.not_empty(entity_external_reference[&#34;source_name&#34;]):
                    external_reference[&#34;source_name&#34;] = entity_external_reference[
                        &#34;source_name&#34;
                    ]
                if self.opencti.not_empty(entity_external_reference[&#34;description&#34;]):
                    external_reference[&#34;description&#34;] = entity_external_reference[
                        &#34;description&#34;
                    ]
                if self.opencti.not_empty(entity_external_reference[&#34;url&#34;]):
                    external_reference[&#34;url&#34;] = entity_external_reference[&#34;url&#34;]
                if self.opencti.not_empty(entity_external_reference[&#34;hash&#34;]):
                    external_reference[&#34;hash&#34;] = entity_external_reference[&#34;hash&#34;]
                if self.opencti.not_empty(entity_external_reference[&#34;external_id&#34;]):
                    external_reference[&#34;external_id&#34;] = entity_external_reference[
                        &#34;external_id&#34;
                    ]
                external_reference[CustomProperties.ID] = entity_external_reference[
                    &#34;id&#34;
                ]
                external_reference[
                    CustomProperties.CREATED
                ] = entity_external_reference[&#34;created&#34;]
                external_reference[
                    CustomProperties.MODIFIED
                ] = entity_external_reference[&#34;modified&#34;]
                external_references.append(external_reference)
            stix_object[&#34;external_references&#34;] = external_references
        if &#34;objectRefs&#34; in entity and len(entity[&#34;objectRefs&#34;]) &gt; 0:
            object_refs = []
            objects_to_get = entity[&#34;objectRefs&#34;]
            for entity_object_ref in entity[&#34;objectRefs&#34;]:
                object_refs.append(entity_object_ref[&#34;stix_id_key&#34;])
            if &#34;relationRefs&#34; in entity and len(entity[&#34;relationRefs&#34;]) &gt; 0:
                relations_to_get = entity[&#34;relationRefs&#34;]
                for entity_relation_ref in entity[&#34;relationRefs&#34;]:
                    if entity_relation_ref[&#34;stix_id_key&#34;] not in object_refs:
                        object_refs.append(entity_relation_ref[&#34;stix_id_key&#34;])
            stix_object[&#34;object_refs&#34;] = object_refs

        uuids = []
        for x in result:
            uuids.append(x[&#34;id&#34;])

        observables_stix_ids = []
        observable_object_data = None
        if &#34;observableRefs&#34; in entity and len(entity[&#34;observableRefs&#34;]) &gt; 0:
            observable_object_data = self.export_stix_observables(entity)
            if observable_object_data is not None:
                observable_object_bundle = self.filter_objects(
                    uuids, [observable_object_data[&#34;observedData&#34;]]
                )
                uuids = uuids + [x[&#34;id&#34;] for x in observable_object_bundle]
                result = result + observable_object_bundle
                observables_stix_ids = (
                    observables_stix_ids + observable_object_data[&#34;stixIds&#34;]
                )
                if stix_object[&#34;type&#34;] == &#34;report&#34;:
                    if &#34;object_refs&#34; in stix_object:
                        stix_object[&#34;object_refs&#34;].append(
                            observable_object_data[&#34;observedData&#34;][&#34;id&#34;]
                        )
                    else:
                        stix_object[&#34;object_refs&#34;] = [
                            observable_object_data[&#34;observedData&#34;][&#34;id&#34;]
                        ]
        result.append(stix_object)

        if mode == &#34;simple&#34;:
            return result
        elif mode == &#34;full&#34;:
            # Get extra relations
            stix_relations = self.opencti.stix_relation.list(
                fromId=entity[&#34;id&#34;], forceNatural=True
            )
            for stix_relation in stix_relations:
                if self.check_max_marking_definition(
                    max_marking_definition_entity, stix_relation[&#34;markingDefinitions&#34;]
                ):
                    if stix_relation[&#34;to&#34;][&#34;id&#34;] == entity[&#34;id&#34;]:
                        other_side_entity = stix_relation[&#34;from&#34;]
                    else:
                        other_side_entity = stix_relation[&#34;to&#34;]
                    objects_to_get.append(other_side_entity)
                    if other_side_entity[&#34;stix_id_key&#34;] in observables_stix_ids:
                        other_side_entity[&#34;stix_id_key&#34;] = observable_object_data[
                            &#34;observedData&#34;
                        ][&#34;id&#34;]
                    relation_object_data = self.opencti.stix_relation.to_stix2(
                        entity=stix_relation
                    )
                    relation_object_bundle = self.filter_objects(
                        uuids, relation_object_data
                    )
                    uuids = uuids + [x[&#34;id&#34;] for x in relation_object_bundle]
                    result = result + relation_object_bundle
                else:
                    self.opencti.log(
                        &#34;info&#34;,
                        &#34;Marking definitions of &#34;
                        + stix_relation[&#34;entity_type&#34;]
                        + &#39; &#34;&#39;
                        + stix_relation[&#34;id&#34;]
                        + &#39;&#34; are less than max definition, not exporting the relation AND the target entity.&#39;,
                    )

            # Export
            exporter = {
                &#34;identity&#34;: self.opencti.identity.to_stix2,
                &#34;threat-actor&#34;: self.opencti.threat_actor.to_stix2,
                &#34;intrusion-set&#34;: self.opencti.intrusion_set.to_stix2,
                &#34;campaign&#34;: self.opencti.campaign.to_stix2,
                &#34;incident&#34;: self.opencti.incident.to_stix2,
                &#34;malware&#34;: self.opencti.malware.to_stix2,
                &#34;tool&#34;: self.opencti.tool.to_stix2,
                &#34;vulnerability&#34;: self.opencti.vulnerability.to_stix2,
                &#34;attack-pattern&#34;: self.opencti.attack_pattern.to_stix2,
                &#34;course-of-action&#34;: self.opencti.course_of_action.to_stix2,
                &#34;report&#34;: self.opencti.report.to_stix2,
                &#34;note&#34;: self.opencti.note.to_stix2,
                &#34;opinion&#34;: self.opencti.opinion.to_stix2,
                &#34;indicator&#34;: self.opencti.indicator.to_stix2,
            }

            # Get extra objects
            for entity_object in objects_to_get:
                # Map types
                if IdentityTypes.has_value(entity_object[&#34;entity_type&#34;]):
                    entity_object[&#34;entity_type&#34;] = &#34;identity&#34;
                do_export = exporter.get(
                    entity_object[&#34;entity_type&#34;],
                    lambda **kwargs: self.unknown_type(
                        {&#34;type&#34;: entity_object[&#34;entity_type&#34;]}
                    ),
                )
                entity_object_data = do_export(id=entity_object[&#34;id&#34;])
                # Add to result
                entity_object_bundle = self.filter_objects(uuids, entity_object_data)
                uuids = uuids + [x[&#34;id&#34;] for x in entity_object_bundle]
                result = result + entity_object_bundle
            for relation_object in relations_to_get:
                relation_object_data = self.opencti.stix_relation.to_stix2(
                    id=relation_object[&#34;id&#34;]
                )
                relation_object_bundle = self.filter_objects(
                    uuids, relation_object_data
                )
                uuids = uuids + [x[&#34;id&#34;] for x in relation_object_bundle]
                result = result + relation_object_bundle

            # Get extra reports
            &#34;&#34;&#34;
            for uuid in uuids:
                if &#34;marking-definition&#34; not in uuid:
                    reports = self.opencti.stix_entity.reports(id=uuid)
                    for report in reports:
                        report_object_data = self.opencti.report.to_stix2(
                            entity=report,
                            mode=&#34;simple&#34;,
                            max_marking_definition_entity=max_marking_definition_entity,
                        )
                        report_object_bundle = self.filter_objects(
                            uuids, report_object_data
                        )
                        uuids = uuids + [x[&#34;id&#34;] for x in report_object_bundle]
                        result = result + report_object_bundle
            &#34;&#34;&#34;

            # Refilter all the reports object refs
            final_result = []
            for entity in result:
                if entity[&#34;type&#34;] == &#34;report&#34;:
                    if &#34;object_refs&#34; in entity:
                        entity[&#34;object_refs&#34;] = [
                            k for k in entity[&#34;object_refs&#34;] if k in uuids
                        ]
                    final_result.append(entity)
                else:
                    final_result.append(entity)
            return final_result
        else:
            return []

    # TODO move in MarkingDefinition
    def create_marking_definition(self, stix_object, extras, update=False):
        definition_type = stix_object[&#34;definition_type&#34;]
        definition = stix_object[&#34;definition&#34;][stix_object[&#34;definition_type&#34;]]
        if stix_object[&#34;definition_type&#34;] == &#34;tlp&#34;:
            definition_type = &#34;TLP&#34;
            definition = (
                &#34;TLP:&#34;
                + stix_object[&#34;definition&#34;][stix_object[&#34;definition_type&#34;]].upper()
            )
        return self.opencti.marking_definition.create(
            definition_type=definition_type,
            definition=definition,
            level=stix_object[CustomProperties.LEVEL]
            if CustomProperties.LEVEL in stix_object
            else 0,
            color=stix_object[CustomProperties.COLOR]
            if CustomProperties.COLOR in stix_object
            else None,
            id=stix_object[CustomProperties.ID]
            if CustomProperties.ID in stix_object
            else None,
            stix_id_key=stix_object[&#34;id&#34;],
            created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
            modified=stix_object[CustomProperties.MODIFIED]
            if CustomProperties.MODIFIED in stix_object
            else None,
            createdByRef=extras[&#34;created_by_ref_id&#34;]
            if &#34;created_by_ref_id&#34; in extras
            else None,
        )

    # TODO move in Identity
    def create_identity(self, stix_object, extras, update=False):
        if CustomProperties.IDENTITY_TYPE in stix_object:
            type = stix_object[CustomProperties.IDENTITY_TYPE].capitalize()
        else:
            if stix_object[&#34;identity_class&#34;] == &#34;individual&#34;:
                type = &#34;User&#34;
            elif stix_object[&#34;identity_class&#34;] == &#34;organization&#34;:
                type = &#34;Organization&#34;
            elif stix_object[&#34;identity_class&#34;] == &#34;group&#34;:
                type = &#34;Organization&#34;
            elif stix_object[&#34;identity_class&#34;] == &#34;class&#34;:
                type = &#34;Sector&#34;
            else:
                return None
        return self.opencti.identity.create(
            type=type,
            name=stix_object[&#34;name&#34;],
            description=self.convert_markdown(stix_object[&#34;description&#34;])
            if &#34;description&#34; in stix_object
            else &#34;&#34;,
            alias=self.pick_aliases(stix_object),
            id=stix_object[CustomProperties.ID]
            if CustomProperties.ID in stix_object
            else None,
            stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
            created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
            modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
            createdByRef=extras[&#34;created_by_ref_id&#34;]
            if &#34;created_by_ref_id&#34; in extras
            else None,
            markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
            if &#34;marking_definitions_ids&#34; in extras
            else [],
            update=update,
        )

    # TODO move in ThreatActor
    def create_threat_actor(self, stix_object, extras, update=False):
        return self.opencti.threat_actor.create(
            name=stix_object[&#34;name&#34;],
            description=self.convert_markdown(stix_object[&#34;description&#34;])
            if &#34;description&#34; in stix_object
            else &#34;&#34;,
            alias=self.pick_aliases(stix_object),
            goal=stix_object[&#34;goals&#34;] if &#34;goals&#34; in stix_object else None,
            sophistication=stix_object[&#34;sophistication&#34;]
            if &#34;sophistication&#34; in stix_object
            else None,
            resource_level=stix_object[&#34;resource_level&#34;]
            if &#34;resource_level&#34; in stix_object
            else None,
            primary_motivaton=stix_object[&#34;primary_motivation&#34;]
            if &#34;primary_motivation&#34; in stix_object
            else None,
            secondary_motivation=stix_object[&#34;secondary_motivations&#34;]
            if &#34;secondary_motivations&#34; in stix_object
            else None,
            personal_motivation=stix_object[&#34;personal_motivations&#34;]
            if &#34;personal_motivations&#34; in stix_object
            else None,
            id=stix_object[CustomProperties.ID]
            if CustomProperties.ID in stix_object
            else None,
            stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
            created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
            modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
            createdByRef=extras[&#34;created_by_ref_id&#34;]
            if &#34;created_by_ref_id&#34; in extras
            else None,
            markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
            if &#34;marking_definitions_ids&#34; in extras
            else [],
            update=update,
        )

    # TODO move in IntrusionSet
    def create_intrusion_set(self, stix_object, extras, update=False):
        return self.opencti.intrusion_set.create(
            name=stix_object[&#34;name&#34;],
            description=self.convert_markdown(stix_object[&#34;description&#34;])
            if &#34;description&#34; in stix_object
            else &#34;&#34;,
            alias=self.pick_aliases(stix_object),
            first_seen=stix_object[CustomProperties.FIRST_SEEN]
            if CustomProperties.FIRST_SEEN in stix_object
            else None,
            last_seen=stix_object[CustomProperties.LAST_SEEN]
            if CustomProperties.LAST_SEEN in stix_object
            else None,
            goal=stix_object[&#34;goals&#34;] if &#34;goals&#34; in stix_object else None,
            sophistication=stix_object[&#34;sophistication&#34;]
            if &#34;sophistication&#34; in stix_object
            else None,
            resource_level=stix_object[&#34;resource_level&#34;]
            if &#34;resource_level&#34; in stix_object
            else None,
            primary_motivation=stix_object[&#34;primary_motivation&#34;]
            if &#34;primary_motivation&#34; in stix_object
            else None,
            secondary_motivation=stix_object[&#34;secondary_motivations&#34;]
            if &#34;secondary_motivations&#34; in stix_object
            else None,
            id=stix_object[CustomProperties.ID]
            if CustomProperties.ID in stix_object
            else None,
            stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
            created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
            modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
            createdByRef=extras[&#34;created_by_ref_id&#34;]
            if &#34;created_by_ref_id&#34; in extras
            else None,
            markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
            if &#34;marking_definitions_ids&#34; in extras
            else [],
            update=update,
        )

    # TODO move in Campaign
    def create_campaign(self, stix_object, extras, update=False):
        return self.opencti.campaign.create(
            name=stix_object[&#34;name&#34;],
            description=self.convert_markdown(stix_object[&#34;description&#34;])
            if &#34;description&#34; in stix_object
            else &#34;&#34;,
            alias=self.pick_aliases(stix_object),
            objective=stix_object[&#34;objective&#34;] if &#34;objective&#34; in stix_object else None,
            first_seen=stix_object[CustomProperties.FIRST_SEEN]
            if CustomProperties.FIRST_SEEN in stix_object
            else None,
            last_seen=stix_object[CustomProperties.LAST_SEEN]
            if CustomProperties.LAST_SEEN in stix_object
            else None,
            id=stix_object[CustomProperties.ID]
            if CustomProperties.ID in stix_object
            else None,
            stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
            created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
            modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
            createdByRef=extras[&#34;created_by_ref_id&#34;]
            if &#34;created_by_ref_id&#34; in extras
            else None,
            markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
            if &#34;marking_definitions_ids&#34; in extras
            else [],
            uodate=update,
        )

    # TODO move in Incident
    def create_incident(self, stix_object, extras, update=False):
        return self.opencti.incident.create(
            name=stix_object[&#34;name&#34;],
            description=self.convert_markdown(stix_object[&#34;description&#34;])
            if &#34;description&#34; in stix_object
            else &#34;&#34;,
            alias=self.pick_aliases(stix_object),
            objective=stix_object[&#34;objective&#34;] if &#34;objective&#34; in stix_object else None,
            first_seen=stix_object[&#34;first_seen&#34;]
            if &#34;first_seen&#34; in stix_object
            else None,
            last_seen=stix_object[&#34;last_seen&#34;] if &#34;last_seen&#34; in stix_object else None,
            id=stix_object[CustomProperties.ID]
            if CustomProperties.ID in stix_object
            else None,
            stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
            created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
            modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
            createdByRef=extras[&#34;created_by_ref_id&#34;]
            if &#34;created_by_ref_id&#34; in extras
            else None,
            markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
            if &#34;marking_definitions_ids&#34; in extras
            else [],
            update=update,
        )

    # TODO move in Malware
    def create_malware(self, stix_object, extras, update=False):
        return self.opencti.malware.create(
            name=stix_object[&#34;name&#34;],
            description=self.convert_markdown(stix_object[&#34;description&#34;])
            if &#34;description&#34; in stix_object
            else &#34;&#34;,
            alias=self.pick_aliases(stix_object),
            id=stix_object[CustomProperties.ID]
            if CustomProperties.ID in stix_object
            else None,
            stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
            created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
            modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
            createdByRef=extras[&#34;created_by_ref_id&#34;]
            if &#34;created_by_ref_id&#34; in extras
            else None,
            markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
            if &#34;marking_definitions_ids&#34; in extras
            else [],
            killChainPhases=extras[&#34;kill_chain_phases_ids&#34;]
            if &#34;kill_chain_phases_ids&#34; in extras
            else [],
            update=update,
        )

    # TODO move in Tool
    def create_tool(self, stix_object, extras, update=False):
        return self.opencti.tool.create(
            name=stix_object[&#34;name&#34;],
            description=self.convert_markdown(stix_object[&#34;description&#34;])
            if &#34;description&#34; in stix_object
            else &#34;&#34;,
            alias=self.pick_aliases(stix_object),
            id=stix_object[CustomProperties.ID]
            if CustomProperties.ID in stix_object
            else None,
            stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
            created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
            modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
            createdByRef=extras[&#34;created_by_ref_id&#34;]
            if &#34;created_by_ref_id&#34; in extras
            else None,
            markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
            if &#34;marking_definitions_ids&#34; in extras
            else [],
            killChainPhases=extras[&#34;kill_chain_phases_ids&#34;]
            if &#34;kill_chain_phases_ids&#34; in extras
            else [],
            update=update,
        )

    # TODO move in Vulnerability
    def create_vulnerability(self, stix_object, extras, update=False):
        return self.opencti.vulnerability.create(
            name=stix_object[&#34;name&#34;],
            description=self.convert_markdown(stix_object[&#34;description&#34;])
            if &#34;description&#34; in stix_object
            else &#34;&#34;,
            base_score=stix_object[CustomProperties.BASE_SCORE]
            if CustomProperties.BASE_SCORE in stix_object
            else None,
            base_severity=stix_object[CustomProperties.BASE_SEVERITY]
            if CustomProperties.BASE_SEVERITY in stix_object
            else None,
            attack_vector=stix_object[CustomProperties.ATTACK_VECTOR]
            if CustomProperties.ATTACK_VECTOR in stix_object
            else None,
            integrity_impact=stix_object[CustomProperties.INTEGRITY_IMPACT]
            if CustomProperties.INTEGRITY_IMPACT in stix_object
            else None,
            availability_impact=stix_object[CustomProperties.AVAILABILITY_IMPACT]
            if CustomProperties.AVAILABILITY_IMPACT in stix_object
            else None,
            alias=self.pick_aliases(stix_object),
            id=stix_object[CustomProperties.ID]
            if CustomProperties.ID in stix_object
            else None,
            stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
            created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
            modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
            createdByRef=extras[&#34;created_by_ref_id&#34;]
            if &#34;created_by_ref_id&#34; in extras
            else None,
            markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
            if &#34;marking_definitions_ids&#34; in extras
            else [],
            update=update,
        )

    def create_attack_pattern(self, stix_object, extras, update=False):
        return self.opencti.attack_pattern.import_from_stix2(
            stixObject=stix_object, extras=extras, update=update
        )

    # TODO move in Course Of Action
    def create_course_of_action(self, stix_object, extras, update=False):
        return self.opencti.course_of_action.create(
            name=stix_object[&#34;name&#34;],
            description=self.convert_markdown(stix_object[&#34;description&#34;])
            if &#34;description&#34; in stix_object
            else &#34;&#34;,
            alias=self.pick_aliases(stix_object),
            id=stix_object[CustomProperties.ID]
            if CustomProperties.ID in stix_object
            else None,
            stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
            created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
            modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
            createdByRef=extras[&#34;created_by_ref_id&#34;]
            if &#34;created_by_ref_id&#34; in extras
            else None,
            markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
            if &#34;marking_definitions_ids&#34; in extras
            else [],
            update=update,
        )

    def create_report(self, stix_object, extras, update=False):
        return self.opencti.report.import_from_stix2(
            stixObject=stix_object, extras=extras, update=update
        )

    def create_note(self, stix_object, extras, update=False):
        return self.opencti.note.import_from_stix2(
            stixObject=stix_object, extras=extras, update=update
        )

    def create_opinion(self, stix_object, extras, update=False):
        return self.opencti.opinion.import_from_stix2(
            stixObject=stix_object, extras=extras, update=update
        )

    def export_stix_observables(self, entity):
        stix_ids = []
        observed_data = dict()
        observed_data[&#34;id&#34;] = &#34;observed-data--&#34; + str(uuid.uuid4())
        observed_data[&#34;type&#34;] = &#34;observed-data&#34;
        observed_data[&#34;number_observed&#34;] = len(entity[&#34;observableRefs&#34;])
        observed_data[&#34;objects&#34;] = []
        for observable in entity[&#34;observableRefs&#34;]:
            stix_observable = dict()
            stix_observable[CustomProperties.OBSERVABLE_TYPE] = observable[
                &#34;entity_type&#34;
            ]
            stix_observable[CustomProperties.OBSERVABLE_VALUE] = observable[
                &#34;observable_value&#34;
            ]
            stix_observable[&#34;type&#34;] = observable[&#34;entity_type&#34;]
            observed_data[&#34;objects&#34;].append(stix_observable)
            stix_ids.append(observable[&#34;stix_id_key&#34;])

        return {&#34;observedData&#34;: observed_data, &#34;stixIds&#34;: stix_ids}

    def create_indicator(self, stix_object, extras, update=False):
        return self.opencti.indicator.create(
            name=stix_object[&#34;name&#34;],
            description=self.convert_markdown(stix_object[&#34;description&#34;])
            if &#34;description&#34; in stix_object
            else &#34;&#34;,
            indicator_pattern=stix_object[CustomProperties.INDICATOR_PATTERN]
            if CustomProperties.INDICATOR_PATTERN in stix_object
            else stix_object[&#34;pattern&#34;],
            main_observable_type=stix_object[CustomProperties.OBSERVABLE_TYPE]
            if CustomProperties.OBSERVABLE_TYPE in stix_object
            else &#34;Unknown&#34;,
            pattern_type=stix_object[CustomProperties.PATTERN_TYPE]
            if CustomProperties.PATTERN_TYPE in stix_object
            else &#34;stix&#34;,
            valid_from=stix_object[&#34;valid_from&#34;]
            if &#34;valid_from&#34; in stix_object
            else None,
            valid_until=stix_object[&#34;valid_until&#34;]
            if &#34;valid_until&#34; in stix_object
            else None,
            id=stix_object[CustomProperties.ID]
            if CustomProperties.ID in stix_object
            else None,
            stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
            created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
            modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
            createdByRef=extras[&#34;created_by_ref_id&#34;]
            if &#34;created_by_ref_id&#34; in extras
            else None,
            markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
            if &#34;marking_definitions_ids&#34; in extras
            else None,
            update=update,
        )

    def resolve_author(self, title):
        if &#34;fireeye&#34; in title.lower() or &#34;mandiant&#34; in title.lower():
            return self.get_author(&#34;FireEye&#34;)
        if &#34;eset&#34; in title.lower():
            return self.get_author(&#34;ESET&#34;)
        if &#34;dragos&#34; in title.lower():
            return self.get_author(&#34;Dragos&#34;)
        if &#34;us-cert&#34; in title.lower():
            return self.get_author(&#34;US-CERT&#34;)
        if (
            &#34;unit 42&#34; in title.lower()
            or &#34;unit42&#34; in title.lower()
            or &#34;palo alto&#34; in title.lower()
        ):
            return self.get_author(&#34;Palo Alto Networks&#34;)
        if &#34;accenture&#34; in title.lower():
            return self.get_author(&#34;Accenture&#34;)
        if &#34;symantec&#34; in title.lower():
            return self.get_author(&#34;Symantec&#34;)
        if &#34;trendmicro&#34; in title.lower() or &#34;trend micro&#34; in title.lower():
            return self.get_author(&#34;Trend Micro&#34;)
        if &#34;mcafee&#34; in title.lower():
            return self.get_author(&#34;McAfee&#34;)
        if &#34;crowdstrike&#34; in title.lower():
            return self.get_author(&#34;CrowdStrike&#34;)
        if &#34;securelist&#34; in title.lower() or &#34;kaspersky&#34; in title.lower():
            return self.get_author(&#34;Kaspersky&#34;)
        if &#34;f-secure&#34; in title.lower():
            return self.get_author(&#34;F-Secure&#34;)
        if &#34;checkpoint&#34; in title.lower():
            return self.get_author(&#34;CheckPoint&#34;)
        if &#34;talos&#34; in title.lower():
            return self.get_author(&#34;Cisco Talos&#34;)
        if &#34;secureworks&#34; in title.lower():
            return self.get_author(&#34;Dell SecureWorks&#34;)
        if &#34;microsoft&#34; in title.lower():
            return self.get_author(&#34;Microsoft&#34;)
        if &#34;mitre att&amp;ck&#34; in title.lower():
            return self.get_author(&#34;The MITRE Corporation&#34;)
        return None

    def get_author(self, name):
        if name in self.mapping_cache:
            return self.mapping_cache[name]
        else:
            author = self.opencti.identity.create(
                type=&#34;Organization&#34;, name=name, description=&#34;&#34;,
            )
            self.mapping_cache[name] = author
            return author

    def import_bundle(self, stix_bundle, update=False, types=None) -&gt; List:
        if types is None:
            types = []

        # Check if the bundle is correctly formatted
        if &#34;type&#34; not in stix_bundle or stix_bundle[&#34;type&#34;] != &#34;bundle&#34;:
            raise ValueError(&#34;JSON data type is not a STIX2 bundle&#34;)
        if &#34;objects&#34; not in stix_bundle or len(stix_bundle[&#34;objects&#34;]) == 0:
            raise ValueError(&#34;JSON data objects is empty&#34;)

        # Import every elements in a specific order
        imported_elements = []

        # Marking definitions
        start_time = time.time()
        for item in stix_bundle[&#34;objects&#34;]:
            if item[&#34;type&#34;] == &#34;marking-definition&#34;:
                self.import_object(item, update, types)
                imported_elements.append({&#34;id&#34;: item[&#34;id&#34;], &#34;type&#34;: item[&#34;type&#34;]})
        end_time = time.time()
        self.opencti.log(
            &#34;info&#34;,
            &#34;Marking definitions imported in: %ssecs&#34; % round(end_time - start_time),
        )

        # Identities
        start_time = time.time()
        for item in stix_bundle[&#34;objects&#34;]:
            if item[&#34;type&#34;] == &#34;identity&#34; and (
                len(types) == 0
                or &#34;identity&#34; in types
                or (
                    CustomProperties.IDENTITY_TYPE in item
                    and item[CustomProperties.IDENTITY_TYPE] in types
                )
            ):
                self.import_object(item, update, types)
                imported_elements.append({&#34;id&#34;: item[&#34;id&#34;], &#34;type&#34;: item[&#34;type&#34;]})
        end_time = time.time()
        self.opencti.log(
            &#34;info&#34;, &#34;Identities imported in: %ssecs&#34; % round(end_time - start_time)
        )

        # StixDomainObjects except Report/Opinion/Notes
        start_time = time.time()
        for item in stix_bundle[&#34;objects&#34;]:
            if (
                item[&#34;type&#34;] != &#34;relationship&#34;
                and item[&#34;type&#34;] != &#34;report&#34;
                and item[&#34;type&#34;] != &#34;note&#34;
                and item[&#34;type&#34;] != &#34;opinion&#34;
                and item[&#34;type&#34;] != &#34;observed-data&#34;
                and (len(types) == 0 or item[&#34;type&#34;] in types)
            ):
                self.import_object(item, update, types)
                imported_elements.append({&#34;id&#34;: item[&#34;id&#34;], &#34;type&#34;: item[&#34;type&#34;]})
        end_time = time.time()
        self.opencti.log(
            &#34;info&#34;, &#34;Objects imported in: %ssecs&#34; % round(end_time - start_time)
        )

        # StixCyberObservables
        start_time = time.time()
        for item in stix_bundle[&#34;objects&#34;]:
            if item[&#34;type&#34;] == &#34;observed-data&#34; and (
                len(types) == 0 or &#34;observed-data&#34; in types
            ):
                self.import_observables(item)
        end_time = time.time()
        self.opencti.log(
            &#34;info&#34;, &#34;Observables imported in: %ssecs&#34; % round(end_time - start_time)
        )

        # StixRelationObjects
        start_time = time.time()
        for item in stix_bundle[&#34;objects&#34;]:
            if item[&#34;type&#34;] == &#34;relationship&#34;:
                # Import only relationships between entities
                if (
                    CustomProperties.SOURCE_REF not in item
                    or &#34;relationship&#34; not in item[CustomProperties.SOURCE_REF]
                ) and (
                    CustomProperties.TARGET_REF not in item
                    or &#34;relationship&#34; not in item[CustomProperties.TARGET_REF]
                ):
                    source_ref = (
                        item[CustomProperties.SOURCE_REF]
                        if CustomProperties.SOURCE_REF in item
                        else item[&#34;source_ref&#34;]
                    )
                    target_ref = (
                        item[CustomProperties.TARGET_REF]
                        if CustomProperties.TARGET_REF in item
                        else item[&#34;target_ref&#34;]
                    )
                    if &#34;observed-data&#34; in source_ref:
                        if source_ref in self.mapping_cache:
                            for observable in self.mapping_cache[source_ref]:
                                item[CustomProperties.SOURCE_REF] = observable[&#34;id&#34;]
                                self.import_relationship(item, update, types)
                    elif &#34;observed-data&#34; in target_ref:
                        if target_ref in self.mapping_cache:
                            for observable in self.mapping_cache[target_ref]:
                                item[CustomProperties.TARGET_REF] = observable[&#34;id&#34;]
                                self.import_relationship(item, update, types)
                    else:
                        self.import_relationship(item, update, types)
                    imported_elements.append({&#34;id&#34;: item[&#34;id&#34;], &#34;type&#34;: item[&#34;type&#34;]})
        end_time = time.time()
        self.opencti.log(
            &#34;info&#34;, &#34;Relationships imported in: %ssecs&#34; % round(end_time - start_time)
        )

        # StixRelationObjects (with relationships)
        start_time = time.time()
        for item in stix_bundle[&#34;objects&#34;]:
            if item[&#34;type&#34;] == &#34;relationship&#34;:
                if (
                    CustomProperties.SOURCE_REF in item
                    and &#34;relationship&#34; in item[CustomProperties.SOURCE_REF]
                ) or (
                    CustomProperties.TARGET_REF in item
                    and &#34;relationship&#34; in item[CustomProperties.TARGET_REF]
                ):
                    self.import_relationship(item, update, types)
                    imported_elements.append({&#34;id&#34;: item[&#34;id&#34;], &#34;type&#34;: item[&#34;type&#34;]})
        end_time = time.time()
        self.opencti.log(
            &#34;info&#34;,
            &#34;Relationships to relationships imported in: %ssecs&#34;
            % round(end_time - start_time),
        )

        # Reports
        start_time = time.time()
        for item in stix_bundle[&#34;objects&#34;]:
            if item[&#34;type&#34;] == &#34;report&#34; and (len(types) == 0 or &#34;report&#34; in types):
                self.import_object(item, update, types)
                imported_elements.append({&#34;id&#34;: item[&#34;id&#34;], &#34;type&#34;: item[&#34;type&#34;]})
        end_time = time.time()
        self.opencti.log(
            &#34;info&#34;, &#34;Reports imported in: %ssecs&#34; % round(end_time - start_time)
        )

        # Notes
        start_time = time.time()
        for item in stix_bundle[&#34;objects&#34;]:
            if item[&#34;type&#34;] == &#34;note&#34; and (len(types) == 0 or &#34;note&#34; in types):
                self.import_object(item, update, types)
                imported_elements.append({&#34;id&#34;: item[&#34;id&#34;], &#34;type&#34;: item[&#34;type&#34;]})
        end_time = time.time()
        self.opencti.log(
            &#34;info&#34;, &#34;Notes imported in: %ssecs&#34; % round(end_time - start_time)
        )

        # Opinions
        start_time = time.time()
        for item in stix_bundle[&#34;objects&#34;]:
            if item[&#34;type&#34;] == &#34;opinion&#34; and (len(types) == 0 or &#34;opinion&#34; in types):
                self.import_object(item, update, types)
                imported_elements.append({&#34;id&#34;: item[&#34;id&#34;], &#34;type&#34;: item[&#34;type&#34;]})
        end_time = time.time()
        self.opencti.log(
            &#34;info&#34;, &#34;Opinions imported in: %ssecs&#34; % round(end_time - start_time)
        )
        return imported_elements</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pycti.utils.opencti_stix2.OpenCTIStix2"><code class="flex name class">
<span>class <span class="ident">OpenCTIStix2</span></span>
<span>(</span><span>opencti)</span>
</code></dt>
<dd>
<div class="desc"><p>Python API for Stix2 in OpenCTI
:param opencti: OpenCTI instance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OpenCTIStix2:
    &#34;&#34;&#34;
        Python API for Stix2 in OpenCTI
        :param opencti: OpenCTI instance
    &#34;&#34;&#34;

    def __init__(self, opencti):
        self.opencti = opencti
        self.mapping_cache = {}

    def unknown_type(self, stix_object):
        self.opencti.log(
            &#34;error&#34;,
            &#39;Unknown object type &#34;&#39; + stix_object[&#34;type&#34;] + &#39;&#34;, doing nothing...&#39;,
        )

    def convert_markdown(self, text):
        return text.replace(&#34;&lt;code&gt;&#34;, &#34;`&#34;).replace(&#34;&lt;/code&gt;&#34;, &#34;`&#34;)

    def format_date(self, date):
        if isinstance(date, datetime.date):
            return date.isoformat(timespec=&#34;milliseconds&#34;).replace(&#34;+00:00&#34;, &#34;Z&#34;)
        if date is not None:
            return (
                dateutil.parser.parse(date)
                .isoformat(timespec=&#34;milliseconds&#34;)
                .replace(&#34;+00:00&#34;, &#34;Z&#34;)
            )
        else:
            return (
                datetime.datetime.utcnow()
                .isoformat(timespec=&#34;milliseconds&#34;)
                .replace(&#34;+00:00&#34;, &#34;Z&#34;)
            )

    def filter_objects(self, uuids, objects):
        result = []
        if objects is not None:
            for object in objects:
                if &#34;id&#34; in object and object[&#34;id&#34;] not in uuids:
                    result.append(object)
        return result

    def pick_aliases(self, stix_object):
        # Add aliases
        if CustomProperties.ALIASES in stix_object:
            return stix_object[CustomProperties.ALIASES]
        elif &#34;x_mitre_aliases&#34; in stix_object:
            return stix_object[&#34;x_mitre_aliases&#34;]
        elif &#34;x_amitt_aliases&#34; in stix_object:
            return stix_object[&#34;x_amitt_aliases&#34;]
        elif &#34;aliases&#34; in stix_object:
            return stix_object[&#34;aliases&#34;]
        return None

    def check_max_marking_definition(
        self, max_marking_definition_entity, entity_marking_definitions
    ):
        # Max is not set, return True
        if max_marking_definition_entity is None:
            return True
        # Filter entity markings definition to the max_marking_definition type
        typed_entity_marking_definitions = []
        for entity_marking_definition in entity_marking_definitions:
            if (
                entity_marking_definition[&#34;definition_type&#34;]
                == max_marking_definition_entity[&#34;definition_type&#34;]
            ):
                typed_entity_marking_definitions.append(entity_marking_definition)
        # No entity marking defintions of the max_marking_definition type
        if len(typed_entity_marking_definitions) == 0:
            return True

        # Check if level is less or equal to max
        for typed_entity_marking_definition in typed_entity_marking_definitions:
            if (
                typed_entity_marking_definition[&#34;level&#34;]
                &lt;= max_marking_definition_entity[&#34;level&#34;]
            ):
                return True
        return False

    def import_bundle_from_file(self, file_path, update=False, types=None):
        if types is None:
            types = []
        if not os.path.isfile(file_path):
            self.opencti.log(&#34;error&#34;, &#34;The bundle file does not exists&#34;)
            return None

        with open(os.path.join(file_path)) as file:
            data = json.load(file)

        return self.import_bundle(data, update, types)

    def import_bundle_from_json(self, json_data, update=False, types=None) -&gt; List:
        if types is None:
            types = []
        data = json.loads(json_data)
        return self.import_bundle(data, update, types)

    def extract_embedded_relationships(self, stix_object, types=None):
        # Created By Ref
        created_by_ref_id = None
        if &#34;created_by_ref&#34; in stix_object:
            created_by_ref = stix_object[&#34;created_by_ref&#34;]
            if created_by_ref in self.mapping_cache:
                created_by_ref_result = self.mapping_cache[created_by_ref]
            else:
                created_by_ref_result = self.opencti.stix_domain_entity.read(
                    id=created_by_ref
                )
                if created_by_ref_result is not None:
                    self.mapping_cache[created_by_ref] = {
                        &#34;id&#34;: created_by_ref_result[&#34;id&#34;],
                        &#34;type&#34;: created_by_ref_result[&#34;entity_type&#34;],
                    }
            if created_by_ref_result is not None:
                created_by_ref_id = created_by_ref_result[&#34;id&#34;]

        # Object Marking Refs
        marking_definitions_ids = []
        if &#34;object_marking_refs&#34; in stix_object:
            for object_marking_ref in stix_object[&#34;object_marking_refs&#34;]:
                if object_marking_ref in self.mapping_cache:
                    object_marking_ref_result = self.mapping_cache[object_marking_ref]
                else:
                    object_marking_ref_result = self.opencti.marking_definition.read(
                        id=object_marking_ref
                    )
                    if object_marking_ref_result is not None:
                        self.mapping_cache[object_marking_ref] = {
                            &#34;id&#34;: object_marking_ref_result[&#34;id&#34;],
                            &#34;type&#34;: object_marking_ref_result[&#34;entity_type&#34;],
                        }
                if object_marking_ref_result is not None:
                    marking_definitions_ids.append(object_marking_ref_result[&#34;id&#34;])

        # Object Tags
        tags_ids = []
        if CustomProperties.TAG_TYPE in stix_object:
            for tag in stix_object[CustomProperties.TAG_TYPE]:
                tag_result = None
                if &#34;id&#34; in tag:
                    if tag[&#34;id&#34;] in self.mapping_cache:
                        tag_result = self.mapping_cache[tag[&#34;id&#34;]]
                    else:
                        tag_result = self.opencti.tag.read(id=tag[&#34;id&#34;])
                if tag_result is not None:
                    self.mapping_cache[tag[&#34;id&#34;]] = {&#34;id&#34;: tag_result[&#34;id&#34;]}
                else:
                    tag_result = self.opencti.tag.create(
                        tag_type=tag[&#34;tag_type&#34;],
                        value=tag[&#34;value&#34;],
                        color=tag[&#34;color&#34;],
                        id=tag[&#34;id&#34;] if &#34;id&#34; in tag else None,
                    )
                if tag_result is not None:
                    tags_ids.append(tag_result[&#34;id&#34;])

        # Kill Chain Phases
        kill_chain_phases_ids = []
        if &#34;kill_chain_phases&#34; in stix_object:
            for kill_chain_phase in stix_object[&#34;kill_chain_phases&#34;]:
                if kill_chain_phase[&#34;phase_name&#34;] in self.mapping_cache:
                    kill_chain_phase = self.mapping_cache[
                        kill_chain_phase[&#34;phase_name&#34;]
                    ]
                else:
                    kill_chain_phase = self.opencti.kill_chain_phase.create(
                        kill_chain_name=kill_chain_phase[&#34;kill_chain_name&#34;],
                        phase_name=kill_chain_phase[&#34;phase_name&#34;],
                        phase_order=kill_chain_phase[CustomProperties.PHASE_ORDER]
                        if CustomProperties.PHASE_ORDER in kill_chain_phase
                        else 0,
                        id=kill_chain_phase[CustomProperties.ID]
                        if CustomProperties.ID in kill_chain_phase
                        else None,
                        stix_id_key=kill_chain_phase[&#34;id&#34;]
                        if &#34;id&#34; in kill_chain_phase
                        else None,
                        created=kill_chain_phase[CustomProperties.CREATED]
                        if CustomProperties.CREATED in kill_chain_phase
                        else None,
                        modified=kill_chain_phase[CustomProperties.MODIFIED]
                        if CustomProperties.MODIFIED in kill_chain_phase
                        else None,
                    )
                    self.mapping_cache[kill_chain_phase[&#34;phase_name&#34;]] = {
                        &#34;id&#34;: kill_chain_phase[&#34;id&#34;],
                        &#34;type&#34;: kill_chain_phase[&#34;entity_type&#34;],
                    }
                kill_chain_phases_ids.append(kill_chain_phase[&#34;id&#34;])

        # Object refs
        object_refs_ids = []
        if &#34;object_refs&#34; in stix_object:
            for object_ref in stix_object[&#34;object_refs&#34;]:
                object_ref_result = None
                if object_ref in self.mapping_cache:
                    object_ref_result = self.mapping_cache[object_ref]
                elif &#34;relationship&#34; in object_ref:
                    object_ref_result = self.opencti.stix_relation.read(id=object_ref)
                    if object_ref_result is not None:
                        self.mapping_cache[object_ref] = {
                            &#34;id&#34;: object_ref_result[&#34;id&#34;],
                            &#34;type&#34;: object_ref_result[&#34;entity_type&#34;],
                        }
                elif &#34;observed-data&#34; not in object_ref:
                    object_ref_result = self.opencti.stix_entity.read(id=object_ref)
                    if object_ref_result is not None:
                        self.mapping_cache[object_ref] = {
                            &#34;id&#34;: object_ref_result[&#34;id&#34;],
                            &#34;type&#34;: object_ref_result[&#34;entity_type&#34;],
                        }
                if &#34;observed-data&#34; not in object_ref:
                    if object_ref_result is not None:
                        object_refs_ids.append(object_ref_result[&#34;id&#34;])
                else:
                    object_refs_ids.append(object_ref)

        # External References
        reports = {}
        external_references_ids = []
        if &#34;external_references&#34; in stix_object:
            for external_reference in stix_object[&#34;external_references&#34;]:
                if &#34;url&#34; in external_reference and &#34;source_name&#34; in external_reference:
                    url = external_reference[&#34;url&#34;]
                    source_name = external_reference[&#34;source_name&#34;]
                else:
                    continue
                if url in self.mapping_cache:
                    external_reference_id = self.mapping_cache[url][&#34;id&#34;]
                else:
                    external_reference_id = self.opencti.external_reference.create(
                        source_name=source_name,
                        url=url,
                        external_id=external_reference[&#34;external_id&#34;]
                        if &#34;external_id&#34; in external_reference
                        else None,
                        description=external_reference[&#34;description&#34;]
                        if &#34;description&#34; in external_reference
                        else None,
                        id=external_reference[CustomProperties.ID]
                        if CustomProperties.ID in external_reference
                        else None,
                        stix_id_key=external_reference[&#34;id&#34;]
                        if &#34;id&#34; in external_reference
                        else None,
                        created=external_reference[CustomProperties.CREATED]
                        if CustomProperties.CREATED in external_reference
                        else None,
                        modified=external_reference[CustomProperties.MODIFIED]
                        if CustomProperties.MODIFIED in external_reference
                        else None,
                    )[&#34;id&#34;]
                self.mapping_cache[url] = {&#34;id&#34;: external_reference_id}
                external_references_ids.append(external_reference_id)

                if stix_object[&#34;type&#34;] in [
                    &#34;threat-actor&#34;,
                    &#34;intrusion-set&#34;,
                    &#34;campaign&#34;,
                    &#34;incident&#34;,
                    &#34;malware&#34;,
                    &#34;relationship&#34;,
                ] and (types is None or &#34;report&#34; in types):
                    # Add a corresponding report
                    # Extract date
                    try:
                        if &#34;description&#34; in external_reference:
                            matches = datefinder.find_dates(
                                external_reference[&#34;description&#34;]
                            )
                        else:
                            matches = datefinder.find_dates(source_name)
                    except:
                        matches = None
                    published = None
                    today = datetime.datetime.today()
                    if matches is not None:
                        for match in matches:
                            if match &lt; today:
                                published = match.strftime(&#34;%Y-%m-%dT%H:%M:%SZ&#34;)
                    if published is None:
                        published = today.strftime(&#34;%Y-%m-%dT%H:%M:%SZ&#34;)

                    if &#34;mitre&#34; in source_name and &#34;name&#34; in stix_object:
                        title = &#34;[MITRE ATT&amp;CK] &#34; + stix_object[&#34;name&#34;]
                        if &#34;modified&#34; in stix_object:
                            published = stix_object[&#34;modified&#34;]
                    elif &#34;amitt&#34; in source_name and &#34;name&#34; in stix_object:
                        title = &#34;[AM!TT] &#34; + stix_object[&#34;name&#34;]
                        if &#34;modified&#34; in stix_object:
                            published = stix_object[&#34;modified&#34;]
                    else:
                        title = source_name

                    if &#34;external_id&#34; in external_reference:
                        title = title + &#34; (&#34; + external_reference[&#34;external_id&#34;] + &#34;)&#34;

                    author = self.resolve_author(title)
                    report = self.opencti.report.create(
                        name=title,
                        external_reference_id=external_reference_id,
                        description=external_reference[&#34;description&#34;]
                        if &#34;description&#34; in external_reference
                        else &#34;&#34;,
                        published=published,
                        report_class=&#34;Threat Report&#34;,
                        object_status=2,
                        createdByRef=author[&#34;id&#34;] if author is not None else None,
                        update=True,
                    )
                    # Add marking
                    if &#34;marking_tlpwhite&#34; in self.mapping_cache:
                        object_marking_ref_result = self.mapping_cache[
                            &#34;marking_tlpwhite&#34;
                        ]
                    else:
                        object_marking_ref_result = self.opencti.marking_definition.read(
                            filters=[
                                {&#34;key&#34;: &#34;definition_type&#34;, &#34;values&#34;: [&#34;TLP&#34;]},
                                {&#34;key&#34;: &#34;definition&#34;, &#34;values&#34;: [&#34;TLP:WHITE&#34;]},
                            ]
                        )
                    if object_marking_ref_result is not None:
                        self.mapping_cache[&#34;marking_tlpwhite&#34;] = {
                            &#34;id&#34;: object_marking_ref_result[&#34;id&#34;]
                        }
                        self.opencti.stix_entity.add_marking_definition(
                            id=report[&#34;id&#34;],
                            marking_definition_id=object_marking_ref_result[&#34;id&#34;],
                        )

                    # Add external reference to report
                    self.opencti.stix_entity.add_external_reference(
                        id=report[&#34;id&#34;], external_reference_id=external_reference_id,
                    )
                    reports[external_reference_id] = report

        return {
            &#34;created_by_ref&#34;: created_by_ref_id,
            &#34;marking_definitions&#34;: marking_definitions_ids,
            &#34;tags&#34;: tags_ids,
            &#34;kill_chain_phases&#34;: kill_chain_phases_ids,
            &#34;object_refs&#34;: object_refs_ids,
            &#34;external_references&#34;: external_references_ids,
            &#34;reports&#34;: reports,
        }

    def import_object(self, stix_object, update=False, types=None):
        self.opencti.log(
            &#34;info&#34;,
            &#34;Importing a &#34; + stix_object[&#34;type&#34;] + &#34; (id: &#34; + stix_object[&#34;id&#34;] + &#34;)&#34;,
        )

        # Extract
        embedded_relationships = self.extract_embedded_relationships(stix_object, types)
        created_by_ref_id = embedded_relationships[&#34;created_by_ref&#34;]
        marking_definitions_ids = embedded_relationships[&#34;marking_definitions&#34;]
        tags_ids = embedded_relationships[&#34;tags&#34;]
        kill_chain_phases_ids = embedded_relationships[&#34;kill_chain_phases&#34;]
        object_refs_ids = embedded_relationships[&#34;object_refs&#34;]
        external_references_ids = embedded_relationships[&#34;external_references&#34;]
        reports = embedded_relationships[&#34;reports&#34;]

        # Extra
        extras = {
            &#34;created_by_ref_id&#34;: created_by_ref_id,
            &#34;marking_definitions_ids&#34;: marking_definitions_ids,
            &#34;tags_ids&#34;: tags_ids,
            &#34;kill_chain_phases_ids&#34;: kill_chain_phases_ids,
            &#34;object_refs_ids&#34;: object_refs_ids,
            &#34;external_references_ids&#34;: external_references_ids,
            &#34;reports&#34;: reports,
        }

        # Import
        importer = {
            &#34;marking-definition&#34;: self.create_marking_definition,
            &#34;identity&#34;: self.create_identity,
            &#34;threat-actor&#34;: self.create_threat_actor,
            &#34;intrusion-set&#34;: self.create_intrusion_set,
            &#34;campaign&#34;: self.create_campaign,
            &#34;x-opencti-incident&#34;: self.create_incident,
            &#34;malware&#34;: self.create_malware,
            &#34;tool&#34;: self.create_tool,
            &#34;vulnerability&#34;: self.create_vulnerability,
            &#34;attack-pattern&#34;: self.create_attack_pattern,
            &#34;course-of-action&#34;: self.create_course_of_action,
            &#34;report&#34;: self.create_report,
            &#34;note&#34;: self.create_note,
            &#34;opinion&#34;: self.create_opinion,
            &#34;indicator&#34;: self.create_indicator,
        }
        do_import = importer.get(
            stix_object[&#34;type&#34;],
            lambda stix_object, extras, update: self.unknown_type(stix_object),
        )
        stix_object_results = do_import(stix_object, extras, update)

        if stix_object_results is None:
            return stix_object_results

        if not isinstance(stix_object_results, list):
            stix_object_results = [stix_object_results]

        for stix_object_result in stix_object_results:
            # Add embedded relationships
            self.mapping_cache[stix_object[&#34;id&#34;]] = {
                &#34;id&#34;: stix_object_result[&#34;id&#34;],
                &#34;type&#34;: stix_object_result[&#34;entity_type&#34;],
                &#34;observableRefs&#34;: stix_object_result[&#34;observableRefs&#34;]
                if &#34;observableRefs&#34; in stix_object_result
                else [],
            }
            self.mapping_cache[stix_object_result[&#34;id&#34;]] = {
                &#34;id&#34;: stix_object_result[&#34;id&#34;],
                &#34;type&#34;: stix_object_result[&#34;entity_type&#34;],
                &#34;observableRefs&#34;: stix_object_result[&#34;observableRefs&#34;]
                if &#34;observableRefs&#34; in stix_object_result
                else [],
            }

            # Add tags
            for tag_id in tags_ids:
                self.opencti.stix_entity.add_tag(
                    id=stix_object_result[&#34;id&#34;], tag_id=tag_id,
                )
            # Add external references
            for external_reference_id in external_references_ids:
                self.opencti.stix_entity.add_external_reference(
                    id=stix_object_result[&#34;id&#34;],
                    external_reference_id=external_reference_id,
                )
                if external_reference_id in reports:
                    self.opencti.report.add_stix_entity(
                        id=reports[external_reference_id][&#34;id&#34;],
                        entity_id=stix_object_result[&#34;id&#34;],
                    )
            # Add object refs
            for object_refs_id in object_refs_ids:
                if &#34;observed-data&#34; in object_refs_id:
                    if object_refs_id in self.mapping_cache:
                        for observable in self.mapping_cache[object_refs_id]:
                            if stix_object_result[&#34;entity_type&#34;] == &#34;report&#34;:
                                self.opencti.report.add_stix_observable(
                                    id=stix_object_result[&#34;id&#34;],
                                    stix_observable_id=observable[&#34;id&#34;],
                                )
                            elif stix_object_result[&#34;entity_type&#34;] == &#34;note&#34;:
                                self.opencti.note.add_stix_observable(
                                    id=stix_object_result[&#34;id&#34;],
                                    stix_observable_id=observable[&#34;id&#34;],
                                )
                            elif stix_object_result[&#34;entity_type&#34;] == &#34;opinion&#34;:
                                self.opencti.opinion.add_stix_observable(
                                    id=stix_object_result[&#34;id&#34;],
                                    stix_observable_id=observable[&#34;id&#34;],
                                )
                else:
                    if stix_object_result[&#34;entity_type&#34;] == &#34;report&#34;:
                        self.opencti.report.add_stix_entity(
                            id=stix_object_result[&#34;id&#34;], entity_id=object_refs_id,
                        )
                    elif stix_object_result[&#34;entity_type&#34;] == &#34;note&#34;:
                        self.opencti.note.add_stix_entity(
                            id=stix_object_result[&#34;id&#34;], entity_id=object_refs_id,
                        )
                    elif stix_object_result[&#34;entity_type&#34;] == &#34;opinion&#34;:
                        self.opencti.opinion.add_stix_entity(
                            id=stix_object_result[&#34;id&#34;], entity_id=object_refs_id,
                        )
                    if (
                        object_refs_id in self.mapping_cache
                        and &#34;observableRefs&#34; in self.mapping_cache[object_refs_id]
                        and self.mapping_cache[object_refs_id] is not None
                        and self.mapping_cache[object_refs_id][&#34;observableRefs&#34;]
                        is not None
                        and len(self.mapping_cache[object_refs_id][&#34;observableRefs&#34;])
                        &gt; 0
                    ):
                        for observable_ref in self.mapping_cache[object_refs_id][
                            &#34;observableRefs&#34;
                        ]:
                            if stix_object_result[&#34;entity_type&#34;] == &#34;report&#34;:
                                self.opencti.report.add_stix_observable(
                                    id=stix_object_result[&#34;id&#34;],
                                    stix_observable_id=observable_ref[&#34;id&#34;],
                                )
                            elif stix_object_result[&#34;entity_type&#34;] == &#34;note&#34;:
                                self.opencti.note.add_stix_observable(
                                    id=stix_object_result[&#34;id&#34;],
                                    stix_observable_id=observable_ref[&#34;id&#34;],
                                )
                            elif stix_object_result[&#34;entity_type&#34;] == &#34;opinion&#34;:
                                self.opencti.opinion.add_stix_observable(
                                    id=stix_object_result[&#34;id&#34;],
                                    stix_observable_id=observable_ref[&#34;id&#34;],
                                )
            # Add files
            if CustomProperties.FILES in stix_object:
                for file in stix_object[CustomProperties.FILES]:
                    self.opencti.stix_domain_entity.add_file(
                        id=stix_object_result[&#34;id&#34;],
                        file_name=file[&#34;name&#34;],
                        data=base64.b64decode(file[&#34;data&#34;]),
                        mime_type=file[&#34;mime_type&#34;],
                    )

        return stix_object_results

    def import_relationship(self, stix_relation, update=False, types=None):
        # Extract
        embedded_relationships = self.extract_embedded_relationships(
            stix_relation, types
        )
        created_by_ref_id = embedded_relationships[&#34;created_by_ref&#34;]
        marking_definitions_ids = embedded_relationships[&#34;marking_definitions&#34;]
        kill_chain_phases_ids = embedded_relationships[&#34;kill_chain_phases&#34;]
        external_references_ids = embedded_relationships[&#34;external_references&#34;]
        reports = embedded_relationships[&#34;reports&#34;]

        # Extra
        extras = {
            &#34;created_by_ref_id&#34;: created_by_ref_id,
            &#34;marking_definitions_ids&#34;: marking_definitions_ids,
            &#34;kill_chain_phases_ids&#34;: kill_chain_phases_ids,
            &#34;external_references_ids&#34;: external_references_ids,
            &#34;reports&#34;: reports,
        }

        # Create the relation

        ### Get the SOURCE_REF
        if CustomProperties.SOURCE_REF in stix_relation:
            source_ref = stix_relation[CustomProperties.SOURCE_REF]
        else:
            source_ref = stix_relation[&#34;source_ref&#34;]
        if source_ref in self.mapping_cache:
            if (
                StixObservableRelationTypes.has_value(
                    stix_relation[&#34;relationship_type&#34;]
                )
                and &#34;observableRefs&#34; in self.mapping_cache[source_ref]
                and self.mapping_cache[source_ref][&#34;observableRefs&#34;] is not None
                and len(self.mapping_cache[source_ref][&#34;observableRefs&#34;]) &gt; 0
            ):
                source_id = self.mapping_cache[source_ref][&#34;observableRefs&#34;][0][&#34;id&#34;]
                source_type = self.mapping_cache[source_ref][&#34;observableRefs&#34;][0][
                    &#34;entity_type&#34;
                ]
            else:
                source_id = self.mapping_cache[source_ref][&#34;id&#34;]
                source_type = self.mapping_cache[source_ref][&#34;type&#34;]
        else:
            stix_object_result = self.opencti.stix_entity.read(id=source_ref)
            if stix_object_result is not None:
                source_id = stix_object_result[&#34;id&#34;]
                source_type = stix_object_result[&#34;entity_type&#34;]
            else:
                self.opencti.log(
                    &#34;error&#34;,
                    &#34;Source ref of the relationship not found, doing nothing...&#34;,
                )
                return None

        ### Get the TARGET_REF
        if CustomProperties.TARGET_REF in stix_relation:
            target_ref = stix_relation[CustomProperties.TARGET_REF]
        else:
            target_ref = stix_relation[&#34;target_ref&#34;]
        if target_ref in self.mapping_cache:
            if (
                StixObservableRelationTypes.has_value(
                    stix_relation[&#34;relationship_type&#34;]
                )
                and &#34;observableRefs&#34; in self.mapping_cache[target_ref]
                and self.mapping_cache[target_ref][&#34;observableRefs&#34;] is not None
                and len(self.mapping_cache[target_ref][&#34;observableRefs&#34;]) &gt; 0
            ):
                target_id = self.mapping_cache[target_ref][&#34;observableRefs&#34;][0][&#34;id&#34;]
                target_type = self.mapping_cache[target_ref][&#34;observableRefs&#34;][0][
                    &#34;entity_type&#34;
                ]
            else:
                target_id = self.mapping_cache[target_ref][&#34;id&#34;]
                target_type = self.mapping_cache[target_ref][&#34;type&#34;]
        else:
            stix_object_result = self.opencti.stix_entity.read(id=target_ref)
            if stix_object_result is not None:
                target_id = stix_object_result[&#34;id&#34;]
                target_type = stix_object_result[&#34;entity_type&#34;]
            else:
                self.opencti.log(
                    &#34;error&#34;,
                    &#34;Target ref of the relationship not found, doing nothing...&#34;,
                )
                return None

        date = None
        if &#34;external_references&#34; in stix_relation:
            for external_reference in stix_relation[&#34;external_references&#34;]:
                try:
                    if &#34;description&#34; in external_reference:
                        matches = datefinder.find_dates(
                            external_reference[&#34;description&#34;]
                        )
                    else:
                        matches = datefinder.find_dates(
                            external_reference[&#34;source_name&#34;]
                        )
                except:
                    matches = None
                date = None
                today = datetime.datetime.today()
                if matches is not None:
                    for match in matches:
                        if match &lt; today:
                            date = match.strftime(&#34;%Y-%m-%dT%H:%M:%SZ&#34;)
        if date is None:
            date = datetime.datetime.today().strftime(&#34;%Y-%m-%dT%H:%M:%SZ&#34;)

        stix_relation_result = None
        if StixObservableRelationTypes.has_value(stix_relation[&#34;relationship_type&#34;]):
            stix_relation_result = self.opencti.stix_observable_relation.create(
                fromId=source_id,
                fromType=source_type,
                toId=target_id,
                toType=target_type,
                relationship_type=stix_relation[&#34;relationship_type&#34;],
                description=self.convert_markdown(stix_relation[&#34;description&#34;])
                if &#34;description&#34; in stix_relation
                else None,
                first_seen=stix_relation[CustomProperties.FIRST_SEEN]
                if CustomProperties.FIRST_SEEN in stix_relation
                else date,
                last_seen=stix_relation[CustomProperties.LAST_SEEN]
                if CustomProperties.LAST_SEEN in stix_relation
                else date,
                weight=stix_relation[CustomProperties.WEIGHT]
                if CustomProperties.WEIGHT in stix_relation
                else 1,
                role_played=stix_relation[CustomProperties.ROLE_PLAYED]
                if CustomProperties.ROLE_PLAYED in stix_relation
                else None,
                id=stix_relation[CustomProperties.ID]
                if CustomProperties.ID in stix_relation
                else None,
                stix_id_key=stix_relation[&#34;id&#34;] if &#34;id&#34; in stix_relation else None,
                created=stix_relation[&#34;created&#34;]
                if &#34;created&#34; in stix_relation
                else None,
                modified=stix_relation[&#34;modified&#34;]
                if &#34;modified&#34; in stix_relation
                else None,
                createdByRef=extras[&#34;created_by_ref_id&#34;]
                if &#34;created_by_ref_id&#34; in extras
                else None,
                markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
                if &#34;marking_definitions_ids&#34; in extras
                else [],
                killChainPhases=extras[&#34;kill_chain_phases_ids&#34;]
                if &#34;kill_chain_phases_ids&#34; in extras
                else [],
                update=update,
                ignore_dates=stix_relation[CustomProperties.IGNORE_DATES]
                if CustomProperties.IGNORE_DATES in stix_relation
                else None,
            )
        else:
            stix_relation_result = self.opencti.stix_relation.create(
                fromId=source_id,
                fromType=source_type,
                toId=target_id,
                toType=target_type,
                relationship_type=stix_relation[&#34;relationship_type&#34;],
                description=self.convert_markdown(stix_relation[&#34;description&#34;])
                if &#34;description&#34; in stix_relation
                else None,
                first_seen=stix_relation[CustomProperties.FIRST_SEEN]
                if CustomProperties.FIRST_SEEN in stix_relation
                else date,
                last_seen=stix_relation[CustomProperties.LAST_SEEN]
                if CustomProperties.LAST_SEEN in stix_relation
                else date,
                weight=stix_relation[CustomProperties.WEIGHT]
                if CustomProperties.WEIGHT in stix_relation
                else 1,
                role_played=stix_relation[CustomProperties.ROLE_PLAYED]
                if CustomProperties.ROLE_PLAYED in stix_relation
                else None,
                id=stix_relation[CustomProperties.ID]
                if CustomProperties.ID in stix_relation
                else None,
                stix_id_key=stix_relation[&#34;id&#34;] if &#34;id&#34; in stix_relation else None,
                created=stix_relation[&#34;created&#34;]
                if &#34;created&#34; in stix_relation
                else None,
                modified=stix_relation[&#34;modified&#34;]
                if &#34;modified&#34; in stix_relation
                else None,
                createdByRef=extras[&#34;created_by_ref_id&#34;]
                if &#34;created_by_ref_id&#34; in extras
                else None,
                markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
                if &#34;marking_definitions_ids&#34; in extras
                else [],
                killChainPhases=extras[&#34;kill_chain_phases_ids&#34;]
                if &#34;kill_chain_phases_ids&#34; in extras
                else [],
                update=update,
                ignore_dates=stix_relation[CustomProperties.IGNORE_DATES]
                if CustomProperties.IGNORE_DATES in stix_relation
                else None,
            )
        if stix_relation_result is not None:
            self.mapping_cache[stix_relation[&#34;id&#34;]] = {
                &#34;id&#34;: stix_relation_result[&#34;id&#34;],
                &#34;type&#34;: stix_relation_result[&#34;entity_type&#34;],
            }
        else:
            return None

        # Add external references
        for external_reference_id in external_references_ids:
            self.opencti.stix_entity.add_external_reference(
                id=stix_relation_result[&#34;id&#34;],
                external_reference_id=external_reference_id,
            )
            if external_reference_id in reports:
                self.opencti.report.add_stix_entity(
                    id=reports[external_reference_id][&#34;id&#34;],
                    entity_id=stix_relation_result[&#34;id&#34;],
                )
                self.opencti.report.add_stix_entity(
                    id=reports[external_reference_id][&#34;id&#34;], entity_id=source_id,
                )
                self.opencti.report.add_stix_entity(
                    id=reports[external_reference_id][&#34;id&#34;], entity_id=target_id,
                )

    def import_observables(self, stix_object):
        # Extract
        embedded_relationships = self.extract_embedded_relationships(stix_object)
        created_by_ref_id = embedded_relationships[&#34;created_by_ref&#34;]
        marking_definitions_ids = embedded_relationships[&#34;marking_definitions&#34;]

        observables_to_create = {}
        relations_to_create = []
        for key, observable_item in stix_object[&#34;objects&#34;].items():
            # TODO artifact
            if (
                CustomProperties.OBSERVABLE_TYPE in observable_item
                and CustomProperties.OBSERVABLE_VALUE in observable_item
            ):
                observables_to_create[key] = [
                    {
                        &#34;id&#34;: str(uuid.uuid4()),
                        &#34;stix_id&#34;: &#34;observable--&#34; + str(uuid.uuid4()),
                        &#34;type&#34;: observable_item[CustomProperties.OBSERVABLE_TYPE],
                        &#34;value&#34;: observable_item[CustomProperties.OBSERVABLE_VALUE],
                    }
                ]
            elif observable_item[&#34;type&#34;] == &#34;autonomous-system&#34;:
                observables_to_create[key] = [
                    {
                        &#34;id&#34;: str(uuid.uuid4()),
                        &#34;stix_id&#34;: &#34;observable--&#34; + str(uuid.uuid4()),
                        &#34;type&#34;: ObservableTypes.AUTONOMOUS_SYSTEM.value,
                        &#34;value&#34;: &#34;AS&#34; + observable_item[&#34;number&#34;],
                    }
                ]
            elif observable_item[&#34;type&#34;] == &#34;directory&#34;:
                observables_to_create[key] = [
                    {
                        &#34;id&#34;: str(uuid.uuid4()),
                        &#34;stix_id&#34;: &#34;observable--&#34; + str(uuid.uuid4()),
                        &#34;type&#34;: ObservableTypes.DIRECTORY.value,
                        &#34;value&#34;: observable_item[&#34;path&#34;],
                    }
                ]
            elif observable_item[&#34;type&#34;] == &#34;domain-name&#34;:
                observables_to_create[key] = [
                    {
                        &#34;id&#34;: str(uuid.uuid4()),
                        &#34;stix_id&#34;: &#34;observable--&#34; + str(uuid.uuid4()),
                        &#34;type&#34;: ObservableTypes.DOMAIN.value,
                        &#34;value&#34;: observable_item[&#34;value&#34;],
                    }
                ]
            elif observable_item[&#34;type&#34;] == &#34;email-addr&#34;:
                observables_to_create[key] = [
                    {
                        &#34;id&#34;: str(uuid.uuid4()),
                        &#34;stix_id&#34;: &#34;observable--&#34; + str(uuid.uuid4()),
                        &#34;type&#34;: ObservableTypes.EMAIL_ADDR.value,
                        &#34;value&#34;: observable_item[&#34;value&#34;],
                    }
                ]
                # TODO Belongs to ref
            # TODO email-message
            # TODO mime-part-type
            elif observable_item[&#34;type&#34;] == &#34;file&#34;:
                observables_to_create[key] = []
                if &#34;name&#34; in observable_item:
                    observables_to_create[key].append(
                        {
                            &#34;id&#34;: str(uuid.uuid4()),
                            &#34;type&#34;: ObservableTypes.FILE_NAME.value,
                            &#34;value&#34;: observable_item[&#34;name&#34;],
                        }
                    )
                if &#34;hashes&#34; in observable_item:
                    for keyfile, value in observable_item[&#34;hashes&#34;].items():
                        if keyfile == &#34;MD5&#34;:
                            observables_to_create[key].append(
                                {
                                    &#34;id&#34;: str(uuid.uuid4()),
                                    &#34;type&#34;: ObservableTypes.FILE_HASH_MD5.value,
                                    &#34;value&#34;: value,
                                }
                            )
                        if keyfile == &#34;SHA-1&#34;:
                            observables_to_create[key].append(
                                {
                                    &#34;id&#34;: str(uuid.uuid4()),
                                    &#34;type&#34;: ObservableTypes.FILE_HASH_SHA1.value,
                                    &#34;value&#34;: value,
                                }
                            )
                        if keyfile == &#34;SHA-256&#34;:
                            observables_to_create[key].append(
                                {
                                    &#34;id&#34;: str(uuid.uuid4()),
                                    &#34;type&#34;: ObservableTypes.FILE_HASH_SHA256.value,
                                    &#34;value&#34;: value,
                                }
                            )
            elif observable_item[&#34;type&#34;] == &#34;ipv4-addr&#34;:
                observables_to_create[key] = [
                    {
                        &#34;id&#34;: str(uuid.uuid4()),
                        &#34;type&#34;: ObservableTypes.IPV4_ADDR.value,
                        &#34;value&#34;: observable_item[&#34;value&#34;],
                    }
                ]
            elif observable_item[&#34;type&#34;] == &#34;ipv6-addr&#34;:
                observables_to_create[key] = [
                    {
                        &#34;id&#34;: str(uuid.uuid4()),
                        &#34;type&#34;: ObservableTypes.IPV6_ADDR.value,
                        &#34;value&#34;: observable_item[&#34;value&#34;],
                    }
                ]
            elif observable_item[&#34;type&#34;] == &#34;mac-addr&#34;:
                observables_to_create[key] = [
                    {
                        &#34;id&#34;: str(uuid.uuid4()),
                        &#34;type&#34;: ObservableTypes.MAC_ADDR.value,
                        &#34;value&#34;: observable_item[&#34;value&#34;],
                    }
                ]
            elif observable_item[&#34;type&#34;] == &#34;windows-registry-key&#34;:
                observables_to_create[key] = [
                    {
                        &#34;id&#34;: str(uuid.uuid4()),
                        &#34;type&#34;: ObservableTypes.REGISTRY_KEY.value,
                        &#34;value&#34;: observable_item[&#34;key&#34;],
                    }
                ]

        for key, observable_item in stix_object[&#34;objects&#34;].items():
            if observable_item[&#34;type&#34;] == &#34;directory&#34;:
                if &#34;contains_refs&#34; in observable_item:
                    for file in observable_item[&#34;contains_refs&#34;]:
                        for observable_to_create_from in observables_to_create[key]:
                            for observables_to_create_to in observables_to_create[file]:
                                if (
                                    observable_to_create_from[&#34;id&#34;]
                                    != observables_to_create_to[&#34;id&#34;]
                                ):
                                    relations_to_create.append(
                                        {
                                            &#34;id&#34;: str(uuid.uuid4()),
                                            &#34;from&#34;: observable_to_create_from[&#34;id&#34;],
                                            &#34;to&#34;: observables_to_create_to[&#34;id&#34;],
                                            &#34;type&#34;: &#34;contains&#34;,
                                        }
                                    )
            if observable_item[&#34;type&#34;] == &#34;domain-name&#34;:
                if &#34;resolves_to_refs&#34; in observable_item:
                    for resolved in observable_item[&#34;resolves_to_refs&#34;]:
                        for observable_to_create_from in observables_to_create[key]:
                            for observables_to_create_to in observables_to_create[
                                resolved
                            ]:
                                if (
                                    observable_to_create_from[&#34;id&#34;]
                                    != observables_to_create_to[&#34;id&#34;]
                                ):
                                    relations_to_create.append(
                                        {
                                            &#34;id&#34;: str(uuid.uuid4()),
                                            &#34;from&#34;: observable_to_create_from[&#34;id&#34;],
                                            &#34;fromType&#34;: observable_to_create_from[
                                                &#34;type&#34;
                                            ],
                                            &#34;to&#34;: observables_to_create_to[&#34;id&#34;],
                                            &#34;toType&#34;: observables_to_create_to[&#34;type&#34;],
                                            &#34;type&#34;: &#34;resolves&#34;,
                                        }
                                    )
            if observable_item[&#34;type&#34;] == &#34;file&#34;:
                for observable_to_create_from in observables_to_create[key]:
                    for observables_to_create_to in observables_to_create[key]:
                        if (
                            observable_to_create_from[&#34;id&#34;]
                            != observables_to_create_to[&#34;id&#34;]
                        ):
                            relations_to_create.append(
                                {
                                    &#34;id&#34;: str(uuid.uuid4()),
                                    &#34;from&#34;: observable_to_create_from[&#34;id&#34;],
                                    &#34;fromType&#34;: observable_to_create_from[&#34;type&#34;],
                                    &#34;to&#34;: observables_to_create_to[&#34;id&#34;],
                                    &#34;toType&#34;: observables_to_create_to[&#34;type&#34;],
                                    &#34;type&#34;: &#34;corresponds&#34;,
                                }
                            )
            if observable_item[&#34;type&#34;] == &#34;ipv4-addr&#34;:
                if &#34;belongs_to_refs&#34; in observable_item:
                    for belonging in observable_item[&#34;belongs_to_refs&#34;]:
                        for observable_to_create_from in observables_to_create[key]:
                            for observables_to_create_to in observables_to_create[
                                belonging
                            ]:
                                if (
                                    observable_to_create_from[&#34;id&#34;]
                                    != observables_to_create_to[&#34;id&#34;]
                                ):
                                    relations_to_create.append(
                                        {
                                            &#34;id&#34;: str(uuid.uuid4()),
                                            &#34;from&#34;: observable_to_create_from[&#34;id&#34;],
                                            &#34;fromType&#34;: observable_to_create_from[
                                                &#34;type&#34;
                                            ],
                                            &#34;to&#34;: observables_to_create_to[&#34;id&#34;],
                                            &#34;toType&#34;: observables_to_create_to[&#34;type&#34;],
                                            &#34;type&#34;: &#34;belongs&#34;,
                                        }
                                    )

        stix_observables_mapping = {}
        self.mapping_cache[stix_object[&#34;id&#34;]] = []
        for key, observable_to_create in observables_to_create.items():
            for observable in observable_to_create:
                observable_result = self.opencti.stix_observable.create(
                    type=observable[&#34;type&#34;],
                    observable_value=observable[&#34;value&#34;],
                    id=observable[&#34;id&#34;],
                    createdByRef=created_by_ref_id,
                    markingDefinitions=marking_definitions_ids,
                    createIndicator=stix_object[CustomProperties.CREATE_INDICATOR]
                    if CustomProperties.CREATE_INDICATOR in stix_object
                    else False,
                )
                stix_observables_mapping[observable[&#34;id&#34;]] = observable_result[&#34;id&#34;]
                self.mapping_cache[stix_object[&#34;id&#34;]].append(
                    {
                        &#34;id&#34;: observable_result[&#34;id&#34;],
                        &#34;type&#34;: observable_result[&#34;entity_type&#34;],
                    }
                )

        stix_observable_relations_mapping = {}
        for relation_to_create in relations_to_create:
            stix_observable_relation_result = self.opencti.stix_observable_relation.create(
                fromId=stix_observables_mapping[relation_to_create[&#34;from&#34;]],
                fromType=relation_to_create[&#34;fromType&#34;],
                toId=stix_observables_mapping[relation_to_create[&#34;to&#34;]],
                toType=relation_to_create[&#34;toType&#34;],
                relationship_type=relation_to_create[&#34;type&#34;],
                createdByRef=created_by_ref_id,
                markingDefinitions=marking_definitions_ids,
            )
            stix_observable_relations_mapping[
                relation_to_create[&#34;id&#34;]
            ] = stix_observable_relation_result[&#34;id&#34;]

    def export_entity(
        self, entity_type, entity_id, mode=&#34;simple&#34;, max_marking_definition=None
    ):
        max_marking_definition_entity = (
            self.opencti.marking_definition.read(id=max_marking_definition)
            if max_marking_definition is not None
            else None
        )
        bundle = {
            &#34;type&#34;: &#34;bundle&#34;,
            &#34;id&#34;: &#34;bundle--&#34; + str(uuid.uuid4()),
            &#34;objects&#34;: [],
        }
        # Map types
        if IdentityTypes.has_value(entity_type):
            entity_type = &#34;identity&#34;

        # Export
        exporter = {
            &#34;identity&#34;: self.opencti.identity.to_stix2,
            &#34;threat-actor&#34;: self.opencti.threat_actor.to_stix2,
            &#34;intrusion-set&#34;: self.opencti.intrusion_set.to_stix2,
            &#34;campaign&#34;: self.opencti.campaign.to_stix2,
            &#34;incident&#34;: self.opencti.incident.to_stix2,
            &#34;malware&#34;: self.opencti.malware.to_stix2,
            &#34;tool&#34;: self.opencti.tool.to_stix2,
            &#34;vulnerability&#34;: self.opencti.vulnerability.to_stix2,
            &#34;attack-pattern&#34;: self.opencti.attack_pattern.to_stix2,
            &#34;course-of-action&#34;: self.opencti.course_of_action.to_stix2,
            &#34;report&#34;: self.opencti.report.to_stix2,
            &#34;note&#34;: self.opencti.note.to_stix2,
            &#34;opinion&#34;: self.opencti.opinion.to_stix2,
            &#34;indicator&#34;: self.opencti.indicator.to_stix2,
        }
        do_export = exporter.get(
            entity_type, lambda **kwargs: self.unknown_type({&#34;type&#34;: entity_type})
        )
        objects = do_export(
            id=entity_id,
            mode=mode,
            max_marking_definition_entity=max_marking_definition_entity,
        )
        if objects is not None:
            bundle[&#34;objects&#34;].extend(objects)
        return bundle

    def export_list(
        self,
        entity_type,
        search=None,
        filters=None,
        order_by=None,
        order_mode=None,
        max_marking_definition=None,
    ):
        max_marking_definition_entity = (
            self.opencti.marking_definition.read(id=max_marking_definition)
            if max_marking_definition is not None
            else None
        )
        bundle = {
            &#34;type&#34;: &#34;bundle&#34;,
            &#34;id&#34;: &#34;bundle--&#34; + str(uuid.uuid4()),
            &#34;objects&#34;: [],
        }

        if IdentityTypes.has_value(entity_type):
            if filters is not None:
                filters.append({&#34;key&#34;: &#34;entity_type&#34;, &#34;values&#34;: [entity_type]})
            else:
                filters = [{&#34;key&#34;: &#34;entity_type&#34;, &#34;values&#34;: [entity_type]}]
            entity_type = &#34;identity&#34;

        # List
        lister = {
            &#34;identity&#34;: self.opencti.identity.list,
            &#34;threat-actor&#34;: self.opencti.threat_actor.list,
            &#34;intrusion-set&#34;: self.opencti.intrusion_set.list,
            &#34;campaign&#34;: self.opencti.campaign.list,
            &#34;incident&#34;: self.opencti.incident.list,
            &#34;malware&#34;: self.opencti.malware.list,
            &#34;tool&#34;: self.opencti.tool.list,
            &#34;vulnerability&#34;: self.opencti.vulnerability.list,
            &#34;attack-pattern&#34;: self.opencti.attack_pattern.list,
            &#34;course-of-action&#34;: self.opencti.course_of_action.list,
            &#34;report&#34;: self.opencti.report.list,
            &#34;note&#34;: self.opencti.note.list,
            &#34;opinion&#34;: self.opencti.opinion.list,
            &#34;indicator&#34;: self.opencti.indicator.list,
        }
        do_list = lister.get(
            entity_type, lambda **kwargs: self.unknown_type({&#34;type&#34;: entity_type})
        )
        entities_list = do_list(
            search=search,
            filters=filters,
            orderBy=order_by,
            orderMode=order_mode,
            getAll=True,
        )

        if entities_list is not None:
            # Export
            exporter = {
                &#34;identity&#34;: self.opencti.identity.to_stix2,
                &#34;threat-actor&#34;: self.opencti.threat_actor.to_stix2,
                &#34;intrusion-set&#34;: self.opencti.intrusion_set.to_stix2,
                &#34;campaign&#34;: self.opencti.campaign.to_stix2,
                &#34;incident&#34;: self.opencti.incident.to_stix2,
                &#34;malware&#34;: self.opencti.malware.to_stix2,
                &#34;tool&#34;: self.opencti.tool.to_stix2,
                &#34;vulnerability&#34;: self.opencti.vulnerability.to_stix2,
                &#34;attack-pattern&#34;: self.opencti.attack_pattern.to_stix2,
                &#34;course-of-action&#34;: self.opencti.course_of_action.to_stix2,
                &#34;report&#34;: self.opencti.report.to_stix2,
                &#34;note&#34;: self.opencti.note.to_stix2,
                &#34;opinion&#34;: self.opencti.opinion.to_stix2,
                &#34;indicator&#34;: self.opencti.indicator.to_stix2,
            }
            do_export = exporter.get(
                entity_type, lambda **kwargs: self.unknown_type({&#34;type&#34;: entity_type})
            )
            uuids = []
            for entity in entities_list:
                entity_bundle = do_export(
                    entity=entity,
                    max_marking_definition_entity=max_marking_definition_entity,
                )
                if entity_bundle is not None:
                    entity_bundle_filtered = self.filter_objects(uuids, entity_bundle)
                    for x in entity_bundle_filtered:
                        uuids.append(x[&#34;id&#34;])
                    bundle[&#34;objects&#34;] = bundle[&#34;objects&#34;] + entity_bundle_filtered

        return bundle

    def prepare_export(
        self, entity, stix_object, mode=&#34;simple&#34;, max_marking_definition_entity=None
    ):
        if (
            self.check_max_marking_definition(
                max_marking_definition_entity, entity[&#34;markingDefinitions&#34;]
            )
            is False
        ):
            self.opencti.log(
                &#34;info&#34;,
                &#34;Marking definitions of &#34;
                + stix_object[&#34;type&#34;]
                + &#39; &#34;&#39;
                + stix_object[&#34;name&#34;]
                + &#39;&#34; are less than max definition, not exporting.&#39;,
            )
            return []
        result = []
        objects_to_get = []
        relations_to_get = []
        if &#34;createdByRef&#34; in entity and entity[&#34;createdByRef&#34;] is not None:
            entity_created_by_ref = entity[&#34;createdByRef&#34;]
            if entity_created_by_ref[&#34;entity_type&#34;] == &#34;user&#34;:
                identity_class = &#34;individual&#34;
            elif entity_created_by_ref[&#34;entity_type&#34;] == &#34;sector&#34;:
                identity_class = &#34;class&#34;
            else:
                identity_class = entity_created_by_ref[&#34;entity_type&#34;]

            created_by_ref = dict()
            created_by_ref[&#34;id&#34;] = entity_created_by_ref[&#34;stix_id_key&#34;]
            created_by_ref[&#34;type&#34;] = &#34;identity&#34;
            created_by_ref[&#34;name&#34;] = entity_created_by_ref[&#34;name&#34;]
            created_by_ref[&#34;identity_class&#34;] = identity_class
            if self.opencti.not_empty(entity_created_by_ref[&#34;stix_label&#34;]):
                created_by_ref[&#34;labels&#34;] = entity_created_by_ref[&#34;stix_label&#34;]
            else:
                created_by_ref[&#34;labels&#34;] = [&#34;identity&#34;]
            created_by_ref[&#34;created&#34;] = self.format_date(
                entity_created_by_ref[&#34;created&#34;]
            )
            created_by_ref[&#34;modified&#34;] = self.format_date(
                entity_created_by_ref[&#34;modified&#34;]
            )
            if (
                entity_created_by_ref[&#34;entity_type&#34;] == &#34;organization&#34;
                and &#34;organization_class&#34; in entity_created_by_ref
            ):
                created_by_ref[CustomProperties.ORG_CLASS] = entity_created_by_ref[
                    &#34;organization_class&#34;
                ]
            if self.opencti.not_empty(entity_created_by_ref[&#34;alias&#34;]):
                created_by_ref[CustomProperties.ALIASES] = entity_created_by_ref[
                    &#34;alias&#34;
                ]
            created_by_ref[CustomProperties.IDENTITY_TYPE] = entity_created_by_ref[
                &#34;entity_type&#34;
            ]
            created_by_ref[CustomProperties.ID] = entity_created_by_ref[&#34;id&#34;]

            stix_object[&#34;created_by_ref&#34;] = created_by_ref[&#34;id&#34;]
            result.append(created_by_ref)
        if &#34;markingDefinitions&#34; in entity and len(entity[&#34;markingDefinitions&#34;]) &gt; 0:
            marking_definitions = []
            for entity_marking_definition in entity[&#34;markingDefinitions&#34;]:
                marking_definition = {
                    &#34;id&#34;: entity_marking_definition[&#34;stix_id_key&#34;],
                    &#34;type&#34;: &#34;marking-definition&#34;,
                    &#34;definition_type&#34;: entity_marking_definition[
                        &#34;definition_type&#34;
                    ].lower(),
                    &#34;definition&#34;: {
                        entity_marking_definition[
                            &#34;definition_type&#34;
                        ]: entity_marking_definition[&#34;definition&#34;]
                    },
                    &#34;created&#34;: entity_marking_definition[&#34;created&#34;],
                    CustomProperties.MODIFIED: entity_marking_definition[&#34;modified&#34;],
                    CustomProperties.ID: entity_marking_definition[&#34;id&#34;],
                }
                marking_definitions.append(marking_definition[&#34;id&#34;])
                result.append(marking_definition)
            stix_object[&#34;object_marking_refs&#34;] = marking_definitions
        if &#34;tags&#34; in entity and len(entity[&#34;tags&#34;]) &gt; 0:
            tags = []
            for entity_tag in entity[&#34;tags&#34;]:
                tag = dict()
                tag[&#34;id&#34;] = entity_tag[&#34;id&#34;]
                tag[&#34;tag_type&#34;] = entity_tag[&#34;tag_type&#34;]
                tag[&#34;value&#34;] = entity_tag[&#34;value&#34;]
                tag[&#34;color&#34;] = entity_tag[&#34;color&#34;]
                tags.append(tag)
            stix_object[CustomProperties.TAG_TYPE] = tags
        if &#34;killChainPhases&#34; in entity and len(entity[&#34;killChainPhases&#34;]) &gt; 0:
            kill_chain_phases = []
            for entity_kill_chain_phase in entity[&#34;killChainPhases&#34;]:
                kill_chain_phase = {
                    &#34;id&#34;: entity_kill_chain_phase[&#34;stix_id_key&#34;],
                    &#34;kill_chain_name&#34;: entity_kill_chain_phase[&#34;kill_chain_name&#34;],
                    &#34;phase_name&#34;: entity_kill_chain_phase[&#34;phase_name&#34;],
                    CustomProperties.ID: entity_kill_chain_phase[&#34;id&#34;],
                    CustomProperties.PHASE_ORDER: entity_kill_chain_phase[
                        &#34;phase_order&#34;
                    ],
                    CustomProperties.CREATED: entity_kill_chain_phase[&#34;created&#34;],
                    CustomProperties.MODIFIED: entity_kill_chain_phase[&#34;modified&#34;],
                }
                kill_chain_phases.append(kill_chain_phase)
            stix_object[&#34;kill_chain_phases&#34;] = kill_chain_phases
        if &#34;externalReferences&#34; in entity and len(entity[&#34;externalReferences&#34;]) &gt; 0:
            external_references = []
            for entity_external_reference in entity[&#34;externalReferences&#34;]:
                external_reference = dict()
                external_reference[&#34;id&#34;] = entity_external_reference[&#34;stix_id_key&#34;]
                if self.opencti.not_empty(entity_external_reference[&#34;source_name&#34;]):
                    external_reference[&#34;source_name&#34;] = entity_external_reference[
                        &#34;source_name&#34;
                    ]
                if self.opencti.not_empty(entity_external_reference[&#34;description&#34;]):
                    external_reference[&#34;description&#34;] = entity_external_reference[
                        &#34;description&#34;
                    ]
                if self.opencti.not_empty(entity_external_reference[&#34;url&#34;]):
                    external_reference[&#34;url&#34;] = entity_external_reference[&#34;url&#34;]
                if self.opencti.not_empty(entity_external_reference[&#34;hash&#34;]):
                    external_reference[&#34;hash&#34;] = entity_external_reference[&#34;hash&#34;]
                if self.opencti.not_empty(entity_external_reference[&#34;external_id&#34;]):
                    external_reference[&#34;external_id&#34;] = entity_external_reference[
                        &#34;external_id&#34;
                    ]
                external_reference[CustomProperties.ID] = entity_external_reference[
                    &#34;id&#34;
                ]
                external_reference[
                    CustomProperties.CREATED
                ] = entity_external_reference[&#34;created&#34;]
                external_reference[
                    CustomProperties.MODIFIED
                ] = entity_external_reference[&#34;modified&#34;]
                external_references.append(external_reference)
            stix_object[&#34;external_references&#34;] = external_references
        if &#34;objectRefs&#34; in entity and len(entity[&#34;objectRefs&#34;]) &gt; 0:
            object_refs = []
            objects_to_get = entity[&#34;objectRefs&#34;]
            for entity_object_ref in entity[&#34;objectRefs&#34;]:
                object_refs.append(entity_object_ref[&#34;stix_id_key&#34;])
            if &#34;relationRefs&#34; in entity and len(entity[&#34;relationRefs&#34;]) &gt; 0:
                relations_to_get = entity[&#34;relationRefs&#34;]
                for entity_relation_ref in entity[&#34;relationRefs&#34;]:
                    if entity_relation_ref[&#34;stix_id_key&#34;] not in object_refs:
                        object_refs.append(entity_relation_ref[&#34;stix_id_key&#34;])
            stix_object[&#34;object_refs&#34;] = object_refs

        uuids = []
        for x in result:
            uuids.append(x[&#34;id&#34;])

        observables_stix_ids = []
        observable_object_data = None
        if &#34;observableRefs&#34; in entity and len(entity[&#34;observableRefs&#34;]) &gt; 0:
            observable_object_data = self.export_stix_observables(entity)
            if observable_object_data is not None:
                observable_object_bundle = self.filter_objects(
                    uuids, [observable_object_data[&#34;observedData&#34;]]
                )
                uuids = uuids + [x[&#34;id&#34;] for x in observable_object_bundle]
                result = result + observable_object_bundle
                observables_stix_ids = (
                    observables_stix_ids + observable_object_data[&#34;stixIds&#34;]
                )
                if stix_object[&#34;type&#34;] == &#34;report&#34;:
                    if &#34;object_refs&#34; in stix_object:
                        stix_object[&#34;object_refs&#34;].append(
                            observable_object_data[&#34;observedData&#34;][&#34;id&#34;]
                        )
                    else:
                        stix_object[&#34;object_refs&#34;] = [
                            observable_object_data[&#34;observedData&#34;][&#34;id&#34;]
                        ]
        result.append(stix_object)

        if mode == &#34;simple&#34;:
            return result
        elif mode == &#34;full&#34;:
            # Get extra relations
            stix_relations = self.opencti.stix_relation.list(
                fromId=entity[&#34;id&#34;], forceNatural=True
            )
            for stix_relation in stix_relations:
                if self.check_max_marking_definition(
                    max_marking_definition_entity, stix_relation[&#34;markingDefinitions&#34;]
                ):
                    if stix_relation[&#34;to&#34;][&#34;id&#34;] == entity[&#34;id&#34;]:
                        other_side_entity = stix_relation[&#34;from&#34;]
                    else:
                        other_side_entity = stix_relation[&#34;to&#34;]
                    objects_to_get.append(other_side_entity)
                    if other_side_entity[&#34;stix_id_key&#34;] in observables_stix_ids:
                        other_side_entity[&#34;stix_id_key&#34;] = observable_object_data[
                            &#34;observedData&#34;
                        ][&#34;id&#34;]
                    relation_object_data = self.opencti.stix_relation.to_stix2(
                        entity=stix_relation
                    )
                    relation_object_bundle = self.filter_objects(
                        uuids, relation_object_data
                    )
                    uuids = uuids + [x[&#34;id&#34;] for x in relation_object_bundle]
                    result = result + relation_object_bundle
                else:
                    self.opencti.log(
                        &#34;info&#34;,
                        &#34;Marking definitions of &#34;
                        + stix_relation[&#34;entity_type&#34;]
                        + &#39; &#34;&#39;
                        + stix_relation[&#34;id&#34;]
                        + &#39;&#34; are less than max definition, not exporting the relation AND the target entity.&#39;,
                    )

            # Export
            exporter = {
                &#34;identity&#34;: self.opencti.identity.to_stix2,
                &#34;threat-actor&#34;: self.opencti.threat_actor.to_stix2,
                &#34;intrusion-set&#34;: self.opencti.intrusion_set.to_stix2,
                &#34;campaign&#34;: self.opencti.campaign.to_stix2,
                &#34;incident&#34;: self.opencti.incident.to_stix2,
                &#34;malware&#34;: self.opencti.malware.to_stix2,
                &#34;tool&#34;: self.opencti.tool.to_stix2,
                &#34;vulnerability&#34;: self.opencti.vulnerability.to_stix2,
                &#34;attack-pattern&#34;: self.opencti.attack_pattern.to_stix2,
                &#34;course-of-action&#34;: self.opencti.course_of_action.to_stix2,
                &#34;report&#34;: self.opencti.report.to_stix2,
                &#34;note&#34;: self.opencti.note.to_stix2,
                &#34;opinion&#34;: self.opencti.opinion.to_stix2,
                &#34;indicator&#34;: self.opencti.indicator.to_stix2,
            }

            # Get extra objects
            for entity_object in objects_to_get:
                # Map types
                if IdentityTypes.has_value(entity_object[&#34;entity_type&#34;]):
                    entity_object[&#34;entity_type&#34;] = &#34;identity&#34;
                do_export = exporter.get(
                    entity_object[&#34;entity_type&#34;],
                    lambda **kwargs: self.unknown_type(
                        {&#34;type&#34;: entity_object[&#34;entity_type&#34;]}
                    ),
                )
                entity_object_data = do_export(id=entity_object[&#34;id&#34;])
                # Add to result
                entity_object_bundle = self.filter_objects(uuids, entity_object_data)
                uuids = uuids + [x[&#34;id&#34;] for x in entity_object_bundle]
                result = result + entity_object_bundle
            for relation_object in relations_to_get:
                relation_object_data = self.opencti.stix_relation.to_stix2(
                    id=relation_object[&#34;id&#34;]
                )
                relation_object_bundle = self.filter_objects(
                    uuids, relation_object_data
                )
                uuids = uuids + [x[&#34;id&#34;] for x in relation_object_bundle]
                result = result + relation_object_bundle

            # Get extra reports
            &#34;&#34;&#34;
            for uuid in uuids:
                if &#34;marking-definition&#34; not in uuid:
                    reports = self.opencti.stix_entity.reports(id=uuid)
                    for report in reports:
                        report_object_data = self.opencti.report.to_stix2(
                            entity=report,
                            mode=&#34;simple&#34;,
                            max_marking_definition_entity=max_marking_definition_entity,
                        )
                        report_object_bundle = self.filter_objects(
                            uuids, report_object_data
                        )
                        uuids = uuids + [x[&#34;id&#34;] for x in report_object_bundle]
                        result = result + report_object_bundle
            &#34;&#34;&#34;

            # Refilter all the reports object refs
            final_result = []
            for entity in result:
                if entity[&#34;type&#34;] == &#34;report&#34;:
                    if &#34;object_refs&#34; in entity:
                        entity[&#34;object_refs&#34;] = [
                            k for k in entity[&#34;object_refs&#34;] if k in uuids
                        ]
                    final_result.append(entity)
                else:
                    final_result.append(entity)
            return final_result
        else:
            return []

    # TODO move in MarkingDefinition
    def create_marking_definition(self, stix_object, extras, update=False):
        definition_type = stix_object[&#34;definition_type&#34;]
        definition = stix_object[&#34;definition&#34;][stix_object[&#34;definition_type&#34;]]
        if stix_object[&#34;definition_type&#34;] == &#34;tlp&#34;:
            definition_type = &#34;TLP&#34;
            definition = (
                &#34;TLP:&#34;
                + stix_object[&#34;definition&#34;][stix_object[&#34;definition_type&#34;]].upper()
            )
        return self.opencti.marking_definition.create(
            definition_type=definition_type,
            definition=definition,
            level=stix_object[CustomProperties.LEVEL]
            if CustomProperties.LEVEL in stix_object
            else 0,
            color=stix_object[CustomProperties.COLOR]
            if CustomProperties.COLOR in stix_object
            else None,
            id=stix_object[CustomProperties.ID]
            if CustomProperties.ID in stix_object
            else None,
            stix_id_key=stix_object[&#34;id&#34;],
            created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
            modified=stix_object[CustomProperties.MODIFIED]
            if CustomProperties.MODIFIED in stix_object
            else None,
            createdByRef=extras[&#34;created_by_ref_id&#34;]
            if &#34;created_by_ref_id&#34; in extras
            else None,
        )

    # TODO move in Identity
    def create_identity(self, stix_object, extras, update=False):
        if CustomProperties.IDENTITY_TYPE in stix_object:
            type = stix_object[CustomProperties.IDENTITY_TYPE].capitalize()
        else:
            if stix_object[&#34;identity_class&#34;] == &#34;individual&#34;:
                type = &#34;User&#34;
            elif stix_object[&#34;identity_class&#34;] == &#34;organization&#34;:
                type = &#34;Organization&#34;
            elif stix_object[&#34;identity_class&#34;] == &#34;group&#34;:
                type = &#34;Organization&#34;
            elif stix_object[&#34;identity_class&#34;] == &#34;class&#34;:
                type = &#34;Sector&#34;
            else:
                return None
        return self.opencti.identity.create(
            type=type,
            name=stix_object[&#34;name&#34;],
            description=self.convert_markdown(stix_object[&#34;description&#34;])
            if &#34;description&#34; in stix_object
            else &#34;&#34;,
            alias=self.pick_aliases(stix_object),
            id=stix_object[CustomProperties.ID]
            if CustomProperties.ID in stix_object
            else None,
            stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
            created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
            modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
            createdByRef=extras[&#34;created_by_ref_id&#34;]
            if &#34;created_by_ref_id&#34; in extras
            else None,
            markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
            if &#34;marking_definitions_ids&#34; in extras
            else [],
            update=update,
        )

    # TODO move in ThreatActor
    def create_threat_actor(self, stix_object, extras, update=False):
        return self.opencti.threat_actor.create(
            name=stix_object[&#34;name&#34;],
            description=self.convert_markdown(stix_object[&#34;description&#34;])
            if &#34;description&#34; in stix_object
            else &#34;&#34;,
            alias=self.pick_aliases(stix_object),
            goal=stix_object[&#34;goals&#34;] if &#34;goals&#34; in stix_object else None,
            sophistication=stix_object[&#34;sophistication&#34;]
            if &#34;sophistication&#34; in stix_object
            else None,
            resource_level=stix_object[&#34;resource_level&#34;]
            if &#34;resource_level&#34; in stix_object
            else None,
            primary_motivaton=stix_object[&#34;primary_motivation&#34;]
            if &#34;primary_motivation&#34; in stix_object
            else None,
            secondary_motivation=stix_object[&#34;secondary_motivations&#34;]
            if &#34;secondary_motivations&#34; in stix_object
            else None,
            personal_motivation=stix_object[&#34;personal_motivations&#34;]
            if &#34;personal_motivations&#34; in stix_object
            else None,
            id=stix_object[CustomProperties.ID]
            if CustomProperties.ID in stix_object
            else None,
            stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
            created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
            modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
            createdByRef=extras[&#34;created_by_ref_id&#34;]
            if &#34;created_by_ref_id&#34; in extras
            else None,
            markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
            if &#34;marking_definitions_ids&#34; in extras
            else [],
            update=update,
        )

    # TODO move in IntrusionSet
    def create_intrusion_set(self, stix_object, extras, update=False):
        return self.opencti.intrusion_set.create(
            name=stix_object[&#34;name&#34;],
            description=self.convert_markdown(stix_object[&#34;description&#34;])
            if &#34;description&#34; in stix_object
            else &#34;&#34;,
            alias=self.pick_aliases(stix_object),
            first_seen=stix_object[CustomProperties.FIRST_SEEN]
            if CustomProperties.FIRST_SEEN in stix_object
            else None,
            last_seen=stix_object[CustomProperties.LAST_SEEN]
            if CustomProperties.LAST_SEEN in stix_object
            else None,
            goal=stix_object[&#34;goals&#34;] if &#34;goals&#34; in stix_object else None,
            sophistication=stix_object[&#34;sophistication&#34;]
            if &#34;sophistication&#34; in stix_object
            else None,
            resource_level=stix_object[&#34;resource_level&#34;]
            if &#34;resource_level&#34; in stix_object
            else None,
            primary_motivation=stix_object[&#34;primary_motivation&#34;]
            if &#34;primary_motivation&#34; in stix_object
            else None,
            secondary_motivation=stix_object[&#34;secondary_motivations&#34;]
            if &#34;secondary_motivations&#34; in stix_object
            else None,
            id=stix_object[CustomProperties.ID]
            if CustomProperties.ID in stix_object
            else None,
            stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
            created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
            modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
            createdByRef=extras[&#34;created_by_ref_id&#34;]
            if &#34;created_by_ref_id&#34; in extras
            else None,
            markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
            if &#34;marking_definitions_ids&#34; in extras
            else [],
            update=update,
        )

    # TODO move in Campaign
    def create_campaign(self, stix_object, extras, update=False):
        return self.opencti.campaign.create(
            name=stix_object[&#34;name&#34;],
            description=self.convert_markdown(stix_object[&#34;description&#34;])
            if &#34;description&#34; in stix_object
            else &#34;&#34;,
            alias=self.pick_aliases(stix_object),
            objective=stix_object[&#34;objective&#34;] if &#34;objective&#34; in stix_object else None,
            first_seen=stix_object[CustomProperties.FIRST_SEEN]
            if CustomProperties.FIRST_SEEN in stix_object
            else None,
            last_seen=stix_object[CustomProperties.LAST_SEEN]
            if CustomProperties.LAST_SEEN in stix_object
            else None,
            id=stix_object[CustomProperties.ID]
            if CustomProperties.ID in stix_object
            else None,
            stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
            created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
            modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
            createdByRef=extras[&#34;created_by_ref_id&#34;]
            if &#34;created_by_ref_id&#34; in extras
            else None,
            markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
            if &#34;marking_definitions_ids&#34; in extras
            else [],
            uodate=update,
        )

    # TODO move in Incident
    def create_incident(self, stix_object, extras, update=False):
        return self.opencti.incident.create(
            name=stix_object[&#34;name&#34;],
            description=self.convert_markdown(stix_object[&#34;description&#34;])
            if &#34;description&#34; in stix_object
            else &#34;&#34;,
            alias=self.pick_aliases(stix_object),
            objective=stix_object[&#34;objective&#34;] if &#34;objective&#34; in stix_object else None,
            first_seen=stix_object[&#34;first_seen&#34;]
            if &#34;first_seen&#34; in stix_object
            else None,
            last_seen=stix_object[&#34;last_seen&#34;] if &#34;last_seen&#34; in stix_object else None,
            id=stix_object[CustomProperties.ID]
            if CustomProperties.ID in stix_object
            else None,
            stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
            created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
            modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
            createdByRef=extras[&#34;created_by_ref_id&#34;]
            if &#34;created_by_ref_id&#34; in extras
            else None,
            markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
            if &#34;marking_definitions_ids&#34; in extras
            else [],
            update=update,
        )

    # TODO move in Malware
    def create_malware(self, stix_object, extras, update=False):
        return self.opencti.malware.create(
            name=stix_object[&#34;name&#34;],
            description=self.convert_markdown(stix_object[&#34;description&#34;])
            if &#34;description&#34; in stix_object
            else &#34;&#34;,
            alias=self.pick_aliases(stix_object),
            id=stix_object[CustomProperties.ID]
            if CustomProperties.ID in stix_object
            else None,
            stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
            created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
            modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
            createdByRef=extras[&#34;created_by_ref_id&#34;]
            if &#34;created_by_ref_id&#34; in extras
            else None,
            markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
            if &#34;marking_definitions_ids&#34; in extras
            else [],
            killChainPhases=extras[&#34;kill_chain_phases_ids&#34;]
            if &#34;kill_chain_phases_ids&#34; in extras
            else [],
            update=update,
        )

    # TODO move in Tool
    def create_tool(self, stix_object, extras, update=False):
        return self.opencti.tool.create(
            name=stix_object[&#34;name&#34;],
            description=self.convert_markdown(stix_object[&#34;description&#34;])
            if &#34;description&#34; in stix_object
            else &#34;&#34;,
            alias=self.pick_aliases(stix_object),
            id=stix_object[CustomProperties.ID]
            if CustomProperties.ID in stix_object
            else None,
            stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
            created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
            modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
            createdByRef=extras[&#34;created_by_ref_id&#34;]
            if &#34;created_by_ref_id&#34; in extras
            else None,
            markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
            if &#34;marking_definitions_ids&#34; in extras
            else [],
            killChainPhases=extras[&#34;kill_chain_phases_ids&#34;]
            if &#34;kill_chain_phases_ids&#34; in extras
            else [],
            update=update,
        )

    # TODO move in Vulnerability
    def create_vulnerability(self, stix_object, extras, update=False):
        return self.opencti.vulnerability.create(
            name=stix_object[&#34;name&#34;],
            description=self.convert_markdown(stix_object[&#34;description&#34;])
            if &#34;description&#34; in stix_object
            else &#34;&#34;,
            base_score=stix_object[CustomProperties.BASE_SCORE]
            if CustomProperties.BASE_SCORE in stix_object
            else None,
            base_severity=stix_object[CustomProperties.BASE_SEVERITY]
            if CustomProperties.BASE_SEVERITY in stix_object
            else None,
            attack_vector=stix_object[CustomProperties.ATTACK_VECTOR]
            if CustomProperties.ATTACK_VECTOR in stix_object
            else None,
            integrity_impact=stix_object[CustomProperties.INTEGRITY_IMPACT]
            if CustomProperties.INTEGRITY_IMPACT in stix_object
            else None,
            availability_impact=stix_object[CustomProperties.AVAILABILITY_IMPACT]
            if CustomProperties.AVAILABILITY_IMPACT in stix_object
            else None,
            alias=self.pick_aliases(stix_object),
            id=stix_object[CustomProperties.ID]
            if CustomProperties.ID in stix_object
            else None,
            stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
            created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
            modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
            createdByRef=extras[&#34;created_by_ref_id&#34;]
            if &#34;created_by_ref_id&#34; in extras
            else None,
            markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
            if &#34;marking_definitions_ids&#34; in extras
            else [],
            update=update,
        )

    def create_attack_pattern(self, stix_object, extras, update=False):
        return self.opencti.attack_pattern.import_from_stix2(
            stixObject=stix_object, extras=extras, update=update
        )

    # TODO move in Course Of Action
    def create_course_of_action(self, stix_object, extras, update=False):
        return self.opencti.course_of_action.create(
            name=stix_object[&#34;name&#34;],
            description=self.convert_markdown(stix_object[&#34;description&#34;])
            if &#34;description&#34; in stix_object
            else &#34;&#34;,
            alias=self.pick_aliases(stix_object),
            id=stix_object[CustomProperties.ID]
            if CustomProperties.ID in stix_object
            else None,
            stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
            created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
            modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
            createdByRef=extras[&#34;created_by_ref_id&#34;]
            if &#34;created_by_ref_id&#34; in extras
            else None,
            markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
            if &#34;marking_definitions_ids&#34; in extras
            else [],
            update=update,
        )

    def create_report(self, stix_object, extras, update=False):
        return self.opencti.report.import_from_stix2(
            stixObject=stix_object, extras=extras, update=update
        )

    def create_note(self, stix_object, extras, update=False):
        return self.opencti.note.import_from_stix2(
            stixObject=stix_object, extras=extras, update=update
        )

    def create_opinion(self, stix_object, extras, update=False):
        return self.opencti.opinion.import_from_stix2(
            stixObject=stix_object, extras=extras, update=update
        )

    def export_stix_observables(self, entity):
        stix_ids = []
        observed_data = dict()
        observed_data[&#34;id&#34;] = &#34;observed-data--&#34; + str(uuid.uuid4())
        observed_data[&#34;type&#34;] = &#34;observed-data&#34;
        observed_data[&#34;number_observed&#34;] = len(entity[&#34;observableRefs&#34;])
        observed_data[&#34;objects&#34;] = []
        for observable in entity[&#34;observableRefs&#34;]:
            stix_observable = dict()
            stix_observable[CustomProperties.OBSERVABLE_TYPE] = observable[
                &#34;entity_type&#34;
            ]
            stix_observable[CustomProperties.OBSERVABLE_VALUE] = observable[
                &#34;observable_value&#34;
            ]
            stix_observable[&#34;type&#34;] = observable[&#34;entity_type&#34;]
            observed_data[&#34;objects&#34;].append(stix_observable)
            stix_ids.append(observable[&#34;stix_id_key&#34;])

        return {&#34;observedData&#34;: observed_data, &#34;stixIds&#34;: stix_ids}

    def create_indicator(self, stix_object, extras, update=False):
        return self.opencti.indicator.create(
            name=stix_object[&#34;name&#34;],
            description=self.convert_markdown(stix_object[&#34;description&#34;])
            if &#34;description&#34; in stix_object
            else &#34;&#34;,
            indicator_pattern=stix_object[CustomProperties.INDICATOR_PATTERN]
            if CustomProperties.INDICATOR_PATTERN in stix_object
            else stix_object[&#34;pattern&#34;],
            main_observable_type=stix_object[CustomProperties.OBSERVABLE_TYPE]
            if CustomProperties.OBSERVABLE_TYPE in stix_object
            else &#34;Unknown&#34;,
            pattern_type=stix_object[CustomProperties.PATTERN_TYPE]
            if CustomProperties.PATTERN_TYPE in stix_object
            else &#34;stix&#34;,
            valid_from=stix_object[&#34;valid_from&#34;]
            if &#34;valid_from&#34; in stix_object
            else None,
            valid_until=stix_object[&#34;valid_until&#34;]
            if &#34;valid_until&#34; in stix_object
            else None,
            id=stix_object[CustomProperties.ID]
            if CustomProperties.ID in stix_object
            else None,
            stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
            created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
            modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
            createdByRef=extras[&#34;created_by_ref_id&#34;]
            if &#34;created_by_ref_id&#34; in extras
            else None,
            markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
            if &#34;marking_definitions_ids&#34; in extras
            else None,
            update=update,
        )

    def resolve_author(self, title):
        if &#34;fireeye&#34; in title.lower() or &#34;mandiant&#34; in title.lower():
            return self.get_author(&#34;FireEye&#34;)
        if &#34;eset&#34; in title.lower():
            return self.get_author(&#34;ESET&#34;)
        if &#34;dragos&#34; in title.lower():
            return self.get_author(&#34;Dragos&#34;)
        if &#34;us-cert&#34; in title.lower():
            return self.get_author(&#34;US-CERT&#34;)
        if (
            &#34;unit 42&#34; in title.lower()
            or &#34;unit42&#34; in title.lower()
            or &#34;palo alto&#34; in title.lower()
        ):
            return self.get_author(&#34;Palo Alto Networks&#34;)
        if &#34;accenture&#34; in title.lower():
            return self.get_author(&#34;Accenture&#34;)
        if &#34;symantec&#34; in title.lower():
            return self.get_author(&#34;Symantec&#34;)
        if &#34;trendmicro&#34; in title.lower() or &#34;trend micro&#34; in title.lower():
            return self.get_author(&#34;Trend Micro&#34;)
        if &#34;mcafee&#34; in title.lower():
            return self.get_author(&#34;McAfee&#34;)
        if &#34;crowdstrike&#34; in title.lower():
            return self.get_author(&#34;CrowdStrike&#34;)
        if &#34;securelist&#34; in title.lower() or &#34;kaspersky&#34; in title.lower():
            return self.get_author(&#34;Kaspersky&#34;)
        if &#34;f-secure&#34; in title.lower():
            return self.get_author(&#34;F-Secure&#34;)
        if &#34;checkpoint&#34; in title.lower():
            return self.get_author(&#34;CheckPoint&#34;)
        if &#34;talos&#34; in title.lower():
            return self.get_author(&#34;Cisco Talos&#34;)
        if &#34;secureworks&#34; in title.lower():
            return self.get_author(&#34;Dell SecureWorks&#34;)
        if &#34;microsoft&#34; in title.lower():
            return self.get_author(&#34;Microsoft&#34;)
        if &#34;mitre att&amp;ck&#34; in title.lower():
            return self.get_author(&#34;The MITRE Corporation&#34;)
        return None

    def get_author(self, name):
        if name in self.mapping_cache:
            return self.mapping_cache[name]
        else:
            author = self.opencti.identity.create(
                type=&#34;Organization&#34;, name=name, description=&#34;&#34;,
            )
            self.mapping_cache[name] = author
            return author

    def import_bundle(self, stix_bundle, update=False, types=None) -&gt; List:
        if types is None:
            types = []

        # Check if the bundle is correctly formatted
        if &#34;type&#34; not in stix_bundle or stix_bundle[&#34;type&#34;] != &#34;bundle&#34;:
            raise ValueError(&#34;JSON data type is not a STIX2 bundle&#34;)
        if &#34;objects&#34; not in stix_bundle or len(stix_bundle[&#34;objects&#34;]) == 0:
            raise ValueError(&#34;JSON data objects is empty&#34;)

        # Import every elements in a specific order
        imported_elements = []

        # Marking definitions
        start_time = time.time()
        for item in stix_bundle[&#34;objects&#34;]:
            if item[&#34;type&#34;] == &#34;marking-definition&#34;:
                self.import_object(item, update, types)
                imported_elements.append({&#34;id&#34;: item[&#34;id&#34;], &#34;type&#34;: item[&#34;type&#34;]})
        end_time = time.time()
        self.opencti.log(
            &#34;info&#34;,
            &#34;Marking definitions imported in: %ssecs&#34; % round(end_time - start_time),
        )

        # Identities
        start_time = time.time()
        for item in stix_bundle[&#34;objects&#34;]:
            if item[&#34;type&#34;] == &#34;identity&#34; and (
                len(types) == 0
                or &#34;identity&#34; in types
                or (
                    CustomProperties.IDENTITY_TYPE in item
                    and item[CustomProperties.IDENTITY_TYPE] in types
                )
            ):
                self.import_object(item, update, types)
                imported_elements.append({&#34;id&#34;: item[&#34;id&#34;], &#34;type&#34;: item[&#34;type&#34;]})
        end_time = time.time()
        self.opencti.log(
            &#34;info&#34;, &#34;Identities imported in: %ssecs&#34; % round(end_time - start_time)
        )

        # StixDomainObjects except Report/Opinion/Notes
        start_time = time.time()
        for item in stix_bundle[&#34;objects&#34;]:
            if (
                item[&#34;type&#34;] != &#34;relationship&#34;
                and item[&#34;type&#34;] != &#34;report&#34;
                and item[&#34;type&#34;] != &#34;note&#34;
                and item[&#34;type&#34;] != &#34;opinion&#34;
                and item[&#34;type&#34;] != &#34;observed-data&#34;
                and (len(types) == 0 or item[&#34;type&#34;] in types)
            ):
                self.import_object(item, update, types)
                imported_elements.append({&#34;id&#34;: item[&#34;id&#34;], &#34;type&#34;: item[&#34;type&#34;]})
        end_time = time.time()
        self.opencti.log(
            &#34;info&#34;, &#34;Objects imported in: %ssecs&#34; % round(end_time - start_time)
        )

        # StixCyberObservables
        start_time = time.time()
        for item in stix_bundle[&#34;objects&#34;]:
            if item[&#34;type&#34;] == &#34;observed-data&#34; and (
                len(types) == 0 or &#34;observed-data&#34; in types
            ):
                self.import_observables(item)
        end_time = time.time()
        self.opencti.log(
            &#34;info&#34;, &#34;Observables imported in: %ssecs&#34; % round(end_time - start_time)
        )

        # StixRelationObjects
        start_time = time.time()
        for item in stix_bundle[&#34;objects&#34;]:
            if item[&#34;type&#34;] == &#34;relationship&#34;:
                # Import only relationships between entities
                if (
                    CustomProperties.SOURCE_REF not in item
                    or &#34;relationship&#34; not in item[CustomProperties.SOURCE_REF]
                ) and (
                    CustomProperties.TARGET_REF not in item
                    or &#34;relationship&#34; not in item[CustomProperties.TARGET_REF]
                ):
                    source_ref = (
                        item[CustomProperties.SOURCE_REF]
                        if CustomProperties.SOURCE_REF in item
                        else item[&#34;source_ref&#34;]
                    )
                    target_ref = (
                        item[CustomProperties.TARGET_REF]
                        if CustomProperties.TARGET_REF in item
                        else item[&#34;target_ref&#34;]
                    )
                    if &#34;observed-data&#34; in source_ref:
                        if source_ref in self.mapping_cache:
                            for observable in self.mapping_cache[source_ref]:
                                item[CustomProperties.SOURCE_REF] = observable[&#34;id&#34;]
                                self.import_relationship(item, update, types)
                    elif &#34;observed-data&#34; in target_ref:
                        if target_ref in self.mapping_cache:
                            for observable in self.mapping_cache[target_ref]:
                                item[CustomProperties.TARGET_REF] = observable[&#34;id&#34;]
                                self.import_relationship(item, update, types)
                    else:
                        self.import_relationship(item, update, types)
                    imported_elements.append({&#34;id&#34;: item[&#34;id&#34;], &#34;type&#34;: item[&#34;type&#34;]})
        end_time = time.time()
        self.opencti.log(
            &#34;info&#34;, &#34;Relationships imported in: %ssecs&#34; % round(end_time - start_time)
        )

        # StixRelationObjects (with relationships)
        start_time = time.time()
        for item in stix_bundle[&#34;objects&#34;]:
            if item[&#34;type&#34;] == &#34;relationship&#34;:
                if (
                    CustomProperties.SOURCE_REF in item
                    and &#34;relationship&#34; in item[CustomProperties.SOURCE_REF]
                ) or (
                    CustomProperties.TARGET_REF in item
                    and &#34;relationship&#34; in item[CustomProperties.TARGET_REF]
                ):
                    self.import_relationship(item, update, types)
                    imported_elements.append({&#34;id&#34;: item[&#34;id&#34;], &#34;type&#34;: item[&#34;type&#34;]})
        end_time = time.time()
        self.opencti.log(
            &#34;info&#34;,
            &#34;Relationships to relationships imported in: %ssecs&#34;
            % round(end_time - start_time),
        )

        # Reports
        start_time = time.time()
        for item in stix_bundle[&#34;objects&#34;]:
            if item[&#34;type&#34;] == &#34;report&#34; and (len(types) == 0 or &#34;report&#34; in types):
                self.import_object(item, update, types)
                imported_elements.append({&#34;id&#34;: item[&#34;id&#34;], &#34;type&#34;: item[&#34;type&#34;]})
        end_time = time.time()
        self.opencti.log(
            &#34;info&#34;, &#34;Reports imported in: %ssecs&#34; % round(end_time - start_time)
        )

        # Notes
        start_time = time.time()
        for item in stix_bundle[&#34;objects&#34;]:
            if item[&#34;type&#34;] == &#34;note&#34; and (len(types) == 0 or &#34;note&#34; in types):
                self.import_object(item, update, types)
                imported_elements.append({&#34;id&#34;: item[&#34;id&#34;], &#34;type&#34;: item[&#34;type&#34;]})
        end_time = time.time()
        self.opencti.log(
            &#34;info&#34;, &#34;Notes imported in: %ssecs&#34; % round(end_time - start_time)
        )

        # Opinions
        start_time = time.time()
        for item in stix_bundle[&#34;objects&#34;]:
            if item[&#34;type&#34;] == &#34;opinion&#34; and (len(types) == 0 or &#34;opinion&#34; in types):
                self.import_object(item, update, types)
                imported_elements.append({&#34;id&#34;: item[&#34;id&#34;], &#34;type&#34;: item[&#34;type&#34;]})
        end_time = time.time()
        self.opencti.log(
            &#34;info&#34;, &#34;Opinions imported in: %ssecs&#34; % round(end_time - start_time)
        )
        return imported_elements</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pycti.utils.opencti_stix2.OpenCTIStix2.check_max_marking_definition"><code class="name flex">
<span>def <span class="ident">check_max_marking_definition</span></span>(<span>self, max_marking_definition_entity, entity_marking_definitions)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_max_marking_definition(
    self, max_marking_definition_entity, entity_marking_definitions
):
    # Max is not set, return True
    if max_marking_definition_entity is None:
        return True
    # Filter entity markings definition to the max_marking_definition type
    typed_entity_marking_definitions = []
    for entity_marking_definition in entity_marking_definitions:
        if (
            entity_marking_definition[&#34;definition_type&#34;]
            == max_marking_definition_entity[&#34;definition_type&#34;]
        ):
            typed_entity_marking_definitions.append(entity_marking_definition)
    # No entity marking defintions of the max_marking_definition type
    if len(typed_entity_marking_definitions) == 0:
        return True

    # Check if level is less or equal to max
    for typed_entity_marking_definition in typed_entity_marking_definitions:
        if (
            typed_entity_marking_definition[&#34;level&#34;]
            &lt;= max_marking_definition_entity[&#34;level&#34;]
        ):
            return True
    return False</code></pre>
</details>
</dd>
<dt id="pycti.utils.opencti_stix2.OpenCTIStix2.convert_markdown"><code class="name flex">
<span>def <span class="ident">convert_markdown</span></span>(<span>self, text)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_markdown(self, text):
    return text.replace(&#34;&lt;code&gt;&#34;, &#34;`&#34;).replace(&#34;&lt;/code&gt;&#34;, &#34;`&#34;)</code></pre>
</details>
</dd>
<dt id="pycti.utils.opencti_stix2.OpenCTIStix2.create_attack_pattern"><code class="name flex">
<span>def <span class="ident">create_attack_pattern</span></span>(<span>self, stix_object, extras, update=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_attack_pattern(self, stix_object, extras, update=False):
    return self.opencti.attack_pattern.import_from_stix2(
        stixObject=stix_object, extras=extras, update=update
    )</code></pre>
</details>
</dd>
<dt id="pycti.utils.opencti_stix2.OpenCTIStix2.create_campaign"><code class="name flex">
<span>def <span class="ident">create_campaign</span></span>(<span>self, stix_object, extras, update=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_campaign(self, stix_object, extras, update=False):
    return self.opencti.campaign.create(
        name=stix_object[&#34;name&#34;],
        description=self.convert_markdown(stix_object[&#34;description&#34;])
        if &#34;description&#34; in stix_object
        else &#34;&#34;,
        alias=self.pick_aliases(stix_object),
        objective=stix_object[&#34;objective&#34;] if &#34;objective&#34; in stix_object else None,
        first_seen=stix_object[CustomProperties.FIRST_SEEN]
        if CustomProperties.FIRST_SEEN in stix_object
        else None,
        last_seen=stix_object[CustomProperties.LAST_SEEN]
        if CustomProperties.LAST_SEEN in stix_object
        else None,
        id=stix_object[CustomProperties.ID]
        if CustomProperties.ID in stix_object
        else None,
        stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
        created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
        modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
        createdByRef=extras[&#34;created_by_ref_id&#34;]
        if &#34;created_by_ref_id&#34; in extras
        else None,
        markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
        if &#34;marking_definitions_ids&#34; in extras
        else [],
        uodate=update,
    )</code></pre>
</details>
</dd>
<dt id="pycti.utils.opencti_stix2.OpenCTIStix2.create_course_of_action"><code class="name flex">
<span>def <span class="ident">create_course_of_action</span></span>(<span>self, stix_object, extras, update=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_course_of_action(self, stix_object, extras, update=False):
    return self.opencti.course_of_action.create(
        name=stix_object[&#34;name&#34;],
        description=self.convert_markdown(stix_object[&#34;description&#34;])
        if &#34;description&#34; in stix_object
        else &#34;&#34;,
        alias=self.pick_aliases(stix_object),
        id=stix_object[CustomProperties.ID]
        if CustomProperties.ID in stix_object
        else None,
        stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
        created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
        modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
        createdByRef=extras[&#34;created_by_ref_id&#34;]
        if &#34;created_by_ref_id&#34; in extras
        else None,
        markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
        if &#34;marking_definitions_ids&#34; in extras
        else [],
        update=update,
    )</code></pre>
</details>
</dd>
<dt id="pycti.utils.opencti_stix2.OpenCTIStix2.create_identity"><code class="name flex">
<span>def <span class="ident">create_identity</span></span>(<span>self, stix_object, extras, update=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_identity(self, stix_object, extras, update=False):
    if CustomProperties.IDENTITY_TYPE in stix_object:
        type = stix_object[CustomProperties.IDENTITY_TYPE].capitalize()
    else:
        if stix_object[&#34;identity_class&#34;] == &#34;individual&#34;:
            type = &#34;User&#34;
        elif stix_object[&#34;identity_class&#34;] == &#34;organization&#34;:
            type = &#34;Organization&#34;
        elif stix_object[&#34;identity_class&#34;] == &#34;group&#34;:
            type = &#34;Organization&#34;
        elif stix_object[&#34;identity_class&#34;] == &#34;class&#34;:
            type = &#34;Sector&#34;
        else:
            return None
    return self.opencti.identity.create(
        type=type,
        name=stix_object[&#34;name&#34;],
        description=self.convert_markdown(stix_object[&#34;description&#34;])
        if &#34;description&#34; in stix_object
        else &#34;&#34;,
        alias=self.pick_aliases(stix_object),
        id=stix_object[CustomProperties.ID]
        if CustomProperties.ID in stix_object
        else None,
        stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
        created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
        modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
        createdByRef=extras[&#34;created_by_ref_id&#34;]
        if &#34;created_by_ref_id&#34; in extras
        else None,
        markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
        if &#34;marking_definitions_ids&#34; in extras
        else [],
        update=update,
    )</code></pre>
</details>
</dd>
<dt id="pycti.utils.opencti_stix2.OpenCTIStix2.create_incident"><code class="name flex">
<span>def <span class="ident">create_incident</span></span>(<span>self, stix_object, extras, update=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_incident(self, stix_object, extras, update=False):
    return self.opencti.incident.create(
        name=stix_object[&#34;name&#34;],
        description=self.convert_markdown(stix_object[&#34;description&#34;])
        if &#34;description&#34; in stix_object
        else &#34;&#34;,
        alias=self.pick_aliases(stix_object),
        objective=stix_object[&#34;objective&#34;] if &#34;objective&#34; in stix_object else None,
        first_seen=stix_object[&#34;first_seen&#34;]
        if &#34;first_seen&#34; in stix_object
        else None,
        last_seen=stix_object[&#34;last_seen&#34;] if &#34;last_seen&#34; in stix_object else None,
        id=stix_object[CustomProperties.ID]
        if CustomProperties.ID in stix_object
        else None,
        stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
        created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
        modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
        createdByRef=extras[&#34;created_by_ref_id&#34;]
        if &#34;created_by_ref_id&#34; in extras
        else None,
        markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
        if &#34;marking_definitions_ids&#34; in extras
        else [],
        update=update,
    )</code></pre>
</details>
</dd>
<dt id="pycti.utils.opencti_stix2.OpenCTIStix2.create_indicator"><code class="name flex">
<span>def <span class="ident">create_indicator</span></span>(<span>self, stix_object, extras, update=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_indicator(self, stix_object, extras, update=False):
    return self.opencti.indicator.create(
        name=stix_object[&#34;name&#34;],
        description=self.convert_markdown(stix_object[&#34;description&#34;])
        if &#34;description&#34; in stix_object
        else &#34;&#34;,
        indicator_pattern=stix_object[CustomProperties.INDICATOR_PATTERN]
        if CustomProperties.INDICATOR_PATTERN in stix_object
        else stix_object[&#34;pattern&#34;],
        main_observable_type=stix_object[CustomProperties.OBSERVABLE_TYPE]
        if CustomProperties.OBSERVABLE_TYPE in stix_object
        else &#34;Unknown&#34;,
        pattern_type=stix_object[CustomProperties.PATTERN_TYPE]
        if CustomProperties.PATTERN_TYPE in stix_object
        else &#34;stix&#34;,
        valid_from=stix_object[&#34;valid_from&#34;]
        if &#34;valid_from&#34; in stix_object
        else None,
        valid_until=stix_object[&#34;valid_until&#34;]
        if &#34;valid_until&#34; in stix_object
        else None,
        id=stix_object[CustomProperties.ID]
        if CustomProperties.ID in stix_object
        else None,
        stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
        created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
        modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
        createdByRef=extras[&#34;created_by_ref_id&#34;]
        if &#34;created_by_ref_id&#34; in extras
        else None,
        markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
        if &#34;marking_definitions_ids&#34; in extras
        else None,
        update=update,
    )</code></pre>
</details>
</dd>
<dt id="pycti.utils.opencti_stix2.OpenCTIStix2.create_intrusion_set"><code class="name flex">
<span>def <span class="ident">create_intrusion_set</span></span>(<span>self, stix_object, extras, update=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_intrusion_set(self, stix_object, extras, update=False):
    return self.opencti.intrusion_set.create(
        name=stix_object[&#34;name&#34;],
        description=self.convert_markdown(stix_object[&#34;description&#34;])
        if &#34;description&#34; in stix_object
        else &#34;&#34;,
        alias=self.pick_aliases(stix_object),
        first_seen=stix_object[CustomProperties.FIRST_SEEN]
        if CustomProperties.FIRST_SEEN in stix_object
        else None,
        last_seen=stix_object[CustomProperties.LAST_SEEN]
        if CustomProperties.LAST_SEEN in stix_object
        else None,
        goal=stix_object[&#34;goals&#34;] if &#34;goals&#34; in stix_object else None,
        sophistication=stix_object[&#34;sophistication&#34;]
        if &#34;sophistication&#34; in stix_object
        else None,
        resource_level=stix_object[&#34;resource_level&#34;]
        if &#34;resource_level&#34; in stix_object
        else None,
        primary_motivation=stix_object[&#34;primary_motivation&#34;]
        if &#34;primary_motivation&#34; in stix_object
        else None,
        secondary_motivation=stix_object[&#34;secondary_motivations&#34;]
        if &#34;secondary_motivations&#34; in stix_object
        else None,
        id=stix_object[CustomProperties.ID]
        if CustomProperties.ID in stix_object
        else None,
        stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
        created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
        modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
        createdByRef=extras[&#34;created_by_ref_id&#34;]
        if &#34;created_by_ref_id&#34; in extras
        else None,
        markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
        if &#34;marking_definitions_ids&#34; in extras
        else [],
        update=update,
    )</code></pre>
</details>
</dd>
<dt id="pycti.utils.opencti_stix2.OpenCTIStix2.create_malware"><code class="name flex">
<span>def <span class="ident">create_malware</span></span>(<span>self, stix_object, extras, update=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_malware(self, stix_object, extras, update=False):
    return self.opencti.malware.create(
        name=stix_object[&#34;name&#34;],
        description=self.convert_markdown(stix_object[&#34;description&#34;])
        if &#34;description&#34; in stix_object
        else &#34;&#34;,
        alias=self.pick_aliases(stix_object),
        id=stix_object[CustomProperties.ID]
        if CustomProperties.ID in stix_object
        else None,
        stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
        created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
        modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
        createdByRef=extras[&#34;created_by_ref_id&#34;]
        if &#34;created_by_ref_id&#34; in extras
        else None,
        markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
        if &#34;marking_definitions_ids&#34; in extras
        else [],
        killChainPhases=extras[&#34;kill_chain_phases_ids&#34;]
        if &#34;kill_chain_phases_ids&#34; in extras
        else [],
        update=update,
    )</code></pre>
</details>
</dd>
<dt id="pycti.utils.opencti_stix2.OpenCTIStix2.create_marking_definition"><code class="name flex">
<span>def <span class="ident">create_marking_definition</span></span>(<span>self, stix_object, extras, update=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_marking_definition(self, stix_object, extras, update=False):
    definition_type = stix_object[&#34;definition_type&#34;]
    definition = stix_object[&#34;definition&#34;][stix_object[&#34;definition_type&#34;]]
    if stix_object[&#34;definition_type&#34;] == &#34;tlp&#34;:
        definition_type = &#34;TLP&#34;
        definition = (
            &#34;TLP:&#34;
            + stix_object[&#34;definition&#34;][stix_object[&#34;definition_type&#34;]].upper()
        )
    return self.opencti.marking_definition.create(
        definition_type=definition_type,
        definition=definition,
        level=stix_object[CustomProperties.LEVEL]
        if CustomProperties.LEVEL in stix_object
        else 0,
        color=stix_object[CustomProperties.COLOR]
        if CustomProperties.COLOR in stix_object
        else None,
        id=stix_object[CustomProperties.ID]
        if CustomProperties.ID in stix_object
        else None,
        stix_id_key=stix_object[&#34;id&#34;],
        created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
        modified=stix_object[CustomProperties.MODIFIED]
        if CustomProperties.MODIFIED in stix_object
        else None,
        createdByRef=extras[&#34;created_by_ref_id&#34;]
        if &#34;created_by_ref_id&#34; in extras
        else None,
    )</code></pre>
</details>
</dd>
<dt id="pycti.utils.opencti_stix2.OpenCTIStix2.create_note"><code class="name flex">
<span>def <span class="ident">create_note</span></span>(<span>self, stix_object, extras, update=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_note(self, stix_object, extras, update=False):
    return self.opencti.note.import_from_stix2(
        stixObject=stix_object, extras=extras, update=update
    )</code></pre>
</details>
</dd>
<dt id="pycti.utils.opencti_stix2.OpenCTIStix2.create_opinion"><code class="name flex">
<span>def <span class="ident">create_opinion</span></span>(<span>self, stix_object, extras, update=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_opinion(self, stix_object, extras, update=False):
    return self.opencti.opinion.import_from_stix2(
        stixObject=stix_object, extras=extras, update=update
    )</code></pre>
</details>
</dd>
<dt id="pycti.utils.opencti_stix2.OpenCTIStix2.create_report"><code class="name flex">
<span>def <span class="ident">create_report</span></span>(<span>self, stix_object, extras, update=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_report(self, stix_object, extras, update=False):
    return self.opencti.report.import_from_stix2(
        stixObject=stix_object, extras=extras, update=update
    )</code></pre>
</details>
</dd>
<dt id="pycti.utils.opencti_stix2.OpenCTIStix2.create_threat_actor"><code class="name flex">
<span>def <span class="ident">create_threat_actor</span></span>(<span>self, stix_object, extras, update=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_threat_actor(self, stix_object, extras, update=False):
    return self.opencti.threat_actor.create(
        name=stix_object[&#34;name&#34;],
        description=self.convert_markdown(stix_object[&#34;description&#34;])
        if &#34;description&#34; in stix_object
        else &#34;&#34;,
        alias=self.pick_aliases(stix_object),
        goal=stix_object[&#34;goals&#34;] if &#34;goals&#34; in stix_object else None,
        sophistication=stix_object[&#34;sophistication&#34;]
        if &#34;sophistication&#34; in stix_object
        else None,
        resource_level=stix_object[&#34;resource_level&#34;]
        if &#34;resource_level&#34; in stix_object
        else None,
        primary_motivaton=stix_object[&#34;primary_motivation&#34;]
        if &#34;primary_motivation&#34; in stix_object
        else None,
        secondary_motivation=stix_object[&#34;secondary_motivations&#34;]
        if &#34;secondary_motivations&#34; in stix_object
        else None,
        personal_motivation=stix_object[&#34;personal_motivations&#34;]
        if &#34;personal_motivations&#34; in stix_object
        else None,
        id=stix_object[CustomProperties.ID]
        if CustomProperties.ID in stix_object
        else None,
        stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
        created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
        modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
        createdByRef=extras[&#34;created_by_ref_id&#34;]
        if &#34;created_by_ref_id&#34; in extras
        else None,
        markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
        if &#34;marking_definitions_ids&#34; in extras
        else [],
        update=update,
    )</code></pre>
</details>
</dd>
<dt id="pycti.utils.opencti_stix2.OpenCTIStix2.create_tool"><code class="name flex">
<span>def <span class="ident">create_tool</span></span>(<span>self, stix_object, extras, update=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_tool(self, stix_object, extras, update=False):
    return self.opencti.tool.create(
        name=stix_object[&#34;name&#34;],
        description=self.convert_markdown(stix_object[&#34;description&#34;])
        if &#34;description&#34; in stix_object
        else &#34;&#34;,
        alias=self.pick_aliases(stix_object),
        id=stix_object[CustomProperties.ID]
        if CustomProperties.ID in stix_object
        else None,
        stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
        created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
        modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
        createdByRef=extras[&#34;created_by_ref_id&#34;]
        if &#34;created_by_ref_id&#34; in extras
        else None,
        markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
        if &#34;marking_definitions_ids&#34; in extras
        else [],
        killChainPhases=extras[&#34;kill_chain_phases_ids&#34;]
        if &#34;kill_chain_phases_ids&#34; in extras
        else [],
        update=update,
    )</code></pre>
</details>
</dd>
<dt id="pycti.utils.opencti_stix2.OpenCTIStix2.create_vulnerability"><code class="name flex">
<span>def <span class="ident">create_vulnerability</span></span>(<span>self, stix_object, extras, update=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_vulnerability(self, stix_object, extras, update=False):
    return self.opencti.vulnerability.create(
        name=stix_object[&#34;name&#34;],
        description=self.convert_markdown(stix_object[&#34;description&#34;])
        if &#34;description&#34; in stix_object
        else &#34;&#34;,
        base_score=stix_object[CustomProperties.BASE_SCORE]
        if CustomProperties.BASE_SCORE in stix_object
        else None,
        base_severity=stix_object[CustomProperties.BASE_SEVERITY]
        if CustomProperties.BASE_SEVERITY in stix_object
        else None,
        attack_vector=stix_object[CustomProperties.ATTACK_VECTOR]
        if CustomProperties.ATTACK_VECTOR in stix_object
        else None,
        integrity_impact=stix_object[CustomProperties.INTEGRITY_IMPACT]
        if CustomProperties.INTEGRITY_IMPACT in stix_object
        else None,
        availability_impact=stix_object[CustomProperties.AVAILABILITY_IMPACT]
        if CustomProperties.AVAILABILITY_IMPACT in stix_object
        else None,
        alias=self.pick_aliases(stix_object),
        id=stix_object[CustomProperties.ID]
        if CustomProperties.ID in stix_object
        else None,
        stix_id_key=stix_object[&#34;id&#34;] if &#34;id&#34; in stix_object else None,
        created=stix_object[&#34;created&#34;] if &#34;created&#34; in stix_object else None,
        modified=stix_object[&#34;modified&#34;] if &#34;modified&#34; in stix_object else None,
        createdByRef=extras[&#34;created_by_ref_id&#34;]
        if &#34;created_by_ref_id&#34; in extras
        else None,
        markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
        if &#34;marking_definitions_ids&#34; in extras
        else [],
        update=update,
    )</code></pre>
</details>
</dd>
<dt id="pycti.utils.opencti_stix2.OpenCTIStix2.export_entity"><code class="name flex">
<span>def <span class="ident">export_entity</span></span>(<span>self, entity_type, entity_id, mode='simple', max_marking_definition=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_entity(
    self, entity_type, entity_id, mode=&#34;simple&#34;, max_marking_definition=None
):
    max_marking_definition_entity = (
        self.opencti.marking_definition.read(id=max_marking_definition)
        if max_marking_definition is not None
        else None
    )
    bundle = {
        &#34;type&#34;: &#34;bundle&#34;,
        &#34;id&#34;: &#34;bundle--&#34; + str(uuid.uuid4()),
        &#34;objects&#34;: [],
    }
    # Map types
    if IdentityTypes.has_value(entity_type):
        entity_type = &#34;identity&#34;

    # Export
    exporter = {
        &#34;identity&#34;: self.opencti.identity.to_stix2,
        &#34;threat-actor&#34;: self.opencti.threat_actor.to_stix2,
        &#34;intrusion-set&#34;: self.opencti.intrusion_set.to_stix2,
        &#34;campaign&#34;: self.opencti.campaign.to_stix2,
        &#34;incident&#34;: self.opencti.incident.to_stix2,
        &#34;malware&#34;: self.opencti.malware.to_stix2,
        &#34;tool&#34;: self.opencti.tool.to_stix2,
        &#34;vulnerability&#34;: self.opencti.vulnerability.to_stix2,
        &#34;attack-pattern&#34;: self.opencti.attack_pattern.to_stix2,
        &#34;course-of-action&#34;: self.opencti.course_of_action.to_stix2,
        &#34;report&#34;: self.opencti.report.to_stix2,
        &#34;note&#34;: self.opencti.note.to_stix2,
        &#34;opinion&#34;: self.opencti.opinion.to_stix2,
        &#34;indicator&#34;: self.opencti.indicator.to_stix2,
    }
    do_export = exporter.get(
        entity_type, lambda **kwargs: self.unknown_type({&#34;type&#34;: entity_type})
    )
    objects = do_export(
        id=entity_id,
        mode=mode,
        max_marking_definition_entity=max_marking_definition_entity,
    )
    if objects is not None:
        bundle[&#34;objects&#34;].extend(objects)
    return bundle</code></pre>
</details>
</dd>
<dt id="pycti.utils.opencti_stix2.OpenCTIStix2.export_list"><code class="name flex">
<span>def <span class="ident">export_list</span></span>(<span>self, entity_type, search=None, filters=None, order_by=None, order_mode=None, max_marking_definition=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_list(
    self,
    entity_type,
    search=None,
    filters=None,
    order_by=None,
    order_mode=None,
    max_marking_definition=None,
):
    max_marking_definition_entity = (
        self.opencti.marking_definition.read(id=max_marking_definition)
        if max_marking_definition is not None
        else None
    )
    bundle = {
        &#34;type&#34;: &#34;bundle&#34;,
        &#34;id&#34;: &#34;bundle--&#34; + str(uuid.uuid4()),
        &#34;objects&#34;: [],
    }

    if IdentityTypes.has_value(entity_type):
        if filters is not None:
            filters.append({&#34;key&#34;: &#34;entity_type&#34;, &#34;values&#34;: [entity_type]})
        else:
            filters = [{&#34;key&#34;: &#34;entity_type&#34;, &#34;values&#34;: [entity_type]}]
        entity_type = &#34;identity&#34;

    # List
    lister = {
        &#34;identity&#34;: self.opencti.identity.list,
        &#34;threat-actor&#34;: self.opencti.threat_actor.list,
        &#34;intrusion-set&#34;: self.opencti.intrusion_set.list,
        &#34;campaign&#34;: self.opencti.campaign.list,
        &#34;incident&#34;: self.opencti.incident.list,
        &#34;malware&#34;: self.opencti.malware.list,
        &#34;tool&#34;: self.opencti.tool.list,
        &#34;vulnerability&#34;: self.opencti.vulnerability.list,
        &#34;attack-pattern&#34;: self.opencti.attack_pattern.list,
        &#34;course-of-action&#34;: self.opencti.course_of_action.list,
        &#34;report&#34;: self.opencti.report.list,
        &#34;note&#34;: self.opencti.note.list,
        &#34;opinion&#34;: self.opencti.opinion.list,
        &#34;indicator&#34;: self.opencti.indicator.list,
    }
    do_list = lister.get(
        entity_type, lambda **kwargs: self.unknown_type({&#34;type&#34;: entity_type})
    )
    entities_list = do_list(
        search=search,
        filters=filters,
        orderBy=order_by,
        orderMode=order_mode,
        getAll=True,
    )

    if entities_list is not None:
        # Export
        exporter = {
            &#34;identity&#34;: self.opencti.identity.to_stix2,
            &#34;threat-actor&#34;: self.opencti.threat_actor.to_stix2,
            &#34;intrusion-set&#34;: self.opencti.intrusion_set.to_stix2,
            &#34;campaign&#34;: self.opencti.campaign.to_stix2,
            &#34;incident&#34;: self.opencti.incident.to_stix2,
            &#34;malware&#34;: self.opencti.malware.to_stix2,
            &#34;tool&#34;: self.opencti.tool.to_stix2,
            &#34;vulnerability&#34;: self.opencti.vulnerability.to_stix2,
            &#34;attack-pattern&#34;: self.opencti.attack_pattern.to_stix2,
            &#34;course-of-action&#34;: self.opencti.course_of_action.to_stix2,
            &#34;report&#34;: self.opencti.report.to_stix2,
            &#34;note&#34;: self.opencti.note.to_stix2,
            &#34;opinion&#34;: self.opencti.opinion.to_stix2,
            &#34;indicator&#34;: self.opencti.indicator.to_stix2,
        }
        do_export = exporter.get(
            entity_type, lambda **kwargs: self.unknown_type({&#34;type&#34;: entity_type})
        )
        uuids = []
        for entity in entities_list:
            entity_bundle = do_export(
                entity=entity,
                max_marking_definition_entity=max_marking_definition_entity,
            )
            if entity_bundle is not None:
                entity_bundle_filtered = self.filter_objects(uuids, entity_bundle)
                for x in entity_bundle_filtered:
                    uuids.append(x[&#34;id&#34;])
                bundle[&#34;objects&#34;] = bundle[&#34;objects&#34;] + entity_bundle_filtered

    return bundle</code></pre>
</details>
</dd>
<dt id="pycti.utils.opencti_stix2.OpenCTIStix2.export_stix_observables"><code class="name flex">
<span>def <span class="ident">export_stix_observables</span></span>(<span>self, entity)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_stix_observables(self, entity):
    stix_ids = []
    observed_data = dict()
    observed_data[&#34;id&#34;] = &#34;observed-data--&#34; + str(uuid.uuid4())
    observed_data[&#34;type&#34;] = &#34;observed-data&#34;
    observed_data[&#34;number_observed&#34;] = len(entity[&#34;observableRefs&#34;])
    observed_data[&#34;objects&#34;] = []
    for observable in entity[&#34;observableRefs&#34;]:
        stix_observable = dict()
        stix_observable[CustomProperties.OBSERVABLE_TYPE] = observable[
            &#34;entity_type&#34;
        ]
        stix_observable[CustomProperties.OBSERVABLE_VALUE] = observable[
            &#34;observable_value&#34;
        ]
        stix_observable[&#34;type&#34;] = observable[&#34;entity_type&#34;]
        observed_data[&#34;objects&#34;].append(stix_observable)
        stix_ids.append(observable[&#34;stix_id_key&#34;])

    return {&#34;observedData&#34;: observed_data, &#34;stixIds&#34;: stix_ids}</code></pre>
</details>
</dd>
<dt id="pycti.utils.opencti_stix2.OpenCTIStix2.extract_embedded_relationships"><code class="name flex">
<span>def <span class="ident">extract_embedded_relationships</span></span>(<span>self, stix_object, types=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_embedded_relationships(self, stix_object, types=None):
    # Created By Ref
    created_by_ref_id = None
    if &#34;created_by_ref&#34; in stix_object:
        created_by_ref = stix_object[&#34;created_by_ref&#34;]
        if created_by_ref in self.mapping_cache:
            created_by_ref_result = self.mapping_cache[created_by_ref]
        else:
            created_by_ref_result = self.opencti.stix_domain_entity.read(
                id=created_by_ref
            )
            if created_by_ref_result is not None:
                self.mapping_cache[created_by_ref] = {
                    &#34;id&#34;: created_by_ref_result[&#34;id&#34;],
                    &#34;type&#34;: created_by_ref_result[&#34;entity_type&#34;],
                }
        if created_by_ref_result is not None:
            created_by_ref_id = created_by_ref_result[&#34;id&#34;]

    # Object Marking Refs
    marking_definitions_ids = []
    if &#34;object_marking_refs&#34; in stix_object:
        for object_marking_ref in stix_object[&#34;object_marking_refs&#34;]:
            if object_marking_ref in self.mapping_cache:
                object_marking_ref_result = self.mapping_cache[object_marking_ref]
            else:
                object_marking_ref_result = self.opencti.marking_definition.read(
                    id=object_marking_ref
                )
                if object_marking_ref_result is not None:
                    self.mapping_cache[object_marking_ref] = {
                        &#34;id&#34;: object_marking_ref_result[&#34;id&#34;],
                        &#34;type&#34;: object_marking_ref_result[&#34;entity_type&#34;],
                    }
            if object_marking_ref_result is not None:
                marking_definitions_ids.append(object_marking_ref_result[&#34;id&#34;])

    # Object Tags
    tags_ids = []
    if CustomProperties.TAG_TYPE in stix_object:
        for tag in stix_object[CustomProperties.TAG_TYPE]:
            tag_result = None
            if &#34;id&#34; in tag:
                if tag[&#34;id&#34;] in self.mapping_cache:
                    tag_result = self.mapping_cache[tag[&#34;id&#34;]]
                else:
                    tag_result = self.opencti.tag.read(id=tag[&#34;id&#34;])
            if tag_result is not None:
                self.mapping_cache[tag[&#34;id&#34;]] = {&#34;id&#34;: tag_result[&#34;id&#34;]}
            else:
                tag_result = self.opencti.tag.create(
                    tag_type=tag[&#34;tag_type&#34;],
                    value=tag[&#34;value&#34;],
                    color=tag[&#34;color&#34;],
                    id=tag[&#34;id&#34;] if &#34;id&#34; in tag else None,
                )
            if tag_result is not None:
                tags_ids.append(tag_result[&#34;id&#34;])

    # Kill Chain Phases
    kill_chain_phases_ids = []
    if &#34;kill_chain_phases&#34; in stix_object:
        for kill_chain_phase in stix_object[&#34;kill_chain_phases&#34;]:
            if kill_chain_phase[&#34;phase_name&#34;] in self.mapping_cache:
                kill_chain_phase = self.mapping_cache[
                    kill_chain_phase[&#34;phase_name&#34;]
                ]
            else:
                kill_chain_phase = self.opencti.kill_chain_phase.create(
                    kill_chain_name=kill_chain_phase[&#34;kill_chain_name&#34;],
                    phase_name=kill_chain_phase[&#34;phase_name&#34;],
                    phase_order=kill_chain_phase[CustomProperties.PHASE_ORDER]
                    if CustomProperties.PHASE_ORDER in kill_chain_phase
                    else 0,
                    id=kill_chain_phase[CustomProperties.ID]
                    if CustomProperties.ID in kill_chain_phase
                    else None,
                    stix_id_key=kill_chain_phase[&#34;id&#34;]
                    if &#34;id&#34; in kill_chain_phase
                    else None,
                    created=kill_chain_phase[CustomProperties.CREATED]
                    if CustomProperties.CREATED in kill_chain_phase
                    else None,
                    modified=kill_chain_phase[CustomProperties.MODIFIED]
                    if CustomProperties.MODIFIED in kill_chain_phase
                    else None,
                )
                self.mapping_cache[kill_chain_phase[&#34;phase_name&#34;]] = {
                    &#34;id&#34;: kill_chain_phase[&#34;id&#34;],
                    &#34;type&#34;: kill_chain_phase[&#34;entity_type&#34;],
                }
            kill_chain_phases_ids.append(kill_chain_phase[&#34;id&#34;])

    # Object refs
    object_refs_ids = []
    if &#34;object_refs&#34; in stix_object:
        for object_ref in stix_object[&#34;object_refs&#34;]:
            object_ref_result = None
            if object_ref in self.mapping_cache:
                object_ref_result = self.mapping_cache[object_ref]
            elif &#34;relationship&#34; in object_ref:
                object_ref_result = self.opencti.stix_relation.read(id=object_ref)
                if object_ref_result is not None:
                    self.mapping_cache[object_ref] = {
                        &#34;id&#34;: object_ref_result[&#34;id&#34;],
                        &#34;type&#34;: object_ref_result[&#34;entity_type&#34;],
                    }
            elif &#34;observed-data&#34; not in object_ref:
                object_ref_result = self.opencti.stix_entity.read(id=object_ref)
                if object_ref_result is not None:
                    self.mapping_cache[object_ref] = {
                        &#34;id&#34;: object_ref_result[&#34;id&#34;],
                        &#34;type&#34;: object_ref_result[&#34;entity_type&#34;],
                    }
            if &#34;observed-data&#34; not in object_ref:
                if object_ref_result is not None:
                    object_refs_ids.append(object_ref_result[&#34;id&#34;])
            else:
                object_refs_ids.append(object_ref)

    # External References
    reports = {}
    external_references_ids = []
    if &#34;external_references&#34; in stix_object:
        for external_reference in stix_object[&#34;external_references&#34;]:
            if &#34;url&#34; in external_reference and &#34;source_name&#34; in external_reference:
                url = external_reference[&#34;url&#34;]
                source_name = external_reference[&#34;source_name&#34;]
            else:
                continue
            if url in self.mapping_cache:
                external_reference_id = self.mapping_cache[url][&#34;id&#34;]
            else:
                external_reference_id = self.opencti.external_reference.create(
                    source_name=source_name,
                    url=url,
                    external_id=external_reference[&#34;external_id&#34;]
                    if &#34;external_id&#34; in external_reference
                    else None,
                    description=external_reference[&#34;description&#34;]
                    if &#34;description&#34; in external_reference
                    else None,
                    id=external_reference[CustomProperties.ID]
                    if CustomProperties.ID in external_reference
                    else None,
                    stix_id_key=external_reference[&#34;id&#34;]
                    if &#34;id&#34; in external_reference
                    else None,
                    created=external_reference[CustomProperties.CREATED]
                    if CustomProperties.CREATED in external_reference
                    else None,
                    modified=external_reference[CustomProperties.MODIFIED]
                    if CustomProperties.MODIFIED in external_reference
                    else None,
                )[&#34;id&#34;]
            self.mapping_cache[url] = {&#34;id&#34;: external_reference_id}
            external_references_ids.append(external_reference_id)

            if stix_object[&#34;type&#34;] in [
                &#34;threat-actor&#34;,
                &#34;intrusion-set&#34;,
                &#34;campaign&#34;,
                &#34;incident&#34;,
                &#34;malware&#34;,
                &#34;relationship&#34;,
            ] and (types is None or &#34;report&#34; in types):
                # Add a corresponding report
                # Extract date
                try:
                    if &#34;description&#34; in external_reference:
                        matches = datefinder.find_dates(
                            external_reference[&#34;description&#34;]
                        )
                    else:
                        matches = datefinder.find_dates(source_name)
                except:
                    matches = None
                published = None
                today = datetime.datetime.today()
                if matches is not None:
                    for match in matches:
                        if match &lt; today:
                            published = match.strftime(&#34;%Y-%m-%dT%H:%M:%SZ&#34;)
                if published is None:
                    published = today.strftime(&#34;%Y-%m-%dT%H:%M:%SZ&#34;)

                if &#34;mitre&#34; in source_name and &#34;name&#34; in stix_object:
                    title = &#34;[MITRE ATT&amp;CK] &#34; + stix_object[&#34;name&#34;]
                    if &#34;modified&#34; in stix_object:
                        published = stix_object[&#34;modified&#34;]
                elif &#34;amitt&#34; in source_name and &#34;name&#34; in stix_object:
                    title = &#34;[AM!TT] &#34; + stix_object[&#34;name&#34;]
                    if &#34;modified&#34; in stix_object:
                        published = stix_object[&#34;modified&#34;]
                else:
                    title = source_name

                if &#34;external_id&#34; in external_reference:
                    title = title + &#34; (&#34; + external_reference[&#34;external_id&#34;] + &#34;)&#34;

                author = self.resolve_author(title)
                report = self.opencti.report.create(
                    name=title,
                    external_reference_id=external_reference_id,
                    description=external_reference[&#34;description&#34;]
                    if &#34;description&#34; in external_reference
                    else &#34;&#34;,
                    published=published,
                    report_class=&#34;Threat Report&#34;,
                    object_status=2,
                    createdByRef=author[&#34;id&#34;] if author is not None else None,
                    update=True,
                )
                # Add marking
                if &#34;marking_tlpwhite&#34; in self.mapping_cache:
                    object_marking_ref_result = self.mapping_cache[
                        &#34;marking_tlpwhite&#34;
                    ]
                else:
                    object_marking_ref_result = self.opencti.marking_definition.read(
                        filters=[
                            {&#34;key&#34;: &#34;definition_type&#34;, &#34;values&#34;: [&#34;TLP&#34;]},
                            {&#34;key&#34;: &#34;definition&#34;, &#34;values&#34;: [&#34;TLP:WHITE&#34;]},
                        ]
                    )
                if object_marking_ref_result is not None:
                    self.mapping_cache[&#34;marking_tlpwhite&#34;] = {
                        &#34;id&#34;: object_marking_ref_result[&#34;id&#34;]
                    }
                    self.opencti.stix_entity.add_marking_definition(
                        id=report[&#34;id&#34;],
                        marking_definition_id=object_marking_ref_result[&#34;id&#34;],
                    )

                # Add external reference to report
                self.opencti.stix_entity.add_external_reference(
                    id=report[&#34;id&#34;], external_reference_id=external_reference_id,
                )
                reports[external_reference_id] = report

    return {
        &#34;created_by_ref&#34;: created_by_ref_id,
        &#34;marking_definitions&#34;: marking_definitions_ids,
        &#34;tags&#34;: tags_ids,
        &#34;kill_chain_phases&#34;: kill_chain_phases_ids,
        &#34;object_refs&#34;: object_refs_ids,
        &#34;external_references&#34;: external_references_ids,
        &#34;reports&#34;: reports,
    }</code></pre>
</details>
</dd>
<dt id="pycti.utils.opencti_stix2.OpenCTIStix2.filter_objects"><code class="name flex">
<span>def <span class="ident">filter_objects</span></span>(<span>self, uuids, objects)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_objects(self, uuids, objects):
    result = []
    if objects is not None:
        for object in objects:
            if &#34;id&#34; in object and object[&#34;id&#34;] not in uuids:
                result.append(object)
    return result</code></pre>
</details>
</dd>
<dt id="pycti.utils.opencti_stix2.OpenCTIStix2.format_date"><code class="name flex">
<span>def <span class="ident">format_date</span></span>(<span>self, date)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format_date(self, date):
    if isinstance(date, datetime.date):
        return date.isoformat(timespec=&#34;milliseconds&#34;).replace(&#34;+00:00&#34;, &#34;Z&#34;)
    if date is not None:
        return (
            dateutil.parser.parse(date)
            .isoformat(timespec=&#34;milliseconds&#34;)
            .replace(&#34;+00:00&#34;, &#34;Z&#34;)
        )
    else:
        return (
            datetime.datetime.utcnow()
            .isoformat(timespec=&#34;milliseconds&#34;)
            .replace(&#34;+00:00&#34;, &#34;Z&#34;)
        )</code></pre>
</details>
</dd>
<dt id="pycti.utils.opencti_stix2.OpenCTIStix2.get_author"><code class="name flex">
<span>def <span class="ident">get_author</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_author(self, name):
    if name in self.mapping_cache:
        return self.mapping_cache[name]
    else:
        author = self.opencti.identity.create(
            type=&#34;Organization&#34;, name=name, description=&#34;&#34;,
        )
        self.mapping_cache[name] = author
        return author</code></pre>
</details>
</dd>
<dt id="pycti.utils.opencti_stix2.OpenCTIStix2.import_bundle"><code class="name flex">
<span>def <span class="ident">import_bundle</span></span>(<span>self, stix_bundle, update=False, types=None) ->List</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def import_bundle(self, stix_bundle, update=False, types=None) -&gt; List:
    if types is None:
        types = []

    # Check if the bundle is correctly formatted
    if &#34;type&#34; not in stix_bundle or stix_bundle[&#34;type&#34;] != &#34;bundle&#34;:
        raise ValueError(&#34;JSON data type is not a STIX2 bundle&#34;)
    if &#34;objects&#34; not in stix_bundle or len(stix_bundle[&#34;objects&#34;]) == 0:
        raise ValueError(&#34;JSON data objects is empty&#34;)

    # Import every elements in a specific order
    imported_elements = []

    # Marking definitions
    start_time = time.time()
    for item in stix_bundle[&#34;objects&#34;]:
        if item[&#34;type&#34;] == &#34;marking-definition&#34;:
            self.import_object(item, update, types)
            imported_elements.append({&#34;id&#34;: item[&#34;id&#34;], &#34;type&#34;: item[&#34;type&#34;]})
    end_time = time.time()
    self.opencti.log(
        &#34;info&#34;,
        &#34;Marking definitions imported in: %ssecs&#34; % round(end_time - start_time),
    )

    # Identities
    start_time = time.time()
    for item in stix_bundle[&#34;objects&#34;]:
        if item[&#34;type&#34;] == &#34;identity&#34; and (
            len(types) == 0
            or &#34;identity&#34; in types
            or (
                CustomProperties.IDENTITY_TYPE in item
                and item[CustomProperties.IDENTITY_TYPE] in types
            )
        ):
            self.import_object(item, update, types)
            imported_elements.append({&#34;id&#34;: item[&#34;id&#34;], &#34;type&#34;: item[&#34;type&#34;]})
    end_time = time.time()
    self.opencti.log(
        &#34;info&#34;, &#34;Identities imported in: %ssecs&#34; % round(end_time - start_time)
    )

    # StixDomainObjects except Report/Opinion/Notes
    start_time = time.time()
    for item in stix_bundle[&#34;objects&#34;]:
        if (
            item[&#34;type&#34;] != &#34;relationship&#34;
            and item[&#34;type&#34;] != &#34;report&#34;
            and item[&#34;type&#34;] != &#34;note&#34;
            and item[&#34;type&#34;] != &#34;opinion&#34;
            and item[&#34;type&#34;] != &#34;observed-data&#34;
            and (len(types) == 0 or item[&#34;type&#34;] in types)
        ):
            self.import_object(item, update, types)
            imported_elements.append({&#34;id&#34;: item[&#34;id&#34;], &#34;type&#34;: item[&#34;type&#34;]})
    end_time = time.time()
    self.opencti.log(
        &#34;info&#34;, &#34;Objects imported in: %ssecs&#34; % round(end_time - start_time)
    )

    # StixCyberObservables
    start_time = time.time()
    for item in stix_bundle[&#34;objects&#34;]:
        if item[&#34;type&#34;] == &#34;observed-data&#34; and (
            len(types) == 0 or &#34;observed-data&#34; in types
        ):
            self.import_observables(item)
    end_time = time.time()
    self.opencti.log(
        &#34;info&#34;, &#34;Observables imported in: %ssecs&#34; % round(end_time - start_time)
    )

    # StixRelationObjects
    start_time = time.time()
    for item in stix_bundle[&#34;objects&#34;]:
        if item[&#34;type&#34;] == &#34;relationship&#34;:
            # Import only relationships between entities
            if (
                CustomProperties.SOURCE_REF not in item
                or &#34;relationship&#34; not in item[CustomProperties.SOURCE_REF]
            ) and (
                CustomProperties.TARGET_REF not in item
                or &#34;relationship&#34; not in item[CustomProperties.TARGET_REF]
            ):
                source_ref = (
                    item[CustomProperties.SOURCE_REF]
                    if CustomProperties.SOURCE_REF in item
                    else item[&#34;source_ref&#34;]
                )
                target_ref = (
                    item[CustomProperties.TARGET_REF]
                    if CustomProperties.TARGET_REF in item
                    else item[&#34;target_ref&#34;]
                )
                if &#34;observed-data&#34; in source_ref:
                    if source_ref in self.mapping_cache:
                        for observable in self.mapping_cache[source_ref]:
                            item[CustomProperties.SOURCE_REF] = observable[&#34;id&#34;]
                            self.import_relationship(item, update, types)
                elif &#34;observed-data&#34; in target_ref:
                    if target_ref in self.mapping_cache:
                        for observable in self.mapping_cache[target_ref]:
                            item[CustomProperties.TARGET_REF] = observable[&#34;id&#34;]
                            self.import_relationship(item, update, types)
                else:
                    self.import_relationship(item, update, types)
                imported_elements.append({&#34;id&#34;: item[&#34;id&#34;], &#34;type&#34;: item[&#34;type&#34;]})
    end_time = time.time()
    self.opencti.log(
        &#34;info&#34;, &#34;Relationships imported in: %ssecs&#34; % round(end_time - start_time)
    )

    # StixRelationObjects (with relationships)
    start_time = time.time()
    for item in stix_bundle[&#34;objects&#34;]:
        if item[&#34;type&#34;] == &#34;relationship&#34;:
            if (
                CustomProperties.SOURCE_REF in item
                and &#34;relationship&#34; in item[CustomProperties.SOURCE_REF]
            ) or (
                CustomProperties.TARGET_REF in item
                and &#34;relationship&#34; in item[CustomProperties.TARGET_REF]
            ):
                self.import_relationship(item, update, types)
                imported_elements.append({&#34;id&#34;: item[&#34;id&#34;], &#34;type&#34;: item[&#34;type&#34;]})
    end_time = time.time()
    self.opencti.log(
        &#34;info&#34;,
        &#34;Relationships to relationships imported in: %ssecs&#34;
        % round(end_time - start_time),
    )

    # Reports
    start_time = time.time()
    for item in stix_bundle[&#34;objects&#34;]:
        if item[&#34;type&#34;] == &#34;report&#34; and (len(types) == 0 or &#34;report&#34; in types):
            self.import_object(item, update, types)
            imported_elements.append({&#34;id&#34;: item[&#34;id&#34;], &#34;type&#34;: item[&#34;type&#34;]})
    end_time = time.time()
    self.opencti.log(
        &#34;info&#34;, &#34;Reports imported in: %ssecs&#34; % round(end_time - start_time)
    )

    # Notes
    start_time = time.time()
    for item in stix_bundle[&#34;objects&#34;]:
        if item[&#34;type&#34;] == &#34;note&#34; and (len(types) == 0 or &#34;note&#34; in types):
            self.import_object(item, update, types)
            imported_elements.append({&#34;id&#34;: item[&#34;id&#34;], &#34;type&#34;: item[&#34;type&#34;]})
    end_time = time.time()
    self.opencti.log(
        &#34;info&#34;, &#34;Notes imported in: %ssecs&#34; % round(end_time - start_time)
    )

    # Opinions
    start_time = time.time()
    for item in stix_bundle[&#34;objects&#34;]:
        if item[&#34;type&#34;] == &#34;opinion&#34; and (len(types) == 0 or &#34;opinion&#34; in types):
            self.import_object(item, update, types)
            imported_elements.append({&#34;id&#34;: item[&#34;id&#34;], &#34;type&#34;: item[&#34;type&#34;]})
    end_time = time.time()
    self.opencti.log(
        &#34;info&#34;, &#34;Opinions imported in: %ssecs&#34; % round(end_time - start_time)
    )
    return imported_elements</code></pre>
</details>
</dd>
<dt id="pycti.utils.opencti_stix2.OpenCTIStix2.import_bundle_from_file"><code class="name flex">
<span>def <span class="ident">import_bundle_from_file</span></span>(<span>self, file_path, update=False, types=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def import_bundle_from_file(self, file_path, update=False, types=None):
    if types is None:
        types = []
    if not os.path.isfile(file_path):
        self.opencti.log(&#34;error&#34;, &#34;The bundle file does not exists&#34;)
        return None

    with open(os.path.join(file_path)) as file:
        data = json.load(file)

    return self.import_bundle(data, update, types)</code></pre>
</details>
</dd>
<dt id="pycti.utils.opencti_stix2.OpenCTIStix2.import_bundle_from_json"><code class="name flex">
<span>def <span class="ident">import_bundle_from_json</span></span>(<span>self, json_data, update=False, types=None) ->List</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def import_bundle_from_json(self, json_data, update=False, types=None) -&gt; List:
    if types is None:
        types = []
    data = json.loads(json_data)
    return self.import_bundle(data, update, types)</code></pre>
</details>
</dd>
<dt id="pycti.utils.opencti_stix2.OpenCTIStix2.import_object"><code class="name flex">
<span>def <span class="ident">import_object</span></span>(<span>self, stix_object, update=False, types=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def import_object(self, stix_object, update=False, types=None):
    self.opencti.log(
        &#34;info&#34;,
        &#34;Importing a &#34; + stix_object[&#34;type&#34;] + &#34; (id: &#34; + stix_object[&#34;id&#34;] + &#34;)&#34;,
    )

    # Extract
    embedded_relationships = self.extract_embedded_relationships(stix_object, types)
    created_by_ref_id = embedded_relationships[&#34;created_by_ref&#34;]
    marking_definitions_ids = embedded_relationships[&#34;marking_definitions&#34;]
    tags_ids = embedded_relationships[&#34;tags&#34;]
    kill_chain_phases_ids = embedded_relationships[&#34;kill_chain_phases&#34;]
    object_refs_ids = embedded_relationships[&#34;object_refs&#34;]
    external_references_ids = embedded_relationships[&#34;external_references&#34;]
    reports = embedded_relationships[&#34;reports&#34;]

    # Extra
    extras = {
        &#34;created_by_ref_id&#34;: created_by_ref_id,
        &#34;marking_definitions_ids&#34;: marking_definitions_ids,
        &#34;tags_ids&#34;: tags_ids,
        &#34;kill_chain_phases_ids&#34;: kill_chain_phases_ids,
        &#34;object_refs_ids&#34;: object_refs_ids,
        &#34;external_references_ids&#34;: external_references_ids,
        &#34;reports&#34;: reports,
    }

    # Import
    importer = {
        &#34;marking-definition&#34;: self.create_marking_definition,
        &#34;identity&#34;: self.create_identity,
        &#34;threat-actor&#34;: self.create_threat_actor,
        &#34;intrusion-set&#34;: self.create_intrusion_set,
        &#34;campaign&#34;: self.create_campaign,
        &#34;x-opencti-incident&#34;: self.create_incident,
        &#34;malware&#34;: self.create_malware,
        &#34;tool&#34;: self.create_tool,
        &#34;vulnerability&#34;: self.create_vulnerability,
        &#34;attack-pattern&#34;: self.create_attack_pattern,
        &#34;course-of-action&#34;: self.create_course_of_action,
        &#34;report&#34;: self.create_report,
        &#34;note&#34;: self.create_note,
        &#34;opinion&#34;: self.create_opinion,
        &#34;indicator&#34;: self.create_indicator,
    }
    do_import = importer.get(
        stix_object[&#34;type&#34;],
        lambda stix_object, extras, update: self.unknown_type(stix_object),
    )
    stix_object_results = do_import(stix_object, extras, update)

    if stix_object_results is None:
        return stix_object_results

    if not isinstance(stix_object_results, list):
        stix_object_results = [stix_object_results]

    for stix_object_result in stix_object_results:
        # Add embedded relationships
        self.mapping_cache[stix_object[&#34;id&#34;]] = {
            &#34;id&#34;: stix_object_result[&#34;id&#34;],
            &#34;type&#34;: stix_object_result[&#34;entity_type&#34;],
            &#34;observableRefs&#34;: stix_object_result[&#34;observableRefs&#34;]
            if &#34;observableRefs&#34; in stix_object_result
            else [],
        }
        self.mapping_cache[stix_object_result[&#34;id&#34;]] = {
            &#34;id&#34;: stix_object_result[&#34;id&#34;],
            &#34;type&#34;: stix_object_result[&#34;entity_type&#34;],
            &#34;observableRefs&#34;: stix_object_result[&#34;observableRefs&#34;]
            if &#34;observableRefs&#34; in stix_object_result
            else [],
        }

        # Add tags
        for tag_id in tags_ids:
            self.opencti.stix_entity.add_tag(
                id=stix_object_result[&#34;id&#34;], tag_id=tag_id,
            )
        # Add external references
        for external_reference_id in external_references_ids:
            self.opencti.stix_entity.add_external_reference(
                id=stix_object_result[&#34;id&#34;],
                external_reference_id=external_reference_id,
            )
            if external_reference_id in reports:
                self.opencti.report.add_stix_entity(
                    id=reports[external_reference_id][&#34;id&#34;],
                    entity_id=stix_object_result[&#34;id&#34;],
                )
        # Add object refs
        for object_refs_id in object_refs_ids:
            if &#34;observed-data&#34; in object_refs_id:
                if object_refs_id in self.mapping_cache:
                    for observable in self.mapping_cache[object_refs_id]:
                        if stix_object_result[&#34;entity_type&#34;] == &#34;report&#34;:
                            self.opencti.report.add_stix_observable(
                                id=stix_object_result[&#34;id&#34;],
                                stix_observable_id=observable[&#34;id&#34;],
                            )
                        elif stix_object_result[&#34;entity_type&#34;] == &#34;note&#34;:
                            self.opencti.note.add_stix_observable(
                                id=stix_object_result[&#34;id&#34;],
                                stix_observable_id=observable[&#34;id&#34;],
                            )
                        elif stix_object_result[&#34;entity_type&#34;] == &#34;opinion&#34;:
                            self.opencti.opinion.add_stix_observable(
                                id=stix_object_result[&#34;id&#34;],
                                stix_observable_id=observable[&#34;id&#34;],
                            )
            else:
                if stix_object_result[&#34;entity_type&#34;] == &#34;report&#34;:
                    self.opencti.report.add_stix_entity(
                        id=stix_object_result[&#34;id&#34;], entity_id=object_refs_id,
                    )
                elif stix_object_result[&#34;entity_type&#34;] == &#34;note&#34;:
                    self.opencti.note.add_stix_entity(
                        id=stix_object_result[&#34;id&#34;], entity_id=object_refs_id,
                    )
                elif stix_object_result[&#34;entity_type&#34;] == &#34;opinion&#34;:
                    self.opencti.opinion.add_stix_entity(
                        id=stix_object_result[&#34;id&#34;], entity_id=object_refs_id,
                    )
                if (
                    object_refs_id in self.mapping_cache
                    and &#34;observableRefs&#34; in self.mapping_cache[object_refs_id]
                    and self.mapping_cache[object_refs_id] is not None
                    and self.mapping_cache[object_refs_id][&#34;observableRefs&#34;]
                    is not None
                    and len(self.mapping_cache[object_refs_id][&#34;observableRefs&#34;])
                    &gt; 0
                ):
                    for observable_ref in self.mapping_cache[object_refs_id][
                        &#34;observableRefs&#34;
                    ]:
                        if stix_object_result[&#34;entity_type&#34;] == &#34;report&#34;:
                            self.opencti.report.add_stix_observable(
                                id=stix_object_result[&#34;id&#34;],
                                stix_observable_id=observable_ref[&#34;id&#34;],
                            )
                        elif stix_object_result[&#34;entity_type&#34;] == &#34;note&#34;:
                            self.opencti.note.add_stix_observable(
                                id=stix_object_result[&#34;id&#34;],
                                stix_observable_id=observable_ref[&#34;id&#34;],
                            )
                        elif stix_object_result[&#34;entity_type&#34;] == &#34;opinion&#34;:
                            self.opencti.opinion.add_stix_observable(
                                id=stix_object_result[&#34;id&#34;],
                                stix_observable_id=observable_ref[&#34;id&#34;],
                            )
        # Add files
        if CustomProperties.FILES in stix_object:
            for file in stix_object[CustomProperties.FILES]:
                self.opencti.stix_domain_entity.add_file(
                    id=stix_object_result[&#34;id&#34;],
                    file_name=file[&#34;name&#34;],
                    data=base64.b64decode(file[&#34;data&#34;]),
                    mime_type=file[&#34;mime_type&#34;],
                )

    return stix_object_results</code></pre>
</details>
</dd>
<dt id="pycti.utils.opencti_stix2.OpenCTIStix2.import_observables"><code class="name flex">
<span>def <span class="ident">import_observables</span></span>(<span>self, stix_object)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def import_observables(self, stix_object):
    # Extract
    embedded_relationships = self.extract_embedded_relationships(stix_object)
    created_by_ref_id = embedded_relationships[&#34;created_by_ref&#34;]
    marking_definitions_ids = embedded_relationships[&#34;marking_definitions&#34;]

    observables_to_create = {}
    relations_to_create = []
    for key, observable_item in stix_object[&#34;objects&#34;].items():
        # TODO artifact
        if (
            CustomProperties.OBSERVABLE_TYPE in observable_item
            and CustomProperties.OBSERVABLE_VALUE in observable_item
        ):
            observables_to_create[key] = [
                {
                    &#34;id&#34;: str(uuid.uuid4()),
                    &#34;stix_id&#34;: &#34;observable--&#34; + str(uuid.uuid4()),
                    &#34;type&#34;: observable_item[CustomProperties.OBSERVABLE_TYPE],
                    &#34;value&#34;: observable_item[CustomProperties.OBSERVABLE_VALUE],
                }
            ]
        elif observable_item[&#34;type&#34;] == &#34;autonomous-system&#34;:
            observables_to_create[key] = [
                {
                    &#34;id&#34;: str(uuid.uuid4()),
                    &#34;stix_id&#34;: &#34;observable--&#34; + str(uuid.uuid4()),
                    &#34;type&#34;: ObservableTypes.AUTONOMOUS_SYSTEM.value,
                    &#34;value&#34;: &#34;AS&#34; + observable_item[&#34;number&#34;],
                }
            ]
        elif observable_item[&#34;type&#34;] == &#34;directory&#34;:
            observables_to_create[key] = [
                {
                    &#34;id&#34;: str(uuid.uuid4()),
                    &#34;stix_id&#34;: &#34;observable--&#34; + str(uuid.uuid4()),
                    &#34;type&#34;: ObservableTypes.DIRECTORY.value,
                    &#34;value&#34;: observable_item[&#34;path&#34;],
                }
            ]
        elif observable_item[&#34;type&#34;] == &#34;domain-name&#34;:
            observables_to_create[key] = [
                {
                    &#34;id&#34;: str(uuid.uuid4()),
                    &#34;stix_id&#34;: &#34;observable--&#34; + str(uuid.uuid4()),
                    &#34;type&#34;: ObservableTypes.DOMAIN.value,
                    &#34;value&#34;: observable_item[&#34;value&#34;],
                }
            ]
        elif observable_item[&#34;type&#34;] == &#34;email-addr&#34;:
            observables_to_create[key] = [
                {
                    &#34;id&#34;: str(uuid.uuid4()),
                    &#34;stix_id&#34;: &#34;observable--&#34; + str(uuid.uuid4()),
                    &#34;type&#34;: ObservableTypes.EMAIL_ADDR.value,
                    &#34;value&#34;: observable_item[&#34;value&#34;],
                }
            ]
            # TODO Belongs to ref
        # TODO email-message
        # TODO mime-part-type
        elif observable_item[&#34;type&#34;] == &#34;file&#34;:
            observables_to_create[key] = []
            if &#34;name&#34; in observable_item:
                observables_to_create[key].append(
                    {
                        &#34;id&#34;: str(uuid.uuid4()),
                        &#34;type&#34;: ObservableTypes.FILE_NAME.value,
                        &#34;value&#34;: observable_item[&#34;name&#34;],
                    }
                )
            if &#34;hashes&#34; in observable_item:
                for keyfile, value in observable_item[&#34;hashes&#34;].items():
                    if keyfile == &#34;MD5&#34;:
                        observables_to_create[key].append(
                            {
                                &#34;id&#34;: str(uuid.uuid4()),
                                &#34;type&#34;: ObservableTypes.FILE_HASH_MD5.value,
                                &#34;value&#34;: value,
                            }
                        )
                    if keyfile == &#34;SHA-1&#34;:
                        observables_to_create[key].append(
                            {
                                &#34;id&#34;: str(uuid.uuid4()),
                                &#34;type&#34;: ObservableTypes.FILE_HASH_SHA1.value,
                                &#34;value&#34;: value,
                            }
                        )
                    if keyfile == &#34;SHA-256&#34;:
                        observables_to_create[key].append(
                            {
                                &#34;id&#34;: str(uuid.uuid4()),
                                &#34;type&#34;: ObservableTypes.FILE_HASH_SHA256.value,
                                &#34;value&#34;: value,
                            }
                        )
        elif observable_item[&#34;type&#34;] == &#34;ipv4-addr&#34;:
            observables_to_create[key] = [
                {
                    &#34;id&#34;: str(uuid.uuid4()),
                    &#34;type&#34;: ObservableTypes.IPV4_ADDR.value,
                    &#34;value&#34;: observable_item[&#34;value&#34;],
                }
            ]
        elif observable_item[&#34;type&#34;] == &#34;ipv6-addr&#34;:
            observables_to_create[key] = [
                {
                    &#34;id&#34;: str(uuid.uuid4()),
                    &#34;type&#34;: ObservableTypes.IPV6_ADDR.value,
                    &#34;value&#34;: observable_item[&#34;value&#34;],
                }
            ]
        elif observable_item[&#34;type&#34;] == &#34;mac-addr&#34;:
            observables_to_create[key] = [
                {
                    &#34;id&#34;: str(uuid.uuid4()),
                    &#34;type&#34;: ObservableTypes.MAC_ADDR.value,
                    &#34;value&#34;: observable_item[&#34;value&#34;],
                }
            ]
        elif observable_item[&#34;type&#34;] == &#34;windows-registry-key&#34;:
            observables_to_create[key] = [
                {
                    &#34;id&#34;: str(uuid.uuid4()),
                    &#34;type&#34;: ObservableTypes.REGISTRY_KEY.value,
                    &#34;value&#34;: observable_item[&#34;key&#34;],
                }
            ]

    for key, observable_item in stix_object[&#34;objects&#34;].items():
        if observable_item[&#34;type&#34;] == &#34;directory&#34;:
            if &#34;contains_refs&#34; in observable_item:
                for file in observable_item[&#34;contains_refs&#34;]:
                    for observable_to_create_from in observables_to_create[key]:
                        for observables_to_create_to in observables_to_create[file]:
                            if (
                                observable_to_create_from[&#34;id&#34;]
                                != observables_to_create_to[&#34;id&#34;]
                            ):
                                relations_to_create.append(
                                    {
                                        &#34;id&#34;: str(uuid.uuid4()),
                                        &#34;from&#34;: observable_to_create_from[&#34;id&#34;],
                                        &#34;to&#34;: observables_to_create_to[&#34;id&#34;],
                                        &#34;type&#34;: &#34;contains&#34;,
                                    }
                                )
        if observable_item[&#34;type&#34;] == &#34;domain-name&#34;:
            if &#34;resolves_to_refs&#34; in observable_item:
                for resolved in observable_item[&#34;resolves_to_refs&#34;]:
                    for observable_to_create_from in observables_to_create[key]:
                        for observables_to_create_to in observables_to_create[
                            resolved
                        ]:
                            if (
                                observable_to_create_from[&#34;id&#34;]
                                != observables_to_create_to[&#34;id&#34;]
                            ):
                                relations_to_create.append(
                                    {
                                        &#34;id&#34;: str(uuid.uuid4()),
                                        &#34;from&#34;: observable_to_create_from[&#34;id&#34;],
                                        &#34;fromType&#34;: observable_to_create_from[
                                            &#34;type&#34;
                                        ],
                                        &#34;to&#34;: observables_to_create_to[&#34;id&#34;],
                                        &#34;toType&#34;: observables_to_create_to[&#34;type&#34;],
                                        &#34;type&#34;: &#34;resolves&#34;,
                                    }
                                )
        if observable_item[&#34;type&#34;] == &#34;file&#34;:
            for observable_to_create_from in observables_to_create[key]:
                for observables_to_create_to in observables_to_create[key]:
                    if (
                        observable_to_create_from[&#34;id&#34;]
                        != observables_to_create_to[&#34;id&#34;]
                    ):
                        relations_to_create.append(
                            {
                                &#34;id&#34;: str(uuid.uuid4()),
                                &#34;from&#34;: observable_to_create_from[&#34;id&#34;],
                                &#34;fromType&#34;: observable_to_create_from[&#34;type&#34;],
                                &#34;to&#34;: observables_to_create_to[&#34;id&#34;],
                                &#34;toType&#34;: observables_to_create_to[&#34;type&#34;],
                                &#34;type&#34;: &#34;corresponds&#34;,
                            }
                        )
        if observable_item[&#34;type&#34;] == &#34;ipv4-addr&#34;:
            if &#34;belongs_to_refs&#34; in observable_item:
                for belonging in observable_item[&#34;belongs_to_refs&#34;]:
                    for observable_to_create_from in observables_to_create[key]:
                        for observables_to_create_to in observables_to_create[
                            belonging
                        ]:
                            if (
                                observable_to_create_from[&#34;id&#34;]
                                != observables_to_create_to[&#34;id&#34;]
                            ):
                                relations_to_create.append(
                                    {
                                        &#34;id&#34;: str(uuid.uuid4()),
                                        &#34;from&#34;: observable_to_create_from[&#34;id&#34;],
                                        &#34;fromType&#34;: observable_to_create_from[
                                            &#34;type&#34;
                                        ],
                                        &#34;to&#34;: observables_to_create_to[&#34;id&#34;],
                                        &#34;toType&#34;: observables_to_create_to[&#34;type&#34;],
                                        &#34;type&#34;: &#34;belongs&#34;,
                                    }
                                )

    stix_observables_mapping = {}
    self.mapping_cache[stix_object[&#34;id&#34;]] = []
    for key, observable_to_create in observables_to_create.items():
        for observable in observable_to_create:
            observable_result = self.opencti.stix_observable.create(
                type=observable[&#34;type&#34;],
                observable_value=observable[&#34;value&#34;],
                id=observable[&#34;id&#34;],
                createdByRef=created_by_ref_id,
                markingDefinitions=marking_definitions_ids,
                createIndicator=stix_object[CustomProperties.CREATE_INDICATOR]
                if CustomProperties.CREATE_INDICATOR in stix_object
                else False,
            )
            stix_observables_mapping[observable[&#34;id&#34;]] = observable_result[&#34;id&#34;]
            self.mapping_cache[stix_object[&#34;id&#34;]].append(
                {
                    &#34;id&#34;: observable_result[&#34;id&#34;],
                    &#34;type&#34;: observable_result[&#34;entity_type&#34;],
                }
            )

    stix_observable_relations_mapping = {}
    for relation_to_create in relations_to_create:
        stix_observable_relation_result = self.opencti.stix_observable_relation.create(
            fromId=stix_observables_mapping[relation_to_create[&#34;from&#34;]],
            fromType=relation_to_create[&#34;fromType&#34;],
            toId=stix_observables_mapping[relation_to_create[&#34;to&#34;]],
            toType=relation_to_create[&#34;toType&#34;],
            relationship_type=relation_to_create[&#34;type&#34;],
            createdByRef=created_by_ref_id,
            markingDefinitions=marking_definitions_ids,
        )
        stix_observable_relations_mapping[
            relation_to_create[&#34;id&#34;]
        ] = stix_observable_relation_result[&#34;id&#34;]</code></pre>
</details>
</dd>
<dt id="pycti.utils.opencti_stix2.OpenCTIStix2.import_relationship"><code class="name flex">
<span>def <span class="ident">import_relationship</span></span>(<span>self, stix_relation, update=False, types=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def import_relationship(self, stix_relation, update=False, types=None):
    # Extract
    embedded_relationships = self.extract_embedded_relationships(
        stix_relation, types
    )
    created_by_ref_id = embedded_relationships[&#34;created_by_ref&#34;]
    marking_definitions_ids = embedded_relationships[&#34;marking_definitions&#34;]
    kill_chain_phases_ids = embedded_relationships[&#34;kill_chain_phases&#34;]
    external_references_ids = embedded_relationships[&#34;external_references&#34;]
    reports = embedded_relationships[&#34;reports&#34;]

    # Extra
    extras = {
        &#34;created_by_ref_id&#34;: created_by_ref_id,
        &#34;marking_definitions_ids&#34;: marking_definitions_ids,
        &#34;kill_chain_phases_ids&#34;: kill_chain_phases_ids,
        &#34;external_references_ids&#34;: external_references_ids,
        &#34;reports&#34;: reports,
    }

    # Create the relation

    ### Get the SOURCE_REF
    if CustomProperties.SOURCE_REF in stix_relation:
        source_ref = stix_relation[CustomProperties.SOURCE_REF]
    else:
        source_ref = stix_relation[&#34;source_ref&#34;]
    if source_ref in self.mapping_cache:
        if (
            StixObservableRelationTypes.has_value(
                stix_relation[&#34;relationship_type&#34;]
            )
            and &#34;observableRefs&#34; in self.mapping_cache[source_ref]
            and self.mapping_cache[source_ref][&#34;observableRefs&#34;] is not None
            and len(self.mapping_cache[source_ref][&#34;observableRefs&#34;]) &gt; 0
        ):
            source_id = self.mapping_cache[source_ref][&#34;observableRefs&#34;][0][&#34;id&#34;]
            source_type = self.mapping_cache[source_ref][&#34;observableRefs&#34;][0][
                &#34;entity_type&#34;
            ]
        else:
            source_id = self.mapping_cache[source_ref][&#34;id&#34;]
            source_type = self.mapping_cache[source_ref][&#34;type&#34;]
    else:
        stix_object_result = self.opencti.stix_entity.read(id=source_ref)
        if stix_object_result is not None:
            source_id = stix_object_result[&#34;id&#34;]
            source_type = stix_object_result[&#34;entity_type&#34;]
        else:
            self.opencti.log(
                &#34;error&#34;,
                &#34;Source ref of the relationship not found, doing nothing...&#34;,
            )
            return None

    ### Get the TARGET_REF
    if CustomProperties.TARGET_REF in stix_relation:
        target_ref = stix_relation[CustomProperties.TARGET_REF]
    else:
        target_ref = stix_relation[&#34;target_ref&#34;]
    if target_ref in self.mapping_cache:
        if (
            StixObservableRelationTypes.has_value(
                stix_relation[&#34;relationship_type&#34;]
            )
            and &#34;observableRefs&#34; in self.mapping_cache[target_ref]
            and self.mapping_cache[target_ref][&#34;observableRefs&#34;] is not None
            and len(self.mapping_cache[target_ref][&#34;observableRefs&#34;]) &gt; 0
        ):
            target_id = self.mapping_cache[target_ref][&#34;observableRefs&#34;][0][&#34;id&#34;]
            target_type = self.mapping_cache[target_ref][&#34;observableRefs&#34;][0][
                &#34;entity_type&#34;
            ]
        else:
            target_id = self.mapping_cache[target_ref][&#34;id&#34;]
            target_type = self.mapping_cache[target_ref][&#34;type&#34;]
    else:
        stix_object_result = self.opencti.stix_entity.read(id=target_ref)
        if stix_object_result is not None:
            target_id = stix_object_result[&#34;id&#34;]
            target_type = stix_object_result[&#34;entity_type&#34;]
        else:
            self.opencti.log(
                &#34;error&#34;,
                &#34;Target ref of the relationship not found, doing nothing...&#34;,
            )
            return None

    date = None
    if &#34;external_references&#34; in stix_relation:
        for external_reference in stix_relation[&#34;external_references&#34;]:
            try:
                if &#34;description&#34; in external_reference:
                    matches = datefinder.find_dates(
                        external_reference[&#34;description&#34;]
                    )
                else:
                    matches = datefinder.find_dates(
                        external_reference[&#34;source_name&#34;]
                    )
            except:
                matches = None
            date = None
            today = datetime.datetime.today()
            if matches is not None:
                for match in matches:
                    if match &lt; today:
                        date = match.strftime(&#34;%Y-%m-%dT%H:%M:%SZ&#34;)
    if date is None:
        date = datetime.datetime.today().strftime(&#34;%Y-%m-%dT%H:%M:%SZ&#34;)

    stix_relation_result = None
    if StixObservableRelationTypes.has_value(stix_relation[&#34;relationship_type&#34;]):
        stix_relation_result = self.opencti.stix_observable_relation.create(
            fromId=source_id,
            fromType=source_type,
            toId=target_id,
            toType=target_type,
            relationship_type=stix_relation[&#34;relationship_type&#34;],
            description=self.convert_markdown(stix_relation[&#34;description&#34;])
            if &#34;description&#34; in stix_relation
            else None,
            first_seen=stix_relation[CustomProperties.FIRST_SEEN]
            if CustomProperties.FIRST_SEEN in stix_relation
            else date,
            last_seen=stix_relation[CustomProperties.LAST_SEEN]
            if CustomProperties.LAST_SEEN in stix_relation
            else date,
            weight=stix_relation[CustomProperties.WEIGHT]
            if CustomProperties.WEIGHT in stix_relation
            else 1,
            role_played=stix_relation[CustomProperties.ROLE_PLAYED]
            if CustomProperties.ROLE_PLAYED in stix_relation
            else None,
            id=stix_relation[CustomProperties.ID]
            if CustomProperties.ID in stix_relation
            else None,
            stix_id_key=stix_relation[&#34;id&#34;] if &#34;id&#34; in stix_relation else None,
            created=stix_relation[&#34;created&#34;]
            if &#34;created&#34; in stix_relation
            else None,
            modified=stix_relation[&#34;modified&#34;]
            if &#34;modified&#34; in stix_relation
            else None,
            createdByRef=extras[&#34;created_by_ref_id&#34;]
            if &#34;created_by_ref_id&#34; in extras
            else None,
            markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
            if &#34;marking_definitions_ids&#34; in extras
            else [],
            killChainPhases=extras[&#34;kill_chain_phases_ids&#34;]
            if &#34;kill_chain_phases_ids&#34; in extras
            else [],
            update=update,
            ignore_dates=stix_relation[CustomProperties.IGNORE_DATES]
            if CustomProperties.IGNORE_DATES in stix_relation
            else None,
        )
    else:
        stix_relation_result = self.opencti.stix_relation.create(
            fromId=source_id,
            fromType=source_type,
            toId=target_id,
            toType=target_type,
            relationship_type=stix_relation[&#34;relationship_type&#34;],
            description=self.convert_markdown(stix_relation[&#34;description&#34;])
            if &#34;description&#34; in stix_relation
            else None,
            first_seen=stix_relation[CustomProperties.FIRST_SEEN]
            if CustomProperties.FIRST_SEEN in stix_relation
            else date,
            last_seen=stix_relation[CustomProperties.LAST_SEEN]
            if CustomProperties.LAST_SEEN in stix_relation
            else date,
            weight=stix_relation[CustomProperties.WEIGHT]
            if CustomProperties.WEIGHT in stix_relation
            else 1,
            role_played=stix_relation[CustomProperties.ROLE_PLAYED]
            if CustomProperties.ROLE_PLAYED in stix_relation
            else None,
            id=stix_relation[CustomProperties.ID]
            if CustomProperties.ID in stix_relation
            else None,
            stix_id_key=stix_relation[&#34;id&#34;] if &#34;id&#34; in stix_relation else None,
            created=stix_relation[&#34;created&#34;]
            if &#34;created&#34; in stix_relation
            else None,
            modified=stix_relation[&#34;modified&#34;]
            if &#34;modified&#34; in stix_relation
            else None,
            createdByRef=extras[&#34;created_by_ref_id&#34;]
            if &#34;created_by_ref_id&#34; in extras
            else None,
            markingDefinitions=extras[&#34;marking_definitions_ids&#34;]
            if &#34;marking_definitions_ids&#34; in extras
            else [],
            killChainPhases=extras[&#34;kill_chain_phases_ids&#34;]
            if &#34;kill_chain_phases_ids&#34; in extras
            else [],
            update=update,
            ignore_dates=stix_relation[CustomProperties.IGNORE_DATES]
            if CustomProperties.IGNORE_DATES in stix_relation
            else None,
        )
    if stix_relation_result is not None:
        self.mapping_cache[stix_relation[&#34;id&#34;]] = {
            &#34;id&#34;: stix_relation_result[&#34;id&#34;],
            &#34;type&#34;: stix_relation_result[&#34;entity_type&#34;],
        }
    else:
        return None

    # Add external references
    for external_reference_id in external_references_ids:
        self.opencti.stix_entity.add_external_reference(
            id=stix_relation_result[&#34;id&#34;],
            external_reference_id=external_reference_id,
        )
        if external_reference_id in reports:
            self.opencti.report.add_stix_entity(
                id=reports[external_reference_id][&#34;id&#34;],
                entity_id=stix_relation_result[&#34;id&#34;],
            )
            self.opencti.report.add_stix_entity(
                id=reports[external_reference_id][&#34;id&#34;], entity_id=source_id,
            )
            self.opencti.report.add_stix_entity(
                id=reports[external_reference_id][&#34;id&#34;], entity_id=target_id,
            )</code></pre>
</details>
</dd>
<dt id="pycti.utils.opencti_stix2.OpenCTIStix2.pick_aliases"><code class="name flex">
<span>def <span class="ident">pick_aliases</span></span>(<span>self, stix_object)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pick_aliases(self, stix_object):
    # Add aliases
    if CustomProperties.ALIASES in stix_object:
        return stix_object[CustomProperties.ALIASES]
    elif &#34;x_mitre_aliases&#34; in stix_object:
        return stix_object[&#34;x_mitre_aliases&#34;]
    elif &#34;x_amitt_aliases&#34; in stix_object:
        return stix_object[&#34;x_amitt_aliases&#34;]
    elif &#34;aliases&#34; in stix_object:
        return stix_object[&#34;aliases&#34;]
    return None</code></pre>
</details>
</dd>
<dt id="pycti.utils.opencti_stix2.OpenCTIStix2.prepare_export"><code class="name flex">
<span>def <span class="ident">prepare_export</span></span>(<span>self, entity, stix_object, mode='simple', max_marking_definition_entity=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepare_export(
    self, entity, stix_object, mode=&#34;simple&#34;, max_marking_definition_entity=None
):
    if (
        self.check_max_marking_definition(
            max_marking_definition_entity, entity[&#34;markingDefinitions&#34;]
        )
        is False
    ):
        self.opencti.log(
            &#34;info&#34;,
            &#34;Marking definitions of &#34;
            + stix_object[&#34;type&#34;]
            + &#39; &#34;&#39;
            + stix_object[&#34;name&#34;]
            + &#39;&#34; are less than max definition, not exporting.&#39;,
        )
        return []
    result = []
    objects_to_get = []
    relations_to_get = []
    if &#34;createdByRef&#34; in entity and entity[&#34;createdByRef&#34;] is not None:
        entity_created_by_ref = entity[&#34;createdByRef&#34;]
        if entity_created_by_ref[&#34;entity_type&#34;] == &#34;user&#34;:
            identity_class = &#34;individual&#34;
        elif entity_created_by_ref[&#34;entity_type&#34;] == &#34;sector&#34;:
            identity_class = &#34;class&#34;
        else:
            identity_class = entity_created_by_ref[&#34;entity_type&#34;]

        created_by_ref = dict()
        created_by_ref[&#34;id&#34;] = entity_created_by_ref[&#34;stix_id_key&#34;]
        created_by_ref[&#34;type&#34;] = &#34;identity&#34;
        created_by_ref[&#34;name&#34;] = entity_created_by_ref[&#34;name&#34;]
        created_by_ref[&#34;identity_class&#34;] = identity_class
        if self.opencti.not_empty(entity_created_by_ref[&#34;stix_label&#34;]):
            created_by_ref[&#34;labels&#34;] = entity_created_by_ref[&#34;stix_label&#34;]
        else:
            created_by_ref[&#34;labels&#34;] = [&#34;identity&#34;]
        created_by_ref[&#34;created&#34;] = self.format_date(
            entity_created_by_ref[&#34;created&#34;]
        )
        created_by_ref[&#34;modified&#34;] = self.format_date(
            entity_created_by_ref[&#34;modified&#34;]
        )
        if (
            entity_created_by_ref[&#34;entity_type&#34;] == &#34;organization&#34;
            and &#34;organization_class&#34; in entity_created_by_ref
        ):
            created_by_ref[CustomProperties.ORG_CLASS] = entity_created_by_ref[
                &#34;organization_class&#34;
            ]
        if self.opencti.not_empty(entity_created_by_ref[&#34;alias&#34;]):
            created_by_ref[CustomProperties.ALIASES] = entity_created_by_ref[
                &#34;alias&#34;
            ]
        created_by_ref[CustomProperties.IDENTITY_TYPE] = entity_created_by_ref[
            &#34;entity_type&#34;
        ]
        created_by_ref[CustomProperties.ID] = entity_created_by_ref[&#34;id&#34;]

        stix_object[&#34;created_by_ref&#34;] = created_by_ref[&#34;id&#34;]
        result.append(created_by_ref)
    if &#34;markingDefinitions&#34; in entity and len(entity[&#34;markingDefinitions&#34;]) &gt; 0:
        marking_definitions = []
        for entity_marking_definition in entity[&#34;markingDefinitions&#34;]:
            marking_definition = {
                &#34;id&#34;: entity_marking_definition[&#34;stix_id_key&#34;],
                &#34;type&#34;: &#34;marking-definition&#34;,
                &#34;definition_type&#34;: entity_marking_definition[
                    &#34;definition_type&#34;
                ].lower(),
                &#34;definition&#34;: {
                    entity_marking_definition[
                        &#34;definition_type&#34;
                    ]: entity_marking_definition[&#34;definition&#34;]
                },
                &#34;created&#34;: entity_marking_definition[&#34;created&#34;],
                CustomProperties.MODIFIED: entity_marking_definition[&#34;modified&#34;],
                CustomProperties.ID: entity_marking_definition[&#34;id&#34;],
            }
            marking_definitions.append(marking_definition[&#34;id&#34;])
            result.append(marking_definition)
        stix_object[&#34;object_marking_refs&#34;] = marking_definitions
    if &#34;tags&#34; in entity and len(entity[&#34;tags&#34;]) &gt; 0:
        tags = []
        for entity_tag in entity[&#34;tags&#34;]:
            tag = dict()
            tag[&#34;id&#34;] = entity_tag[&#34;id&#34;]
            tag[&#34;tag_type&#34;] = entity_tag[&#34;tag_type&#34;]
            tag[&#34;value&#34;] = entity_tag[&#34;value&#34;]
            tag[&#34;color&#34;] = entity_tag[&#34;color&#34;]
            tags.append(tag)
        stix_object[CustomProperties.TAG_TYPE] = tags
    if &#34;killChainPhases&#34; in entity and len(entity[&#34;killChainPhases&#34;]) &gt; 0:
        kill_chain_phases = []
        for entity_kill_chain_phase in entity[&#34;killChainPhases&#34;]:
            kill_chain_phase = {
                &#34;id&#34;: entity_kill_chain_phase[&#34;stix_id_key&#34;],
                &#34;kill_chain_name&#34;: entity_kill_chain_phase[&#34;kill_chain_name&#34;],
                &#34;phase_name&#34;: entity_kill_chain_phase[&#34;phase_name&#34;],
                CustomProperties.ID: entity_kill_chain_phase[&#34;id&#34;],
                CustomProperties.PHASE_ORDER: entity_kill_chain_phase[
                    &#34;phase_order&#34;
                ],
                CustomProperties.CREATED: entity_kill_chain_phase[&#34;created&#34;],
                CustomProperties.MODIFIED: entity_kill_chain_phase[&#34;modified&#34;],
            }
            kill_chain_phases.append(kill_chain_phase)
        stix_object[&#34;kill_chain_phases&#34;] = kill_chain_phases
    if &#34;externalReferences&#34; in entity and len(entity[&#34;externalReferences&#34;]) &gt; 0:
        external_references = []
        for entity_external_reference in entity[&#34;externalReferences&#34;]:
            external_reference = dict()
            external_reference[&#34;id&#34;] = entity_external_reference[&#34;stix_id_key&#34;]
            if self.opencti.not_empty(entity_external_reference[&#34;source_name&#34;]):
                external_reference[&#34;source_name&#34;] = entity_external_reference[
                    &#34;source_name&#34;
                ]
            if self.opencti.not_empty(entity_external_reference[&#34;description&#34;]):
                external_reference[&#34;description&#34;] = entity_external_reference[
                    &#34;description&#34;
                ]
            if self.opencti.not_empty(entity_external_reference[&#34;url&#34;]):
                external_reference[&#34;url&#34;] = entity_external_reference[&#34;url&#34;]
            if self.opencti.not_empty(entity_external_reference[&#34;hash&#34;]):
                external_reference[&#34;hash&#34;] = entity_external_reference[&#34;hash&#34;]
            if self.opencti.not_empty(entity_external_reference[&#34;external_id&#34;]):
                external_reference[&#34;external_id&#34;] = entity_external_reference[
                    &#34;external_id&#34;
                ]
            external_reference[CustomProperties.ID] = entity_external_reference[
                &#34;id&#34;
            ]
            external_reference[
                CustomProperties.CREATED
            ] = entity_external_reference[&#34;created&#34;]
            external_reference[
                CustomProperties.MODIFIED
            ] = entity_external_reference[&#34;modified&#34;]
            external_references.append(external_reference)
        stix_object[&#34;external_references&#34;] = external_references
    if &#34;objectRefs&#34; in entity and len(entity[&#34;objectRefs&#34;]) &gt; 0:
        object_refs = []
        objects_to_get = entity[&#34;objectRefs&#34;]
        for entity_object_ref in entity[&#34;objectRefs&#34;]:
            object_refs.append(entity_object_ref[&#34;stix_id_key&#34;])
        if &#34;relationRefs&#34; in entity and len(entity[&#34;relationRefs&#34;]) &gt; 0:
            relations_to_get = entity[&#34;relationRefs&#34;]
            for entity_relation_ref in entity[&#34;relationRefs&#34;]:
                if entity_relation_ref[&#34;stix_id_key&#34;] not in object_refs:
                    object_refs.append(entity_relation_ref[&#34;stix_id_key&#34;])
        stix_object[&#34;object_refs&#34;] = object_refs

    uuids = []
    for x in result:
        uuids.append(x[&#34;id&#34;])

    observables_stix_ids = []
    observable_object_data = None
    if &#34;observableRefs&#34; in entity and len(entity[&#34;observableRefs&#34;]) &gt; 0:
        observable_object_data = self.export_stix_observables(entity)
        if observable_object_data is not None:
            observable_object_bundle = self.filter_objects(
                uuids, [observable_object_data[&#34;observedData&#34;]]
            )
            uuids = uuids + [x[&#34;id&#34;] for x in observable_object_bundle]
            result = result + observable_object_bundle
            observables_stix_ids = (
                observables_stix_ids + observable_object_data[&#34;stixIds&#34;]
            )
            if stix_object[&#34;type&#34;] == &#34;report&#34;:
                if &#34;object_refs&#34; in stix_object:
                    stix_object[&#34;object_refs&#34;].append(
                        observable_object_data[&#34;observedData&#34;][&#34;id&#34;]
                    )
                else:
                    stix_object[&#34;object_refs&#34;] = [
                        observable_object_data[&#34;observedData&#34;][&#34;id&#34;]
                    ]
    result.append(stix_object)

    if mode == &#34;simple&#34;:
        return result
    elif mode == &#34;full&#34;:
        # Get extra relations
        stix_relations = self.opencti.stix_relation.list(
            fromId=entity[&#34;id&#34;], forceNatural=True
        )
        for stix_relation in stix_relations:
            if self.check_max_marking_definition(
                max_marking_definition_entity, stix_relation[&#34;markingDefinitions&#34;]
            ):
                if stix_relation[&#34;to&#34;][&#34;id&#34;] == entity[&#34;id&#34;]:
                    other_side_entity = stix_relation[&#34;from&#34;]
                else:
                    other_side_entity = stix_relation[&#34;to&#34;]
                objects_to_get.append(other_side_entity)
                if other_side_entity[&#34;stix_id_key&#34;] in observables_stix_ids:
                    other_side_entity[&#34;stix_id_key&#34;] = observable_object_data[
                        &#34;observedData&#34;
                    ][&#34;id&#34;]
                relation_object_data = self.opencti.stix_relation.to_stix2(
                    entity=stix_relation
                )
                relation_object_bundle = self.filter_objects(
                    uuids, relation_object_data
                )
                uuids = uuids + [x[&#34;id&#34;] for x in relation_object_bundle]
                result = result + relation_object_bundle
            else:
                self.opencti.log(
                    &#34;info&#34;,
                    &#34;Marking definitions of &#34;
                    + stix_relation[&#34;entity_type&#34;]
                    + &#39; &#34;&#39;
                    + stix_relation[&#34;id&#34;]
                    + &#39;&#34; are less than max definition, not exporting the relation AND the target entity.&#39;,
                )

        # Export
        exporter = {
            &#34;identity&#34;: self.opencti.identity.to_stix2,
            &#34;threat-actor&#34;: self.opencti.threat_actor.to_stix2,
            &#34;intrusion-set&#34;: self.opencti.intrusion_set.to_stix2,
            &#34;campaign&#34;: self.opencti.campaign.to_stix2,
            &#34;incident&#34;: self.opencti.incident.to_stix2,
            &#34;malware&#34;: self.opencti.malware.to_stix2,
            &#34;tool&#34;: self.opencti.tool.to_stix2,
            &#34;vulnerability&#34;: self.opencti.vulnerability.to_stix2,
            &#34;attack-pattern&#34;: self.opencti.attack_pattern.to_stix2,
            &#34;course-of-action&#34;: self.opencti.course_of_action.to_stix2,
            &#34;report&#34;: self.opencti.report.to_stix2,
            &#34;note&#34;: self.opencti.note.to_stix2,
            &#34;opinion&#34;: self.opencti.opinion.to_stix2,
            &#34;indicator&#34;: self.opencti.indicator.to_stix2,
        }

        # Get extra objects
        for entity_object in objects_to_get:
            # Map types
            if IdentityTypes.has_value(entity_object[&#34;entity_type&#34;]):
                entity_object[&#34;entity_type&#34;] = &#34;identity&#34;
            do_export = exporter.get(
                entity_object[&#34;entity_type&#34;],
                lambda **kwargs: self.unknown_type(
                    {&#34;type&#34;: entity_object[&#34;entity_type&#34;]}
                ),
            )
            entity_object_data = do_export(id=entity_object[&#34;id&#34;])
            # Add to result
            entity_object_bundle = self.filter_objects(uuids, entity_object_data)
            uuids = uuids + [x[&#34;id&#34;] for x in entity_object_bundle]
            result = result + entity_object_bundle
        for relation_object in relations_to_get:
            relation_object_data = self.opencti.stix_relation.to_stix2(
                id=relation_object[&#34;id&#34;]
            )
            relation_object_bundle = self.filter_objects(
                uuids, relation_object_data
            )
            uuids = uuids + [x[&#34;id&#34;] for x in relation_object_bundle]
            result = result + relation_object_bundle

        # Get extra reports
        &#34;&#34;&#34;
        for uuid in uuids:
            if &#34;marking-definition&#34; not in uuid:
                reports = self.opencti.stix_entity.reports(id=uuid)
                for report in reports:
                    report_object_data = self.opencti.report.to_stix2(
                        entity=report,
                        mode=&#34;simple&#34;,
                        max_marking_definition_entity=max_marking_definition_entity,
                    )
                    report_object_bundle = self.filter_objects(
                        uuids, report_object_data
                    )
                    uuids = uuids + [x[&#34;id&#34;] for x in report_object_bundle]
                    result = result + report_object_bundle
        &#34;&#34;&#34;

        # Refilter all the reports object refs
        final_result = []
        for entity in result:
            if entity[&#34;type&#34;] == &#34;report&#34;:
                if &#34;object_refs&#34; in entity:
                    entity[&#34;object_refs&#34;] = [
                        k for k in entity[&#34;object_refs&#34;] if k in uuids
                    ]
                final_result.append(entity)
            else:
                final_result.append(entity)
        return final_result
    else:
        return []</code></pre>
</details>
</dd>
<dt id="pycti.utils.opencti_stix2.OpenCTIStix2.resolve_author"><code class="name flex">
<span>def <span class="ident">resolve_author</span></span>(<span>self, title)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resolve_author(self, title):
    if &#34;fireeye&#34; in title.lower() or &#34;mandiant&#34; in title.lower():
        return self.get_author(&#34;FireEye&#34;)
    if &#34;eset&#34; in title.lower():
        return self.get_author(&#34;ESET&#34;)
    if &#34;dragos&#34; in title.lower():
        return self.get_author(&#34;Dragos&#34;)
    if &#34;us-cert&#34; in title.lower():
        return self.get_author(&#34;US-CERT&#34;)
    if (
        &#34;unit 42&#34; in title.lower()
        or &#34;unit42&#34; in title.lower()
        or &#34;palo alto&#34; in title.lower()
    ):
        return self.get_author(&#34;Palo Alto Networks&#34;)
    if &#34;accenture&#34; in title.lower():
        return self.get_author(&#34;Accenture&#34;)
    if &#34;symantec&#34; in title.lower():
        return self.get_author(&#34;Symantec&#34;)
    if &#34;trendmicro&#34; in title.lower() or &#34;trend micro&#34; in title.lower():
        return self.get_author(&#34;Trend Micro&#34;)
    if &#34;mcafee&#34; in title.lower():
        return self.get_author(&#34;McAfee&#34;)
    if &#34;crowdstrike&#34; in title.lower():
        return self.get_author(&#34;CrowdStrike&#34;)
    if &#34;securelist&#34; in title.lower() or &#34;kaspersky&#34; in title.lower():
        return self.get_author(&#34;Kaspersky&#34;)
    if &#34;f-secure&#34; in title.lower():
        return self.get_author(&#34;F-Secure&#34;)
    if &#34;checkpoint&#34; in title.lower():
        return self.get_author(&#34;CheckPoint&#34;)
    if &#34;talos&#34; in title.lower():
        return self.get_author(&#34;Cisco Talos&#34;)
    if &#34;secureworks&#34; in title.lower():
        return self.get_author(&#34;Dell SecureWorks&#34;)
    if &#34;microsoft&#34; in title.lower():
        return self.get_author(&#34;Microsoft&#34;)
    if &#34;mitre att&amp;ck&#34; in title.lower():
        return self.get_author(&#34;The MITRE Corporation&#34;)
    return None</code></pre>
</details>
</dd>
<dt id="pycti.utils.opencti_stix2.OpenCTIStix2.unknown_type"><code class="name flex">
<span>def <span class="ident">unknown_type</span></span>(<span>self, stix_object)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unknown_type(self, stix_object):
    self.opencti.log(
        &#34;error&#34;,
        &#39;Unknown object type &#34;&#39; + stix_object[&#34;type&#34;] + &#39;&#34;, doing nothing...&#39;,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pycti.utils" href="index.html">pycti.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pycti.utils.opencti_stix2.OpenCTIStix2" href="#pycti.utils.opencti_stix2.OpenCTIStix2">OpenCTIStix2</a></code></h4>
<ul class="">
<li><code><a title="pycti.utils.opencti_stix2.OpenCTIStix2.check_max_marking_definition" href="#pycti.utils.opencti_stix2.OpenCTIStix2.check_max_marking_definition">check_max_marking_definition</a></code></li>
<li><code><a title="pycti.utils.opencti_stix2.OpenCTIStix2.convert_markdown" href="#pycti.utils.opencti_stix2.OpenCTIStix2.convert_markdown">convert_markdown</a></code></li>
<li><code><a title="pycti.utils.opencti_stix2.OpenCTIStix2.create_attack_pattern" href="#pycti.utils.opencti_stix2.OpenCTIStix2.create_attack_pattern">create_attack_pattern</a></code></li>
<li><code><a title="pycti.utils.opencti_stix2.OpenCTIStix2.create_campaign" href="#pycti.utils.opencti_stix2.OpenCTIStix2.create_campaign">create_campaign</a></code></li>
<li><code><a title="pycti.utils.opencti_stix2.OpenCTIStix2.create_course_of_action" href="#pycti.utils.opencti_stix2.OpenCTIStix2.create_course_of_action">create_course_of_action</a></code></li>
<li><code><a title="pycti.utils.opencti_stix2.OpenCTIStix2.create_identity" href="#pycti.utils.opencti_stix2.OpenCTIStix2.create_identity">create_identity</a></code></li>
<li><code><a title="pycti.utils.opencti_stix2.OpenCTIStix2.create_incident" href="#pycti.utils.opencti_stix2.OpenCTIStix2.create_incident">create_incident</a></code></li>
<li><code><a title="pycti.utils.opencti_stix2.OpenCTIStix2.create_indicator" href="#pycti.utils.opencti_stix2.OpenCTIStix2.create_indicator">create_indicator</a></code></li>
<li><code><a title="pycti.utils.opencti_stix2.OpenCTIStix2.create_intrusion_set" href="#pycti.utils.opencti_stix2.OpenCTIStix2.create_intrusion_set">create_intrusion_set</a></code></li>
<li><code><a title="pycti.utils.opencti_stix2.OpenCTIStix2.create_malware" href="#pycti.utils.opencti_stix2.OpenCTIStix2.create_malware">create_malware</a></code></li>
<li><code><a title="pycti.utils.opencti_stix2.OpenCTIStix2.create_marking_definition" href="#pycti.utils.opencti_stix2.OpenCTIStix2.create_marking_definition">create_marking_definition</a></code></li>
<li><code><a title="pycti.utils.opencti_stix2.OpenCTIStix2.create_note" href="#pycti.utils.opencti_stix2.OpenCTIStix2.create_note">create_note</a></code></li>
<li><code><a title="pycti.utils.opencti_stix2.OpenCTIStix2.create_opinion" href="#pycti.utils.opencti_stix2.OpenCTIStix2.create_opinion">create_opinion</a></code></li>
<li><code><a title="pycti.utils.opencti_stix2.OpenCTIStix2.create_report" href="#pycti.utils.opencti_stix2.OpenCTIStix2.create_report">create_report</a></code></li>
<li><code><a title="pycti.utils.opencti_stix2.OpenCTIStix2.create_threat_actor" href="#pycti.utils.opencti_stix2.OpenCTIStix2.create_threat_actor">create_threat_actor</a></code></li>
<li><code><a title="pycti.utils.opencti_stix2.OpenCTIStix2.create_tool" href="#pycti.utils.opencti_stix2.OpenCTIStix2.create_tool">create_tool</a></code></li>
<li><code><a title="pycti.utils.opencti_stix2.OpenCTIStix2.create_vulnerability" href="#pycti.utils.opencti_stix2.OpenCTIStix2.create_vulnerability">create_vulnerability</a></code></li>
<li><code><a title="pycti.utils.opencti_stix2.OpenCTIStix2.export_entity" href="#pycti.utils.opencti_stix2.OpenCTIStix2.export_entity">export_entity</a></code></li>
<li><code><a title="pycti.utils.opencti_stix2.OpenCTIStix2.export_list" href="#pycti.utils.opencti_stix2.OpenCTIStix2.export_list">export_list</a></code></li>
<li><code><a title="pycti.utils.opencti_stix2.OpenCTIStix2.export_stix_observables" href="#pycti.utils.opencti_stix2.OpenCTIStix2.export_stix_observables">export_stix_observables</a></code></li>
<li><code><a title="pycti.utils.opencti_stix2.OpenCTIStix2.extract_embedded_relationships" href="#pycti.utils.opencti_stix2.OpenCTIStix2.extract_embedded_relationships">extract_embedded_relationships</a></code></li>
<li><code><a title="pycti.utils.opencti_stix2.OpenCTIStix2.filter_objects" href="#pycti.utils.opencti_stix2.OpenCTIStix2.filter_objects">filter_objects</a></code></li>
<li><code><a title="pycti.utils.opencti_stix2.OpenCTIStix2.format_date" href="#pycti.utils.opencti_stix2.OpenCTIStix2.format_date">format_date</a></code></li>
<li><code><a title="pycti.utils.opencti_stix2.OpenCTIStix2.get_author" href="#pycti.utils.opencti_stix2.OpenCTIStix2.get_author">get_author</a></code></li>
<li><code><a title="pycti.utils.opencti_stix2.OpenCTIStix2.import_bundle" href="#pycti.utils.opencti_stix2.OpenCTIStix2.import_bundle">import_bundle</a></code></li>
<li><code><a title="pycti.utils.opencti_stix2.OpenCTIStix2.import_bundle_from_file" href="#pycti.utils.opencti_stix2.OpenCTIStix2.import_bundle_from_file">import_bundle_from_file</a></code></li>
<li><code><a title="pycti.utils.opencti_stix2.OpenCTIStix2.import_bundle_from_json" href="#pycti.utils.opencti_stix2.OpenCTIStix2.import_bundle_from_json">import_bundle_from_json</a></code></li>
<li><code><a title="pycti.utils.opencti_stix2.OpenCTIStix2.import_object" href="#pycti.utils.opencti_stix2.OpenCTIStix2.import_object">import_object</a></code></li>
<li><code><a title="pycti.utils.opencti_stix2.OpenCTIStix2.import_observables" href="#pycti.utils.opencti_stix2.OpenCTIStix2.import_observables">import_observables</a></code></li>
<li><code><a title="pycti.utils.opencti_stix2.OpenCTIStix2.import_relationship" href="#pycti.utils.opencti_stix2.OpenCTIStix2.import_relationship">import_relationship</a></code></li>
<li><code><a title="pycti.utils.opencti_stix2.OpenCTIStix2.pick_aliases" href="#pycti.utils.opencti_stix2.OpenCTIStix2.pick_aliases">pick_aliases</a></code></li>
<li><code><a title="pycti.utils.opencti_stix2.OpenCTIStix2.prepare_export" href="#pycti.utils.opencti_stix2.OpenCTIStix2.prepare_export">prepare_export</a></code></li>
<li><code><a title="pycti.utils.opencti_stix2.OpenCTIStix2.resolve_author" href="#pycti.utils.opencti_stix2.OpenCTIStix2.resolve_author">resolve_author</a></code></li>
<li><code><a title="pycti.utils.opencti_stix2.OpenCTIStix2.unknown_type" href="#pycti.utils.opencti_stix2.OpenCTIStix2.unknown_type">unknown_type</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>